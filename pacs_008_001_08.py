#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Mar 31 15:11:15 2024 by generateDS.py version 2.43.3.
# Python 3.11.4 (main, Jul  4 2023, 05:25:16) [GCC 12.2.0]
#
# Command line options:
#   ('--member-specs', 'dict')
#   ('-o', 'pacs_008_001_08.py')
#
# Command line arguments:
#   xsd/pacs.008/pacs.008.001.08.xsd
#
# Command line:
#   /home/vscode/.local/bin/generateDS --member-specs="dict" -o "pacs_008_001_08.py" xsd/pacs.008/pacs.008.001.08.xsd
#
# Current working directory (os.getcwd()):
#   msg_gen
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class AddressType2Code(str, Enum):
    ADDR='ADDR'
    PBOX='PBOX'
    HOME='HOME'
    BIZZ='BIZZ'
    MLTO='MLTO'
    DLVY='DLVY'


class ChargeBearerType1Code(str, Enum):
    DEBT='DEBT'
    CRED='CRED'
    SHAR='SHAR'
    SLEV='SLEV'


class ClearingChannel2Code(str, Enum):
    RTGS='RTGS'
    RTNS='RTNS'
    MPNS='MPNS'
    BOOK='BOOK'


class CreditDebitCode(str, Enum):
    CRDT='CRDT'
    DBIT='DBIT'


class DocumentType3Code(str, Enum):
    RADM='RADM'
    RPIN='RPIN'
    FXDR='FXDR'
    DISP='DISP'
    PUOR='PUOR'
    SCOR='SCOR'


class DocumentType6Code(str, Enum):
    MSIN='MSIN'
    CNFA='CNFA'
    DNFA='DNFA'
    CINV='CINV'
    CREN='CREN'
    DEBN='DEBN'
    HIRI='HIRI'
    SBIN='SBIN'
    CMCN='CMCN'
    SOAC='SOAC'
    DISP='DISP'
    BOLD='BOLD'
    VCHR='VCHR'
    AROI='AROI'
    TSUT='TSUT'
    PUOR='PUOR'


class Instruction3Code(str, Enum):
    CHQB='CHQB'
    HOLD='HOLD'
    PHOB='PHOB'
    TELB='TELB'


class Instruction4Code(str, Enum):
    PHOA='PHOA'
    TELA='TELA'


class NamePrefix2Code(str, Enum):
    DOCT='DOCT'
    MADM='MADM'
    MISS='MISS'
    MIST='MIST'
    MIKS='MIKS'


class PreferredContactMethod1Code(str, Enum):
    LETT='LETT'
    MAIL='MAIL'
    PHON='PHON'
    FAXX='FAXX'
    CELL='CELL'


class Priority2Code(str, Enum):
    HIGH='HIGH'
    NORM='NORM'


class Priority3Code(str, Enum):
    URGT='URGT'
    HIGH='HIGH'
    NORM='NORM'


class RegulatoryReportingType1Code(str, Enum):
    CRED='CRED'
    DEBT='DEBT'
    BOTH='BOTH'


class RemittanceLocationMethod2Code(str, Enum):
    FAXI='FAXI'
    EDIC='EDIC'
    URID='URID'
    EMAL='EMAL'
    POST='POST'
    SMSM='SMSM'


class SettlementMethod1Code(str, Enum):
    INDA='INDA'
    INGA='INGA'
    COVE='COVE'
    CLRG='CLRG'


class TaxRecordPeriod1Code(str, Enum):
    MM_01='MM01'
    MM_02='MM02'
    MM_03='MM03'
    MM_04='MM04'
    MM_05='MM05'
    MM_06='MM06'
    MM_07='MM07'
    MM_08='MM08'
    MM_09='MM09'
    MM_10='MM10'
    MM_11='MM11'
    MM_12='MM12'
    QTR_1='QTR1'
    QTR_2='QTR2'
    QTR_3='QTR3'
    QTR_4='QTR4'
    HLF_1='HLF1'
    HLF_2='HLF2'


#
# Start data representation classes
#
class AccountIdentification4Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'IBAN': MemberSpec_('IBAN', ['IBAN2007Identifier', 'xs:string'], 0, 0, {'name': 'IBAN', 'type': 'xs:string'}, 1),
        'Othr': MemberSpec_('Othr', 'GenericAccountIdentification1', 0, 0, {'name': 'Othr', 'type': 'GenericAccountIdentification1'}, 1),
    }
    subclass = None
    superclass = None
    def __init__(self, IBAN=None, Othr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IBAN = IBAN
        self.validate_IBAN2007Identifier(self.IBAN)
        self.IBAN_nsprefix_ = None
        self.Othr = Othr
        self.Othr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountIdentification4Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountIdentification4Choice.subclass:
            return AccountIdentification4Choice.subclass(*args_, **kwargs_)
        else:
            return AccountIdentification4Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IBAN(self):
        return self.IBAN
    def set_IBAN(self, IBAN):
        self.IBAN = IBAN
    def get_Othr(self):
        return self.Othr
    def set_Othr(self, Othr):
        self.Othr = Othr
    def validate_IBAN2007Identifier(self, value):
        result = True
        # Validate type IBAN2007Identifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IBAN2007Identifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IBAN2007Identifier_patterns_, ))
                result = False
        return result
    validate_IBAN2007Identifier_patterns_ = [['^([A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30})$']]
    def has__content(self):
        if (
            self.IBAN is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='AccountIdentification4Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountIdentification4Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccountIdentification4Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccountIdentification4Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccountIdentification4Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccountIdentification4Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='AccountIdentification4Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IBAN is not None:
            namespaceprefix_ = self.IBAN_nsprefix_ + ':' if (UseCapturedNS_ and self.IBAN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIBAN>%s</%sIBAN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IBAN), input_name='IBAN')), namespaceprefix_ , eol_))
        if self.Othr is not None:
            namespaceprefix_ = self.Othr_nsprefix_ + ':' if (UseCapturedNS_ and self.Othr_nsprefix_) else ''
            self.Othr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Othr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IBAN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IBAN')
            value_ = self.gds_validate_string(value_, node, 'IBAN')
            self.IBAN = value_
            self.IBAN_nsprefix_ = child_.prefix
            # validate type IBAN2007Identifier
            self.validate_IBAN2007Identifier(self.IBAN)
        elif nodeName_ == 'Othr':
            obj_ = GenericAccountIdentification1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class AccountIdentification4Choice


class AccountSchemeName1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalAccountIdentification1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 2),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 2),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalAccountIdentification1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountSchemeName1Choice.subclass:
            return AccountSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return AccountSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalAccountIdentification1Code(self, value):
        result = True
        # Validate type ExternalAccountIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalAccountIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalAccountIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='AccountSchemeName1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccountSchemeName1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccountSchemeName1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccountSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccountSchemeName1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='AccountSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalAccountIdentification1Code
            self.validate_ExternalAccountIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class AccountSchemeName1Choice


class ActiveCurrencyAndAmount(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Ccy': MemberSpec_('Ccy', 'ActiveCurrencyCode', 0, 0, {'use': 'required', 'name': 'Ccy'}),
        'valueOf_': MemberSpec_('valueOf_', ['ActiveCurrencyAndAmount_SimpleType', 'xs:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Ccy=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Ccy = _cast(None, Ccy)
        self.Ccy_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveCurrencyAndAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveCurrencyAndAmount.subclass:
            return ActiveCurrencyAndAmount.subclass(*args_, **kwargs_)
        else:
            return ActiveCurrencyAndAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Ccy(self):
        return self.Ccy
    def set_Ccy(self, Ccy):
        self.Ccy = Ccy
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_ActiveCurrencyAndAmount_SimpleType(self, value):
        result = True
        # Validate type ActiveCurrencyAndAmount_SimpleType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ActiveCurrencyAndAmount_SimpleType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on ActiveCurrencyAndAmount_SimpleType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ActiveCurrencyCode(self, value):
        # Validate type ActiveCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveCurrencyCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActiveCurrencyCode_patterns_, ))
    validate_ActiveCurrencyCode_patterns_ = [['^([A-Z]{3,3})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveCurrencyAndAmount', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveCurrencyAndAmount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveCurrencyAndAmount':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveCurrencyAndAmount')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveCurrencyAndAmount'):
        if self.Ccy is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            outfile.write(' Ccy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Ccy), input_name='Ccy')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveCurrencyAndAmount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ccy', node)
        if value is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            self.Ccy = value
            self.validate_ActiveCurrencyCode(self.Ccy)    # validate type ActiveCurrencyCode
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ActiveCurrencyAndAmount


class ActiveOrHistoricCurrencyAndAmount(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Ccy': MemberSpec_('Ccy', 'ActiveOrHistoricCurrencyCode', 0, 0, {'use': 'required', 'name': 'Ccy'}),
        'valueOf_': MemberSpec_('valueOf_', ['ActiveOrHistoricCurrencyAndAmount_SimpleType', 'xs:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Ccy=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Ccy = _cast(None, Ccy)
        self.Ccy_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveOrHistoricCurrencyAndAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveOrHistoricCurrencyAndAmount.subclass:
            return ActiveOrHistoricCurrencyAndAmount.subclass(*args_, **kwargs_)
        else:
            return ActiveOrHistoricCurrencyAndAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Ccy(self):
        return self.Ccy
    def set_Ccy(self, Ccy):
        self.Ccy = Ccy
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_ActiveOrHistoricCurrencyAndAmount_SimpleType(self, value):
        result = True
        # Validate type ActiveOrHistoricCurrencyAndAmount_SimpleType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ActiveOrHistoricCurrencyAndAmount_SimpleType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on ActiveOrHistoricCurrencyAndAmount_SimpleType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^([A-Z]{3,3})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveOrHistoricCurrencyAndAmount', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveOrHistoricCurrencyAndAmount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveOrHistoricCurrencyAndAmount':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveOrHistoricCurrencyAndAmount')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveOrHistoricCurrencyAndAmount'):
        if self.Ccy is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            outfile.write(' Ccy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Ccy), input_name='Ccy')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveOrHistoricCurrencyAndAmount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ccy', node)
        if value is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            self.Ccy = value
            self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)    # validate type ActiveOrHistoricCurrencyCode
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ActiveOrHistoricCurrencyAndAmount


class AddressType3Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['AddressType2Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 3),
        'Prtry': MemberSpec_('Prtry', 'GenericIdentification30', 0, 0, {'name': 'Prtry', 'type': 'GenericIdentification30'}, 3),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_AddressType2Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType3Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType3Choice.subclass:
            return AddressType3Choice.subclass(*args_, **kwargs_)
        else:
            return AddressType3Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_AddressType2Code(self, value):
        result = True
        # Validate type AddressType2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADDR', 'PBOX', 'HOME', 'BIZZ', 'MLTO', 'DLVY']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressType2Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='AddressType3Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType3Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AddressType3Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType3Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AddressType3Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType3Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='AddressType3Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            self.Prtry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prtry', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type AddressType2Code
            self.validate_AddressType2Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = GenericIdentification30.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
# end class AddressType3Choice


class BranchAndFinancialInstitutionIdentification6(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'FinInstnId': MemberSpec_('FinInstnId', 'FinancialInstitutionIdentification18', 0, 0, {'name': 'FinInstnId', 'type': 'FinancialInstitutionIdentification18'}, None),
        'BrnchId': MemberSpec_('BrnchId', 'BranchData3', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'BrnchId', 'type': 'BranchData3'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, FinInstnId=None, BrnchId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FinInstnId = FinInstnId
        self.FinInstnId_nsprefix_ = None
        self.BrnchId = BrnchId
        self.BrnchId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchAndFinancialInstitutionIdentification6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchAndFinancialInstitutionIdentification6.subclass:
            return BranchAndFinancialInstitutionIdentification6.subclass(*args_, **kwargs_)
        else:
            return BranchAndFinancialInstitutionIdentification6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FinInstnId(self):
        return self.FinInstnId
    def set_FinInstnId(self, FinInstnId):
        self.FinInstnId = FinInstnId
    def get_BrnchId(self):
        return self.BrnchId
    def set_BrnchId(self, BrnchId):
        self.BrnchId = BrnchId
    def has__content(self):
        if (
            self.FinInstnId is not None or
            self.BrnchId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='BranchAndFinancialInstitutionIdentification6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BranchAndFinancialInstitutionIdentification6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BranchAndFinancialInstitutionIdentification6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BranchAndFinancialInstitutionIdentification6')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BranchAndFinancialInstitutionIdentification6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BranchAndFinancialInstitutionIdentification6'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='BranchAndFinancialInstitutionIdentification6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FinInstnId is not None:
            namespaceprefix_ = self.FinInstnId_nsprefix_ + ':' if (UseCapturedNS_ and self.FinInstnId_nsprefix_) else ''
            self.FinInstnId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FinInstnId', pretty_print=pretty_print)
        if self.BrnchId is not None:
            namespaceprefix_ = self.BrnchId_nsprefix_ + ':' if (UseCapturedNS_ and self.BrnchId_nsprefix_) else ''
            self.BrnchId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BrnchId', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FinInstnId':
            obj_ = FinancialInstitutionIdentification18.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FinInstnId = obj_
            obj_.original_tagname_ = 'FinInstnId'
        elif nodeName_ == 'BrnchId':
            obj_ = BranchData3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BrnchId = obj_
            obj_.original_tagname_ = 'BrnchId'
# end class BranchAndFinancialInstitutionIdentification6


class BranchData3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Id', 'type': 'xs:string'}, None),
        'LEI': MemberSpec_('LEI', ['LEIIdentifier', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'LEI', 'type': 'xs:string'}, None),
        'Nm': MemberSpec_('Nm', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nm', 'type': 'xs:string'}, None),
        'PstlAdr': MemberSpec_('PstlAdr', 'PostalAddress24', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PstlAdr', 'type': 'PostalAddress24'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, LEI=None, Nm=None, PstlAdr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.Id_nsprefix_ = None
        self.LEI = LEI
        self.validate_LEIIdentifier(self.LEI)
        self.LEI_nsprefix_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Nm_nsprefix_ = None
        self.PstlAdr = PstlAdr
        self.PstlAdr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchData3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchData3.subclass:
            return BranchData3.subclass(*args_, **kwargs_)
        else:
            return BranchData3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_LEI(self):
        return self.LEI
    def set_LEI(self, LEI):
        self.LEI = LEI
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def get_PstlAdr(self):
        return self.PstlAdr
    def set_PstlAdr(self, PstlAdr):
        self.PstlAdr = PstlAdr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_LEIIdentifier(self, value):
        result = True
        # Validate type LEIIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_LEIIdentifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LEIIdentifier_patterns_, ))
                result = False
        return result
    validate_LEIIdentifier_patterns_ = [['^([A-Z0-9]{18,18}[0-9]{2,2})$']]
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id is not None or
            self.LEI is not None or
            self.Nm is not None or
            self.PstlAdr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='BranchData3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BranchData3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BranchData3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BranchData3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BranchData3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BranchData3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='BranchData3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
        if self.LEI is not None:
            namespaceprefix_ = self.LEI_nsprefix_ + ':' if (UseCapturedNS_ and self.LEI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLEI>%s</%sLEI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LEI), input_name='LEI')), namespaceprefix_ , eol_))
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
        if self.PstlAdr is not None:
            namespaceprefix_ = self.PstlAdr_nsprefix_ + ':' if (UseCapturedNS_ and self.PstlAdr_nsprefix_) else ''
            self.PstlAdr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PstlAdr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'LEI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LEI')
            value_ = self.gds_validate_string(value_, node, 'LEI')
            self.LEI = value_
            self.LEI_nsprefix_ = child_.prefix
            # validate type LEIIdentifier
            self.validate_LEIIdentifier(self.LEI)
        elif nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
# end class BranchData3


class CashAccount38(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'AccountIdentification4Choice', 0, 0, {'name': 'Id', 'type': 'AccountIdentification4Choice'}, None),
        'Tp': MemberSpec_('Tp', 'CashAccountType2Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'CashAccountType2Choice'}, None),
        'Ccy': MemberSpec_('Ccy', ['ActiveOrHistoricCurrencyCode', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Ccy', 'type': 'xs:string'}, None),
        'Nm': MemberSpec_('Nm', ['Max70Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nm', 'type': 'xs:string'}, None),
        'Prxy': MemberSpec_('Prxy', 'ProxyAccountIdentification1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Prxy', 'type': 'ProxyAccountIdentification1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, Tp=None, Ccy=None, Nm=None, Prxy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Ccy = Ccy
        self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
        self.Ccy_nsprefix_ = None
        self.Nm = Nm
        self.validate_Max70Text(self.Nm)
        self.Nm_nsprefix_ = None
        self.Prxy = Prxy
        self.Prxy_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccount38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccount38.subclass:
            return CashAccount38.subclass(*args_, **kwargs_)
        else:
            return CashAccount38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Ccy(self):
        return self.Ccy
    def set_Ccy(self, Ccy):
        self.Ccy = Ccy
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def get_Prxy(self):
        return self.Prxy
    def set_Prxy(self, Prxy):
        self.Prxy = Prxy
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        result = True
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
                result = False
        return result
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^([A-Z]{3,3})$']]
    def validate_Max70Text(self, value):
        result = True
        # Validate type Max70Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max70Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max70Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id is not None or
            self.Tp is not None or
            self.Ccy is not None or
            self.Nm is not None or
            self.Prxy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CashAccount38', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CashAccount38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CashAccount38':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CashAccount38')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CashAccount38', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CashAccount38'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CashAccount38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Ccy is not None:
            namespaceprefix_ = self.Ccy_nsprefix_ + ':' if (UseCapturedNS_ and self.Ccy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCcy>%s</%sCcy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Ccy), input_name='Ccy')), namespaceprefix_ , eol_))
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
        if self.Prxy is not None:
            namespaceprefix_ = self.Prxy_nsprefix_ + ':' if (UseCapturedNS_ and self.Prxy_nsprefix_) else ''
            self.Prxy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prxy', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = AccountIdentification4Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Tp':
            obj_ = CashAccountType2Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Ccy':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ccy')
            value_ = self.gds_validate_string(value_, node, 'Ccy')
            self.Ccy = value_
            self.Ccy_nsprefix_ = child_.prefix
            # validate type ActiveOrHistoricCurrencyCode
            self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
        elif nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.Nm)
        elif nodeName_ == 'Prxy':
            obj_ = ProxyAccountIdentification1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prxy = obj_
            obj_.original_tagname_ = 'Prxy'
# end class CashAccount38


class CashAccountType2Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalCashAccountType1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 4),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 4),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalCashAccountType1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccountType2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccountType2Choice.subclass:
            return CashAccountType2Choice.subclass(*args_, **kwargs_)
        else:
            return CashAccountType2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalCashAccountType1Code(self, value):
        result = True
        # Validate type ExternalCashAccountType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalCashAccountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalCashAccountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CashAccountType2Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CashAccountType2Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CashAccountType2Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CashAccountType2Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CashAccountType2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CashAccountType2Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CashAccountType2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalCashAccountType1Code
            self.validate_ExternalCashAccountType1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CashAccountType2Choice


class CategoryPurpose1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalCategoryPurpose1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 5),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 5),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalCategoryPurpose1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryPurpose1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryPurpose1Choice.subclass:
            return CategoryPurpose1Choice.subclass(*args_, **kwargs_)
        else:
            return CategoryPurpose1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalCategoryPurpose1Code(self, value):
        result = True
        # Validate type ExternalCategoryPurpose1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalCategoryPurpose1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalCategoryPurpose1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CategoryPurpose1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CategoryPurpose1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CategoryPurpose1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CategoryPurpose1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CategoryPurpose1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CategoryPurpose1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CategoryPurpose1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalCategoryPurpose1Code
            self.validate_ExternalCategoryPurpose1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CategoryPurpose1Choice


class Charges7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Amt': MemberSpec_('Amt', 'ActiveOrHistoricCurrencyAndAmount', 0, 0, {'name': 'Amt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'Agt': MemberSpec_('Agt', 'BranchAndFinancialInstitutionIdentification6', 0, 0, {'name': 'Agt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Amt=None, Agt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Amt = Amt
        self.Amt_nsprefix_ = None
        self.Agt = Agt
        self.Agt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Charges7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Charges7.subclass:
            return Charges7.subclass(*args_, **kwargs_)
        else:
            return Charges7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Amt(self):
        return self.Amt
    def set_Amt(self, Amt):
        self.Amt = Amt
    def get_Agt(self):
        return self.Agt
    def set_Agt(self, Agt):
        self.Agt = Agt
    def has__content(self):
        if (
            self.Amt is not None or
            self.Agt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Charges7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Charges7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Charges7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Charges7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Charges7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Charges7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Charges7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amt is not None:
            namespaceprefix_ = self.Amt_nsprefix_ + ':' if (UseCapturedNS_ and self.Amt_nsprefix_) else ''
            self.Amt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amt', pretty_print=pretty_print)
        if self.Agt is not None:
            namespaceprefix_ = self.Agt_nsprefix_ + ':' if (UseCapturedNS_ and self.Agt_nsprefix_) else ''
            self.Agt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Agt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'Agt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Agt = obj_
            obj_.original_tagname_ = 'Agt'
# end class Charges7


class ClearingSystemIdentification2Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalClearingSystemIdentification1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 6),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 6),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalClearingSystemIdentification1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingSystemIdentification2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingSystemIdentification2Choice.subclass:
            return ClearingSystemIdentification2Choice.subclass(*args_, **kwargs_)
        else:
            return ClearingSystemIdentification2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalClearingSystemIdentification1Code(self, value):
        result = True
        # Validate type ExternalClearingSystemIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalClearingSystemIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalClearingSystemIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ClearingSystemIdentification2Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClearingSystemIdentification2Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClearingSystemIdentification2Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClearingSystemIdentification2Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClearingSystemIdentification2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClearingSystemIdentification2Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ClearingSystemIdentification2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalClearingSystemIdentification1Code
            self.validate_ExternalClearingSystemIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ClearingSystemIdentification2Choice


class ClearingSystemIdentification3Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalCashClearingSystem1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 7),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 7),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalCashClearingSystem1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingSystemIdentification3Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingSystemIdentification3Choice.subclass:
            return ClearingSystemIdentification3Choice.subclass(*args_, **kwargs_)
        else:
            return ClearingSystemIdentification3Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalCashClearingSystem1Code(self, value):
        result = True
        # Validate type ExternalCashClearingSystem1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalCashClearingSystem1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalCashClearingSystem1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ClearingSystemIdentification3Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClearingSystemIdentification3Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClearingSystemIdentification3Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClearingSystemIdentification3Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClearingSystemIdentification3Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClearingSystemIdentification3Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ClearingSystemIdentification3Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalCashClearingSystem1Code
            self.validate_ExternalCashClearingSystem1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ClearingSystemIdentification3Choice


class ClearingSystemMemberIdentification2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'ClrSysId': MemberSpec_('ClrSysId', 'ClearingSystemIdentification2Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ClrSysId', 'type': 'ClearingSystemIdentification2Choice'}, None),
        'MmbId': MemberSpec_('MmbId', ['Max35Text', 'xs:string'], 0, 0, {'name': 'MmbId', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ClrSysId=None, MmbId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ClrSysId = ClrSysId
        self.ClrSysId_nsprefix_ = None
        self.MmbId = MmbId
        self.validate_Max35Text(self.MmbId)
        self.MmbId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingSystemMemberIdentification2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingSystemMemberIdentification2.subclass:
            return ClearingSystemMemberIdentification2.subclass(*args_, **kwargs_)
        else:
            return ClearingSystemMemberIdentification2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ClrSysId(self):
        return self.ClrSysId
    def set_ClrSysId(self, ClrSysId):
        self.ClrSysId = ClrSysId
    def get_MmbId(self):
        return self.MmbId
    def set_MmbId(self, MmbId):
        self.MmbId = MmbId
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ClrSysId is not None or
            self.MmbId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ClearingSystemMemberIdentification2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClearingSystemMemberIdentification2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClearingSystemMemberIdentification2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClearingSystemMemberIdentification2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClearingSystemMemberIdentification2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClearingSystemMemberIdentification2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ClearingSystemMemberIdentification2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClrSysId is not None:
            namespaceprefix_ = self.ClrSysId_nsprefix_ + ':' if (UseCapturedNS_ and self.ClrSysId_nsprefix_) else ''
            self.ClrSysId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClrSysId', pretty_print=pretty_print)
        if self.MmbId is not None:
            namespaceprefix_ = self.MmbId_nsprefix_ + ':' if (UseCapturedNS_ and self.MmbId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMmbId>%s</%sMmbId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MmbId), input_name='MmbId')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ClrSysId':
            obj_ = ClearingSystemIdentification2Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClrSysId = obj_
            obj_.original_tagname_ = 'ClrSysId'
        elif nodeName_ == 'MmbId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MmbId')
            value_ = self.gds_validate_string(value_, node, 'MmbId')
            self.MmbId = value_
            self.MmbId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.MmbId)
# end class ClearingSystemMemberIdentification2


class Contact4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'NmPrfx': MemberSpec_('NmPrfx', ['NamePrefix2Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'NmPrfx', 'type': 'xs:string'}, None),
        'Nm': MemberSpec_('Nm', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nm', 'type': 'xs:string'}, None),
        'PhneNb': MemberSpec_('PhneNb', ['PhoneNumber', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PhneNb', 'type': 'xs:string'}, None),
        'MobNb': MemberSpec_('MobNb', ['PhoneNumber', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'MobNb', 'type': 'xs:string'}, None),
        'FaxNb': MemberSpec_('FaxNb', ['PhoneNumber', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'FaxNb', 'type': 'xs:string'}, None),
        'EmailAdr': MemberSpec_('EmailAdr', ['Max2048Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'EmailAdr', 'type': 'xs:string'}, None),
        'EmailPurp': MemberSpec_('EmailPurp', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'EmailPurp', 'type': 'xs:string'}, None),
        'JobTitl': MemberSpec_('JobTitl', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'JobTitl', 'type': 'xs:string'}, None),
        'Rspnsblty': MemberSpec_('Rspnsblty', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Rspnsblty', 'type': 'xs:string'}, None),
        'Dept': MemberSpec_('Dept', ['Max70Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dept', 'type': 'xs:string'}, None),
        'Othr': MemberSpec_('Othr', 'OtherContact1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Othr', 'type': 'OtherContact1'}, None),
        'PrefrdMtd': MemberSpec_('PrefrdMtd', ['PreferredContactMethod1Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrefrdMtd', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, NmPrfx=None, Nm=None, PhneNb=None, MobNb=None, FaxNb=None, EmailAdr=None, EmailPurp=None, JobTitl=None, Rspnsblty=None, Dept=None, Othr=None, PrefrdMtd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NmPrfx = NmPrfx
        self.validate_NamePrefix2Code(self.NmPrfx)
        self.NmPrfx_nsprefix_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Nm_nsprefix_ = None
        self.PhneNb = PhneNb
        self.validate_PhoneNumber(self.PhneNb)
        self.PhneNb_nsprefix_ = None
        self.MobNb = MobNb
        self.validate_PhoneNumber(self.MobNb)
        self.MobNb_nsprefix_ = None
        self.FaxNb = FaxNb
        self.validate_PhoneNumber(self.FaxNb)
        self.FaxNb_nsprefix_ = None
        self.EmailAdr = EmailAdr
        self.validate_Max2048Text(self.EmailAdr)
        self.EmailAdr_nsprefix_ = None
        self.EmailPurp = EmailPurp
        self.validate_Max35Text(self.EmailPurp)
        self.EmailPurp_nsprefix_ = None
        self.JobTitl = JobTitl
        self.validate_Max35Text(self.JobTitl)
        self.JobTitl_nsprefix_ = None
        self.Rspnsblty = Rspnsblty
        self.validate_Max35Text(self.Rspnsblty)
        self.Rspnsblty_nsprefix_ = None
        self.Dept = Dept
        self.validate_Max70Text(self.Dept)
        self.Dept_nsprefix_ = None
        if Othr is None:
            self.Othr = []
        else:
            self.Othr = Othr
        self.Othr_nsprefix_ = None
        self.PrefrdMtd = PrefrdMtd
        self.validate_PreferredContactMethod1Code(self.PrefrdMtd)
        self.PrefrdMtd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Contact4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Contact4.subclass:
            return Contact4.subclass(*args_, **kwargs_)
        else:
            return Contact4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NmPrfx(self):
        return self.NmPrfx
    def set_NmPrfx(self, NmPrfx):
        self.NmPrfx = NmPrfx
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def get_PhneNb(self):
        return self.PhneNb
    def set_PhneNb(self, PhneNb):
        self.PhneNb = PhneNb
    def get_MobNb(self):
        return self.MobNb
    def set_MobNb(self, MobNb):
        self.MobNb = MobNb
    def get_FaxNb(self):
        return self.FaxNb
    def set_FaxNb(self, FaxNb):
        self.FaxNb = FaxNb
    def get_EmailAdr(self):
        return self.EmailAdr
    def set_EmailAdr(self, EmailAdr):
        self.EmailAdr = EmailAdr
    def get_EmailPurp(self):
        return self.EmailPurp
    def set_EmailPurp(self, EmailPurp):
        self.EmailPurp = EmailPurp
    def get_JobTitl(self):
        return self.JobTitl
    def set_JobTitl(self, JobTitl):
        self.JobTitl = JobTitl
    def get_Rspnsblty(self):
        return self.Rspnsblty
    def set_Rspnsblty(self, Rspnsblty):
        self.Rspnsblty = Rspnsblty
    def get_Dept(self):
        return self.Dept
    def set_Dept(self, Dept):
        self.Dept = Dept
    def get_Othr(self):
        return self.Othr
    def set_Othr(self, Othr):
        self.Othr = Othr
    def add_Othr(self, value):
        self.Othr.append(value)
    def insert_Othr_at(self, index, value):
        self.Othr.insert(index, value)
    def replace_Othr_at(self, index, value):
        self.Othr[index] = value
    def get_PrefrdMtd(self):
        return self.PrefrdMtd
    def set_PrefrdMtd(self, PrefrdMtd):
        self.PrefrdMtd = PrefrdMtd
    def validate_NamePrefix2Code(self, value):
        result = True
        # Validate type NamePrefix2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DOCT', 'MADM', 'MISS', 'MIST', 'MIKS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NamePrefix2Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_PhoneNumber(self, value):
        result = True
        # Validate type PhoneNumber, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_PhoneNumber_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PhoneNumber_patterns_, ))
                result = False
        return result
    validate_PhoneNumber_patterns_ = [['^(\\+[0-9]{1,3}-[0-9()+\\-]{1,30})$']]
    def validate_Max2048Text(self, value):
        result = True
        # Validate type Max2048Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2048:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max70Text(self, value):
        result = True
        # Validate type Max70Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max70Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max70Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_PreferredContactMethod1Code(self, value):
        result = True
        # Validate type PreferredContactMethod1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LETT', 'MAIL', 'PHON', 'FAXX', 'CELL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PreferredContactMethod1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.NmPrfx is not None or
            self.Nm is not None or
            self.PhneNb is not None or
            self.MobNb is not None or
            self.FaxNb is not None or
            self.EmailAdr is not None or
            self.EmailPurp is not None or
            self.JobTitl is not None or
            self.Rspnsblty is not None or
            self.Dept is not None or
            self.Othr or
            self.PrefrdMtd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Contact4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Contact4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Contact4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Contact4')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Contact4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Contact4'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Contact4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NmPrfx is not None:
            namespaceprefix_ = self.NmPrfx_nsprefix_ + ':' if (UseCapturedNS_ and self.NmPrfx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNmPrfx>%s</%sNmPrfx>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NmPrfx), input_name='NmPrfx')), namespaceprefix_ , eol_))
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
        if self.PhneNb is not None:
            namespaceprefix_ = self.PhneNb_nsprefix_ + ':' if (UseCapturedNS_ and self.PhneNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhneNb>%s</%sPhneNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PhneNb), input_name='PhneNb')), namespaceprefix_ , eol_))
        if self.MobNb is not None:
            namespaceprefix_ = self.MobNb_nsprefix_ + ':' if (UseCapturedNS_ and self.MobNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMobNb>%s</%sMobNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MobNb), input_name='MobNb')), namespaceprefix_ , eol_))
        if self.FaxNb is not None:
            namespaceprefix_ = self.FaxNb_nsprefix_ + ':' if (UseCapturedNS_ and self.FaxNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFaxNb>%s</%sFaxNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FaxNb), input_name='FaxNb')), namespaceprefix_ , eol_))
        if self.EmailAdr is not None:
            namespaceprefix_ = self.EmailAdr_nsprefix_ + ':' if (UseCapturedNS_ and self.EmailAdr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmailAdr>%s</%sEmailAdr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EmailAdr), input_name='EmailAdr')), namespaceprefix_ , eol_))
        if self.EmailPurp is not None:
            namespaceprefix_ = self.EmailPurp_nsprefix_ + ':' if (UseCapturedNS_ and self.EmailPurp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmailPurp>%s</%sEmailPurp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EmailPurp), input_name='EmailPurp')), namespaceprefix_ , eol_))
        if self.JobTitl is not None:
            namespaceprefix_ = self.JobTitl_nsprefix_ + ':' if (UseCapturedNS_ and self.JobTitl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJobTitl>%s</%sJobTitl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.JobTitl), input_name='JobTitl')), namespaceprefix_ , eol_))
        if self.Rspnsblty is not None:
            namespaceprefix_ = self.Rspnsblty_nsprefix_ + ':' if (UseCapturedNS_ and self.Rspnsblty_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRspnsblty>%s</%sRspnsblty>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Rspnsblty), input_name='Rspnsblty')), namespaceprefix_ , eol_))
        if self.Dept is not None:
            namespaceprefix_ = self.Dept_nsprefix_ + ':' if (UseCapturedNS_ and self.Dept_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDept>%s</%sDept>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Dept), input_name='Dept')), namespaceprefix_ , eol_))
        for Othr_ in self.Othr:
            namespaceprefix_ = self.Othr_nsprefix_ + ':' if (UseCapturedNS_ and self.Othr_nsprefix_) else ''
            Othr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Othr', pretty_print=pretty_print)
        if self.PrefrdMtd is not None:
            namespaceprefix_ = self.PrefrdMtd_nsprefix_ + ':' if (UseCapturedNS_ and self.PrefrdMtd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrefrdMtd>%s</%sPrefrdMtd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PrefrdMtd), input_name='PrefrdMtd')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NmPrfx':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NmPrfx')
            value_ = self.gds_validate_string(value_, node, 'NmPrfx')
            self.NmPrfx = value_
            self.NmPrfx_nsprefix_ = child_.prefix
            # validate type NamePrefix2Code
            self.validate_NamePrefix2Code(self.NmPrfx)
        elif nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PhneNb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PhneNb')
            value_ = self.gds_validate_string(value_, node, 'PhneNb')
            self.PhneNb = value_
            self.PhneNb_nsprefix_ = child_.prefix
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.PhneNb)
        elif nodeName_ == 'MobNb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MobNb')
            value_ = self.gds_validate_string(value_, node, 'MobNb')
            self.MobNb = value_
            self.MobNb_nsprefix_ = child_.prefix
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.MobNb)
        elif nodeName_ == 'FaxNb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FaxNb')
            value_ = self.gds_validate_string(value_, node, 'FaxNb')
            self.FaxNb = value_
            self.FaxNb_nsprefix_ = child_.prefix
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.FaxNb)
        elif nodeName_ == 'EmailAdr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EmailAdr')
            value_ = self.gds_validate_string(value_, node, 'EmailAdr')
            self.EmailAdr = value_
            self.EmailAdr_nsprefix_ = child_.prefix
            # validate type Max2048Text
            self.validate_Max2048Text(self.EmailAdr)
        elif nodeName_ == 'EmailPurp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EmailPurp')
            value_ = self.gds_validate_string(value_, node, 'EmailPurp')
            self.EmailPurp = value_
            self.EmailPurp_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.EmailPurp)
        elif nodeName_ == 'JobTitl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'JobTitl')
            value_ = self.gds_validate_string(value_, node, 'JobTitl')
            self.JobTitl = value_
            self.JobTitl_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.JobTitl)
        elif nodeName_ == 'Rspnsblty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Rspnsblty')
            value_ = self.gds_validate_string(value_, node, 'Rspnsblty')
            self.Rspnsblty = value_
            self.Rspnsblty_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Rspnsblty)
        elif nodeName_ == 'Dept':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Dept')
            value_ = self.gds_validate_string(value_, node, 'Dept')
            self.Dept = value_
            self.Dept_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.Dept)
        elif nodeName_ == 'Othr':
            obj_ = OtherContact1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Othr.append(obj_)
            obj_.original_tagname_ = 'Othr'
        elif nodeName_ == 'PrefrdMtd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PrefrdMtd')
            value_ = self.gds_validate_string(value_, node, 'PrefrdMtd')
            self.PrefrdMtd = value_
            self.PrefrdMtd_nsprefix_ = child_.prefix
            # validate type PreferredContactMethod1Code
            self.validate_PreferredContactMethod1Code(self.PrefrdMtd)
# end class Contact4


class CreditTransferTransaction39(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'PmtId': MemberSpec_('PmtId', 'PaymentIdentification7', 0, 0, {'name': 'PmtId', 'type': 'PaymentIdentification7'}, None),
        'PmtTpInf': MemberSpec_('PmtTpInf', 'PaymentTypeInformation28', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PmtTpInf', 'type': 'PaymentTypeInformation28'}, None),
        'IntrBkSttlmAmt': MemberSpec_('IntrBkSttlmAmt', 'ActiveCurrencyAndAmount', 0, 0, {'name': 'IntrBkSttlmAmt', 'type': 'ActiveCurrencyAndAmount'}, None),
        'IntrBkSttlmDt': MemberSpec_('IntrBkSttlmDt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrBkSttlmDt', 'type': 'xs:date'}, None),
        'SttlmPrty': MemberSpec_('SttlmPrty', ['Priority3Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SttlmPrty', 'type': 'xs:string'}, None),
        'SttlmTmIndctn': MemberSpec_('SttlmTmIndctn', 'SettlementDateTimeIndication1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SttlmTmIndctn', 'type': 'SettlementDateTimeIndication1'}, None),
        'SttlmTmReq': MemberSpec_('SttlmTmReq', 'SettlementTimeRequest2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SttlmTmReq', 'type': 'SettlementTimeRequest2'}, None),
        'AccptncDtTm': MemberSpec_('AccptncDtTm', ['ISODateTime', 'xs:dateTime'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'AccptncDtTm', 'type': 'xs:dateTime'}, None),
        'PoolgAdjstmntDt': MemberSpec_('PoolgAdjstmntDt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PoolgAdjstmntDt', 'type': 'xs:date'}, None),
        'InstdAmt': MemberSpec_('InstdAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstdAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'XchgRate': MemberSpec_('XchgRate', ['BaseOneRate', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'XchgRate', 'type': 'xs:decimal'}, None),
        'ChrgBr': MemberSpec_('ChrgBr', ['ChargeBearerType1Code', 'xs:string'], 0, 0, {'name': 'ChrgBr', 'type': 'xs:string'}, None),
        'ChrgsInf': MemberSpec_('ChrgsInf', 'Charges7', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ChrgsInf', 'type': 'Charges7'}, None),
        'PrvsInstgAgt1': MemberSpec_('PrvsInstgAgt1', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrvsInstgAgt1', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'PrvsInstgAgt1Acct': MemberSpec_('PrvsInstgAgt1Acct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrvsInstgAgt1Acct', 'type': 'CashAccount38'}, None),
        'PrvsInstgAgt2': MemberSpec_('PrvsInstgAgt2', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrvsInstgAgt2', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'PrvsInstgAgt2Acct': MemberSpec_('PrvsInstgAgt2Acct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrvsInstgAgt2Acct', 'type': 'CashAccount38'}, None),
        'PrvsInstgAgt3': MemberSpec_('PrvsInstgAgt3', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrvsInstgAgt3', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'PrvsInstgAgt3Acct': MemberSpec_('PrvsInstgAgt3Acct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrvsInstgAgt3Acct', 'type': 'CashAccount38'}, None),
        'InstgAgt': MemberSpec_('InstgAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstgAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'InstdAgt': MemberSpec_('InstdAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstdAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'IntrmyAgt1': MemberSpec_('IntrmyAgt1', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrmyAgt1', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'IntrmyAgt1Acct': MemberSpec_('IntrmyAgt1Acct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrmyAgt1Acct', 'type': 'CashAccount38'}, None),
        'IntrmyAgt2': MemberSpec_('IntrmyAgt2', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrmyAgt2', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'IntrmyAgt2Acct': MemberSpec_('IntrmyAgt2Acct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrmyAgt2Acct', 'type': 'CashAccount38'}, None),
        'IntrmyAgt3': MemberSpec_('IntrmyAgt3', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrmyAgt3', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'IntrmyAgt3Acct': MemberSpec_('IntrmyAgt3Acct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrmyAgt3Acct', 'type': 'CashAccount38'}, None),
        'UltmtDbtr': MemberSpec_('UltmtDbtr', 'PartyIdentification135', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'UltmtDbtr', 'type': 'PartyIdentification135'}, None),
        'InitgPty': MemberSpec_('InitgPty', 'PartyIdentification135', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InitgPty', 'type': 'PartyIdentification135'}, None),
        'Dbtr': MemberSpec_('Dbtr', 'PartyIdentification135', 0, 0, {'name': 'Dbtr', 'type': 'PartyIdentification135'}, None),
        'DbtrAcct': MemberSpec_('DbtrAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DbtrAcct', 'type': 'CashAccount38'}, None),
        'DbtrAgt': MemberSpec_('DbtrAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 0, {'name': 'DbtrAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'DbtrAgtAcct': MemberSpec_('DbtrAgtAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DbtrAgtAcct', 'type': 'CashAccount38'}, None),
        'CdtrAgt': MemberSpec_('CdtrAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 0, {'name': 'CdtrAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'CdtrAgtAcct': MemberSpec_('CdtrAgtAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CdtrAgtAcct', 'type': 'CashAccount38'}, None),
        'Cdtr': MemberSpec_('Cdtr', 'PartyIdentification135', 0, 0, {'name': 'Cdtr', 'type': 'PartyIdentification135'}, None),
        'CdtrAcct': MemberSpec_('CdtrAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CdtrAcct', 'type': 'CashAccount38'}, None),
        'UltmtCdtr': MemberSpec_('UltmtCdtr', 'PartyIdentification135', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'UltmtCdtr', 'type': 'PartyIdentification135'}, None),
        'InstrForCdtrAgt': MemberSpec_('InstrForCdtrAgt', 'InstructionForCreditorAgent1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'InstrForCdtrAgt', 'type': 'InstructionForCreditorAgent1'}, None),
        'InstrForNxtAgt': MemberSpec_('InstrForNxtAgt', 'InstructionForNextAgent1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'InstrForNxtAgt', 'type': 'InstructionForNextAgent1'}, None),
        'Purp': MemberSpec_('Purp', 'Purpose2Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Purp', 'type': 'Purpose2Choice'}, None),
        'RgltryRptg': MemberSpec_('RgltryRptg', 'RegulatoryReporting3', 1, 1, {'maxOccurs': '10', 'minOccurs': '0', 'name': 'RgltryRptg', 'type': 'RegulatoryReporting3'}, None),
        'Tax': MemberSpec_('Tax', 'TaxInformation8', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tax', 'type': 'TaxInformation8'}, None),
        'RltdRmtInf': MemberSpec_('RltdRmtInf', 'RemittanceLocation7', 1, 1, {'maxOccurs': '10', 'minOccurs': '0', 'name': 'RltdRmtInf', 'type': 'RemittanceLocation7'}, None),
        'RmtInf': MemberSpec_('RmtInf', 'RemittanceInformation16', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RmtInf', 'type': 'RemittanceInformation16'}, None),
        'SplmtryData': MemberSpec_('SplmtryData', 'SupplementaryData1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'SplmtryData', 'type': 'SupplementaryData1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, PmtId=None, PmtTpInf=None, IntrBkSttlmAmt=None, IntrBkSttlmDt=None, SttlmPrty=None, SttlmTmIndctn=None, SttlmTmReq=None, AccptncDtTm=None, PoolgAdjstmntDt=None, InstdAmt=None, XchgRate=None, ChrgBr=None, ChrgsInf=None, PrvsInstgAgt1=None, PrvsInstgAgt1Acct=None, PrvsInstgAgt2=None, PrvsInstgAgt2Acct=None, PrvsInstgAgt3=None, PrvsInstgAgt3Acct=None, InstgAgt=None, InstdAgt=None, IntrmyAgt1=None, IntrmyAgt1Acct=None, IntrmyAgt2=None, IntrmyAgt2Acct=None, IntrmyAgt3=None, IntrmyAgt3Acct=None, UltmtDbtr=None, InitgPty=None, Dbtr=None, DbtrAcct=None, DbtrAgt=None, DbtrAgtAcct=None, CdtrAgt=None, CdtrAgtAcct=None, Cdtr=None, CdtrAcct=None, UltmtCdtr=None, InstrForCdtrAgt=None, InstrForNxtAgt=None, Purp=None, RgltryRptg=None, Tax=None, RltdRmtInf=None, RmtInf=None, SplmtryData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PmtId = PmtId
        self.PmtId_nsprefix_ = None
        self.PmtTpInf = PmtTpInf
        self.PmtTpInf_nsprefix_ = None
        self.IntrBkSttlmAmt = IntrBkSttlmAmt
        self.IntrBkSttlmAmt_nsprefix_ = None
        if isinstance(IntrBkSttlmDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(IntrBkSttlmDt, '%Y-%m-%d').date()
        else:
            initvalue_ = IntrBkSttlmDt
        self.IntrBkSttlmDt = initvalue_
        self.IntrBkSttlmDt_nsprefix_ = None
        self.SttlmPrty = SttlmPrty
        self.validate_Priority3Code(self.SttlmPrty)
        self.SttlmPrty_nsprefix_ = None
        self.SttlmTmIndctn = SttlmTmIndctn
        self.SttlmTmIndctn_nsprefix_ = None
        self.SttlmTmReq = SttlmTmReq
        self.SttlmTmReq_nsprefix_ = None
        if isinstance(AccptncDtTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AccptncDtTm, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = AccptncDtTm
        self.AccptncDtTm = initvalue_
        self.AccptncDtTm_nsprefix_ = None
        if isinstance(PoolgAdjstmntDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PoolgAdjstmntDt, '%Y-%m-%d').date()
        else:
            initvalue_ = PoolgAdjstmntDt
        self.PoolgAdjstmntDt = initvalue_
        self.PoolgAdjstmntDt_nsprefix_ = None
        self.InstdAmt = InstdAmt
        self.InstdAmt_nsprefix_ = None
        self.XchgRate = XchgRate
        self.validate_BaseOneRate(self.XchgRate)
        self.XchgRate_nsprefix_ = None
        self.ChrgBr = ChrgBr
        self.validate_ChargeBearerType1Code(self.ChrgBr)
        self.ChrgBr_nsprefix_ = None
        if ChrgsInf is None:
            self.ChrgsInf = []
        else:
            self.ChrgsInf = ChrgsInf
        self.ChrgsInf_nsprefix_ = None
        self.PrvsInstgAgt1 = PrvsInstgAgt1
        self.PrvsInstgAgt1_nsprefix_ = None
        self.PrvsInstgAgt1Acct = PrvsInstgAgt1Acct
        self.PrvsInstgAgt1Acct_nsprefix_ = None
        self.PrvsInstgAgt2 = PrvsInstgAgt2
        self.PrvsInstgAgt2_nsprefix_ = None
        self.PrvsInstgAgt2Acct = PrvsInstgAgt2Acct
        self.PrvsInstgAgt2Acct_nsprefix_ = None
        self.PrvsInstgAgt3 = PrvsInstgAgt3
        self.PrvsInstgAgt3_nsprefix_ = None
        self.PrvsInstgAgt3Acct = PrvsInstgAgt3Acct
        self.PrvsInstgAgt3Acct_nsprefix_ = None
        self.InstgAgt = InstgAgt
        self.InstgAgt_nsprefix_ = None
        self.InstdAgt = InstdAgt
        self.InstdAgt_nsprefix_ = None
        self.IntrmyAgt1 = IntrmyAgt1
        self.IntrmyAgt1_nsprefix_ = None
        self.IntrmyAgt1Acct = IntrmyAgt1Acct
        self.IntrmyAgt1Acct_nsprefix_ = None
        self.IntrmyAgt2 = IntrmyAgt2
        self.IntrmyAgt2_nsprefix_ = None
        self.IntrmyAgt2Acct = IntrmyAgt2Acct
        self.IntrmyAgt2Acct_nsprefix_ = None
        self.IntrmyAgt3 = IntrmyAgt3
        self.IntrmyAgt3_nsprefix_ = None
        self.IntrmyAgt3Acct = IntrmyAgt3Acct
        self.IntrmyAgt3Acct_nsprefix_ = None
        self.UltmtDbtr = UltmtDbtr
        self.UltmtDbtr_nsprefix_ = None
        self.InitgPty = InitgPty
        self.InitgPty_nsprefix_ = None
        self.Dbtr = Dbtr
        self.Dbtr_nsprefix_ = None
        self.DbtrAcct = DbtrAcct
        self.DbtrAcct_nsprefix_ = None
        self.DbtrAgt = DbtrAgt
        self.DbtrAgt_nsprefix_ = None
        self.DbtrAgtAcct = DbtrAgtAcct
        self.DbtrAgtAcct_nsprefix_ = None
        self.CdtrAgt = CdtrAgt
        self.CdtrAgt_nsprefix_ = None
        self.CdtrAgtAcct = CdtrAgtAcct
        self.CdtrAgtAcct_nsprefix_ = None
        self.Cdtr = Cdtr
        self.Cdtr_nsprefix_ = None
        self.CdtrAcct = CdtrAcct
        self.CdtrAcct_nsprefix_ = None
        self.UltmtCdtr = UltmtCdtr
        self.UltmtCdtr_nsprefix_ = None
        if InstrForCdtrAgt is None:
            self.InstrForCdtrAgt = []
        else:
            self.InstrForCdtrAgt = InstrForCdtrAgt
        self.InstrForCdtrAgt_nsprefix_ = None
        if InstrForNxtAgt is None:
            self.InstrForNxtAgt = []
        else:
            self.InstrForNxtAgt = InstrForNxtAgt
        self.InstrForNxtAgt_nsprefix_ = None
        self.Purp = Purp
        self.Purp_nsprefix_ = None
        if RgltryRptg is None:
            self.RgltryRptg = []
        else:
            self.RgltryRptg = RgltryRptg
        self.RgltryRptg_nsprefix_ = None
        self.Tax = Tax
        self.Tax_nsprefix_ = None
        if RltdRmtInf is None:
            self.RltdRmtInf = []
        else:
            self.RltdRmtInf = RltdRmtInf
        self.RltdRmtInf_nsprefix_ = None
        self.RmtInf = RmtInf
        self.RmtInf_nsprefix_ = None
        if SplmtryData is None:
            self.SplmtryData = []
        else:
            self.SplmtryData = SplmtryData
        self.SplmtryData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditTransferTransaction39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditTransferTransaction39.subclass:
            return CreditTransferTransaction39.subclass(*args_, **kwargs_)
        else:
            return CreditTransferTransaction39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PmtId(self):
        return self.PmtId
    def set_PmtId(self, PmtId):
        self.PmtId = PmtId
    def get_PmtTpInf(self):
        return self.PmtTpInf
    def set_PmtTpInf(self, PmtTpInf):
        self.PmtTpInf = PmtTpInf
    def get_IntrBkSttlmAmt(self):
        return self.IntrBkSttlmAmt
    def set_IntrBkSttlmAmt(self, IntrBkSttlmAmt):
        self.IntrBkSttlmAmt = IntrBkSttlmAmt
    def get_IntrBkSttlmDt(self):
        return self.IntrBkSttlmDt
    def set_IntrBkSttlmDt(self, IntrBkSttlmDt):
        self.IntrBkSttlmDt = IntrBkSttlmDt
    def get_SttlmPrty(self):
        return self.SttlmPrty
    def set_SttlmPrty(self, SttlmPrty):
        self.SttlmPrty = SttlmPrty
    def get_SttlmTmIndctn(self):
        return self.SttlmTmIndctn
    def set_SttlmTmIndctn(self, SttlmTmIndctn):
        self.SttlmTmIndctn = SttlmTmIndctn
    def get_SttlmTmReq(self):
        return self.SttlmTmReq
    def set_SttlmTmReq(self, SttlmTmReq):
        self.SttlmTmReq = SttlmTmReq
    def get_AccptncDtTm(self):
        return self.AccptncDtTm
    def set_AccptncDtTm(self, AccptncDtTm):
        self.AccptncDtTm = AccptncDtTm
    def get_PoolgAdjstmntDt(self):
        return self.PoolgAdjstmntDt
    def set_PoolgAdjstmntDt(self, PoolgAdjstmntDt):
        self.PoolgAdjstmntDt = PoolgAdjstmntDt
    def get_InstdAmt(self):
        return self.InstdAmt
    def set_InstdAmt(self, InstdAmt):
        self.InstdAmt = InstdAmt
    def get_XchgRate(self):
        return self.XchgRate
    def set_XchgRate(self, XchgRate):
        self.XchgRate = XchgRate
    def get_ChrgBr(self):
        return self.ChrgBr
    def set_ChrgBr(self, ChrgBr):
        self.ChrgBr = ChrgBr
    def get_ChrgsInf(self):
        return self.ChrgsInf
    def set_ChrgsInf(self, ChrgsInf):
        self.ChrgsInf = ChrgsInf
    def add_ChrgsInf(self, value):
        self.ChrgsInf.append(value)
    def insert_ChrgsInf_at(self, index, value):
        self.ChrgsInf.insert(index, value)
    def replace_ChrgsInf_at(self, index, value):
        self.ChrgsInf[index] = value
    def get_PrvsInstgAgt1(self):
        return self.PrvsInstgAgt1
    def set_PrvsInstgAgt1(self, PrvsInstgAgt1):
        self.PrvsInstgAgt1 = PrvsInstgAgt1
    def get_PrvsInstgAgt1Acct(self):
        return self.PrvsInstgAgt1Acct
    def set_PrvsInstgAgt1Acct(self, PrvsInstgAgt1Acct):
        self.PrvsInstgAgt1Acct = PrvsInstgAgt1Acct
    def get_PrvsInstgAgt2(self):
        return self.PrvsInstgAgt2
    def set_PrvsInstgAgt2(self, PrvsInstgAgt2):
        self.PrvsInstgAgt2 = PrvsInstgAgt2
    def get_PrvsInstgAgt2Acct(self):
        return self.PrvsInstgAgt2Acct
    def set_PrvsInstgAgt2Acct(self, PrvsInstgAgt2Acct):
        self.PrvsInstgAgt2Acct = PrvsInstgAgt2Acct
    def get_PrvsInstgAgt3(self):
        return self.PrvsInstgAgt3
    def set_PrvsInstgAgt3(self, PrvsInstgAgt3):
        self.PrvsInstgAgt3 = PrvsInstgAgt3
    def get_PrvsInstgAgt3Acct(self):
        return self.PrvsInstgAgt3Acct
    def set_PrvsInstgAgt3Acct(self, PrvsInstgAgt3Acct):
        self.PrvsInstgAgt3Acct = PrvsInstgAgt3Acct
    def get_InstgAgt(self):
        return self.InstgAgt
    def set_InstgAgt(self, InstgAgt):
        self.InstgAgt = InstgAgt
    def get_InstdAgt(self):
        return self.InstdAgt
    def set_InstdAgt(self, InstdAgt):
        self.InstdAgt = InstdAgt
    def get_IntrmyAgt1(self):
        return self.IntrmyAgt1
    def set_IntrmyAgt1(self, IntrmyAgt1):
        self.IntrmyAgt1 = IntrmyAgt1
    def get_IntrmyAgt1Acct(self):
        return self.IntrmyAgt1Acct
    def set_IntrmyAgt1Acct(self, IntrmyAgt1Acct):
        self.IntrmyAgt1Acct = IntrmyAgt1Acct
    def get_IntrmyAgt2(self):
        return self.IntrmyAgt2
    def set_IntrmyAgt2(self, IntrmyAgt2):
        self.IntrmyAgt2 = IntrmyAgt2
    def get_IntrmyAgt2Acct(self):
        return self.IntrmyAgt2Acct
    def set_IntrmyAgt2Acct(self, IntrmyAgt2Acct):
        self.IntrmyAgt2Acct = IntrmyAgt2Acct
    def get_IntrmyAgt3(self):
        return self.IntrmyAgt3
    def set_IntrmyAgt3(self, IntrmyAgt3):
        self.IntrmyAgt3 = IntrmyAgt3
    def get_IntrmyAgt3Acct(self):
        return self.IntrmyAgt3Acct
    def set_IntrmyAgt3Acct(self, IntrmyAgt3Acct):
        self.IntrmyAgt3Acct = IntrmyAgt3Acct
    def get_UltmtDbtr(self):
        return self.UltmtDbtr
    def set_UltmtDbtr(self, UltmtDbtr):
        self.UltmtDbtr = UltmtDbtr
    def get_InitgPty(self):
        return self.InitgPty
    def set_InitgPty(self, InitgPty):
        self.InitgPty = InitgPty
    def get_Dbtr(self):
        return self.Dbtr
    def set_Dbtr(self, Dbtr):
        self.Dbtr = Dbtr
    def get_DbtrAcct(self):
        return self.DbtrAcct
    def set_DbtrAcct(self, DbtrAcct):
        self.DbtrAcct = DbtrAcct
    def get_DbtrAgt(self):
        return self.DbtrAgt
    def set_DbtrAgt(self, DbtrAgt):
        self.DbtrAgt = DbtrAgt
    def get_DbtrAgtAcct(self):
        return self.DbtrAgtAcct
    def set_DbtrAgtAcct(self, DbtrAgtAcct):
        self.DbtrAgtAcct = DbtrAgtAcct
    def get_CdtrAgt(self):
        return self.CdtrAgt
    def set_CdtrAgt(self, CdtrAgt):
        self.CdtrAgt = CdtrAgt
    def get_CdtrAgtAcct(self):
        return self.CdtrAgtAcct
    def set_CdtrAgtAcct(self, CdtrAgtAcct):
        self.CdtrAgtAcct = CdtrAgtAcct
    def get_Cdtr(self):
        return self.Cdtr
    def set_Cdtr(self, Cdtr):
        self.Cdtr = Cdtr
    def get_CdtrAcct(self):
        return self.CdtrAcct
    def set_CdtrAcct(self, CdtrAcct):
        self.CdtrAcct = CdtrAcct
    def get_UltmtCdtr(self):
        return self.UltmtCdtr
    def set_UltmtCdtr(self, UltmtCdtr):
        self.UltmtCdtr = UltmtCdtr
    def get_InstrForCdtrAgt(self):
        return self.InstrForCdtrAgt
    def set_InstrForCdtrAgt(self, InstrForCdtrAgt):
        self.InstrForCdtrAgt = InstrForCdtrAgt
    def add_InstrForCdtrAgt(self, value):
        self.InstrForCdtrAgt.append(value)
    def insert_InstrForCdtrAgt_at(self, index, value):
        self.InstrForCdtrAgt.insert(index, value)
    def replace_InstrForCdtrAgt_at(self, index, value):
        self.InstrForCdtrAgt[index] = value
    def get_InstrForNxtAgt(self):
        return self.InstrForNxtAgt
    def set_InstrForNxtAgt(self, InstrForNxtAgt):
        self.InstrForNxtAgt = InstrForNxtAgt
    def add_InstrForNxtAgt(self, value):
        self.InstrForNxtAgt.append(value)
    def insert_InstrForNxtAgt_at(self, index, value):
        self.InstrForNxtAgt.insert(index, value)
    def replace_InstrForNxtAgt_at(self, index, value):
        self.InstrForNxtAgt[index] = value
    def get_Purp(self):
        return self.Purp
    def set_Purp(self, Purp):
        self.Purp = Purp
    def get_RgltryRptg(self):
        return self.RgltryRptg
    def set_RgltryRptg(self, RgltryRptg):
        self.RgltryRptg = RgltryRptg
    def add_RgltryRptg(self, value):
        self.RgltryRptg.append(value)
    def insert_RgltryRptg_at(self, index, value):
        self.RgltryRptg.insert(index, value)
    def replace_RgltryRptg_at(self, index, value):
        self.RgltryRptg[index] = value
    def get_Tax(self):
        return self.Tax
    def set_Tax(self, Tax):
        self.Tax = Tax
    def get_RltdRmtInf(self):
        return self.RltdRmtInf
    def set_RltdRmtInf(self, RltdRmtInf):
        self.RltdRmtInf = RltdRmtInf
    def add_RltdRmtInf(self, value):
        self.RltdRmtInf.append(value)
    def insert_RltdRmtInf_at(self, index, value):
        self.RltdRmtInf.insert(index, value)
    def replace_RltdRmtInf_at(self, index, value):
        self.RltdRmtInf[index] = value
    def get_RmtInf(self):
        return self.RmtInf
    def set_RmtInf(self, RmtInf):
        self.RmtInf = RmtInf
    def get_SplmtryData(self):
        return self.SplmtryData
    def set_SplmtryData(self, SplmtryData):
        self.SplmtryData = SplmtryData
    def add_SplmtryData(self, value):
        self.SplmtryData.append(value)
    def insert_SplmtryData_at(self, index, value):
        self.SplmtryData.insert(index, value)
    def replace_SplmtryData_at(self, index, value):
        self.SplmtryData[index] = value
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Priority3Code(self, value):
        result = True
        # Validate type Priority3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['URGT', 'HIGH', 'NORM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Priority3Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODateTime(self, value):
        result = True
        # Validate type ISODateTime, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_BaseOneRate(self, value):
        result = True
        # Validate type BaseOneRate, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on BaseOneRate' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ChargeBearerType1Code(self, value):
        result = True
        # Validate type ChargeBearerType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEBT', 'CRED', 'SHAR', 'SLEV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ChargeBearerType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.PmtId is not None or
            self.PmtTpInf is not None or
            self.IntrBkSttlmAmt is not None or
            self.IntrBkSttlmDt is not None or
            self.SttlmPrty is not None or
            self.SttlmTmIndctn is not None or
            self.SttlmTmReq is not None or
            self.AccptncDtTm is not None or
            self.PoolgAdjstmntDt is not None or
            self.InstdAmt is not None or
            self.XchgRate is not None or
            self.ChrgBr is not None or
            self.ChrgsInf or
            self.PrvsInstgAgt1 is not None or
            self.PrvsInstgAgt1Acct is not None or
            self.PrvsInstgAgt2 is not None or
            self.PrvsInstgAgt2Acct is not None or
            self.PrvsInstgAgt3 is not None or
            self.PrvsInstgAgt3Acct is not None or
            self.InstgAgt is not None or
            self.InstdAgt is not None or
            self.IntrmyAgt1 is not None or
            self.IntrmyAgt1Acct is not None or
            self.IntrmyAgt2 is not None or
            self.IntrmyAgt2Acct is not None or
            self.IntrmyAgt3 is not None or
            self.IntrmyAgt3Acct is not None or
            self.UltmtDbtr is not None or
            self.InitgPty is not None or
            self.Dbtr is not None or
            self.DbtrAcct is not None or
            self.DbtrAgt is not None or
            self.DbtrAgtAcct is not None or
            self.CdtrAgt is not None or
            self.CdtrAgtAcct is not None or
            self.Cdtr is not None or
            self.CdtrAcct is not None or
            self.UltmtCdtr is not None or
            self.InstrForCdtrAgt or
            self.InstrForNxtAgt or
            self.Purp is not None or
            self.RgltryRptg or
            self.Tax is not None or
            self.RltdRmtInf or
            self.RmtInf is not None or
            self.SplmtryData
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditTransferTransaction39', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditTransferTransaction39')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditTransferTransaction39':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditTransferTransaction39')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditTransferTransaction39', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditTransferTransaction39'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditTransferTransaction39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PmtId is not None:
            namespaceprefix_ = self.PmtId_nsprefix_ + ':' if (UseCapturedNS_ and self.PmtId_nsprefix_) else ''
            self.PmtId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PmtId', pretty_print=pretty_print)
        if self.PmtTpInf is not None:
            namespaceprefix_ = self.PmtTpInf_nsprefix_ + ':' if (UseCapturedNS_ and self.PmtTpInf_nsprefix_) else ''
            self.PmtTpInf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PmtTpInf', pretty_print=pretty_print)
        if self.IntrBkSttlmAmt is not None:
            namespaceprefix_ = self.IntrBkSttlmAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrBkSttlmAmt_nsprefix_) else ''
            self.IntrBkSttlmAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntrBkSttlmAmt', pretty_print=pretty_print)
        if self.IntrBkSttlmDt is not None:
            namespaceprefix_ = self.IntrBkSttlmDt_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrBkSttlmDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIntrBkSttlmDt>%s</%sIntrBkSttlmDt>%s' % (namespaceprefix_ , self.gds_format_date(self.IntrBkSttlmDt, input_name='IntrBkSttlmDt'), namespaceprefix_ , eol_))
        if self.SttlmPrty is not None:
            namespaceprefix_ = self.SttlmPrty_nsprefix_ + ':' if (UseCapturedNS_ and self.SttlmPrty_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSttlmPrty>%s</%sSttlmPrty>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SttlmPrty), input_name='SttlmPrty')), namespaceprefix_ , eol_))
        if self.SttlmTmIndctn is not None:
            namespaceprefix_ = self.SttlmTmIndctn_nsprefix_ + ':' if (UseCapturedNS_ and self.SttlmTmIndctn_nsprefix_) else ''
            self.SttlmTmIndctn.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SttlmTmIndctn', pretty_print=pretty_print)
        if self.SttlmTmReq is not None:
            namespaceprefix_ = self.SttlmTmReq_nsprefix_ + ':' if (UseCapturedNS_ and self.SttlmTmReq_nsprefix_) else ''
            self.SttlmTmReq.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SttlmTmReq', pretty_print=pretty_print)
        if self.AccptncDtTm is not None:
            namespaceprefix_ = self.AccptncDtTm_nsprefix_ + ':' if (UseCapturedNS_ and self.AccptncDtTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccptncDtTm>%s</%sAccptncDtTm>%s' % (namespaceprefix_ , self.gds_format_datetime(self.AccptncDtTm, input_name='AccptncDtTm'), namespaceprefix_ , eol_))
        if self.PoolgAdjstmntDt is not None:
            namespaceprefix_ = self.PoolgAdjstmntDt_nsprefix_ + ':' if (UseCapturedNS_ and self.PoolgAdjstmntDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPoolgAdjstmntDt>%s</%sPoolgAdjstmntDt>%s' % (namespaceprefix_ , self.gds_format_date(self.PoolgAdjstmntDt, input_name='PoolgAdjstmntDt'), namespaceprefix_ , eol_))
        if self.InstdAmt is not None:
            namespaceprefix_ = self.InstdAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstdAmt_nsprefix_) else ''
            self.InstdAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstdAmt', pretty_print=pretty_print)
        if self.XchgRate is not None:
            namespaceprefix_ = self.XchgRate_nsprefix_ + ':' if (UseCapturedNS_ and self.XchgRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXchgRate>%s</%sXchgRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.XchgRate, input_name='XchgRate'), namespaceprefix_ , eol_))
        if self.ChrgBr is not None:
            namespaceprefix_ = self.ChrgBr_nsprefix_ + ':' if (UseCapturedNS_ and self.ChrgBr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChrgBr>%s</%sChrgBr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ChrgBr), input_name='ChrgBr')), namespaceprefix_ , eol_))
        for ChrgsInf_ in self.ChrgsInf:
            namespaceprefix_ = self.ChrgsInf_nsprefix_ + ':' if (UseCapturedNS_ and self.ChrgsInf_nsprefix_) else ''
            ChrgsInf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChrgsInf', pretty_print=pretty_print)
        if self.PrvsInstgAgt1 is not None:
            namespaceprefix_ = self.PrvsInstgAgt1_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvsInstgAgt1_nsprefix_) else ''
            self.PrvsInstgAgt1.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrvsInstgAgt1', pretty_print=pretty_print)
        if self.PrvsInstgAgt1Acct is not None:
            namespaceprefix_ = self.PrvsInstgAgt1Acct_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvsInstgAgt1Acct_nsprefix_) else ''
            self.PrvsInstgAgt1Acct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrvsInstgAgt1Acct', pretty_print=pretty_print)
        if self.PrvsInstgAgt2 is not None:
            namespaceprefix_ = self.PrvsInstgAgt2_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvsInstgAgt2_nsprefix_) else ''
            self.PrvsInstgAgt2.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrvsInstgAgt2', pretty_print=pretty_print)
        if self.PrvsInstgAgt2Acct is not None:
            namespaceprefix_ = self.PrvsInstgAgt2Acct_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvsInstgAgt2Acct_nsprefix_) else ''
            self.PrvsInstgAgt2Acct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrvsInstgAgt2Acct', pretty_print=pretty_print)
        if self.PrvsInstgAgt3 is not None:
            namespaceprefix_ = self.PrvsInstgAgt3_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvsInstgAgt3_nsprefix_) else ''
            self.PrvsInstgAgt3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrvsInstgAgt3', pretty_print=pretty_print)
        if self.PrvsInstgAgt3Acct is not None:
            namespaceprefix_ = self.PrvsInstgAgt3Acct_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvsInstgAgt3Acct_nsprefix_) else ''
            self.PrvsInstgAgt3Acct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrvsInstgAgt3Acct', pretty_print=pretty_print)
        if self.InstgAgt is not None:
            namespaceprefix_ = self.InstgAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstgAgt_nsprefix_) else ''
            self.InstgAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstgAgt', pretty_print=pretty_print)
        if self.InstdAgt is not None:
            namespaceprefix_ = self.InstdAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstdAgt_nsprefix_) else ''
            self.InstdAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstdAgt', pretty_print=pretty_print)
        if self.IntrmyAgt1 is not None:
            namespaceprefix_ = self.IntrmyAgt1_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrmyAgt1_nsprefix_) else ''
            self.IntrmyAgt1.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntrmyAgt1', pretty_print=pretty_print)
        if self.IntrmyAgt1Acct is not None:
            namespaceprefix_ = self.IntrmyAgt1Acct_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrmyAgt1Acct_nsprefix_) else ''
            self.IntrmyAgt1Acct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntrmyAgt1Acct', pretty_print=pretty_print)
        if self.IntrmyAgt2 is not None:
            namespaceprefix_ = self.IntrmyAgt2_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrmyAgt2_nsprefix_) else ''
            self.IntrmyAgt2.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntrmyAgt2', pretty_print=pretty_print)
        if self.IntrmyAgt2Acct is not None:
            namespaceprefix_ = self.IntrmyAgt2Acct_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrmyAgt2Acct_nsprefix_) else ''
            self.IntrmyAgt2Acct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntrmyAgt2Acct', pretty_print=pretty_print)
        if self.IntrmyAgt3 is not None:
            namespaceprefix_ = self.IntrmyAgt3_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrmyAgt3_nsprefix_) else ''
            self.IntrmyAgt3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntrmyAgt3', pretty_print=pretty_print)
        if self.IntrmyAgt3Acct is not None:
            namespaceprefix_ = self.IntrmyAgt3Acct_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrmyAgt3Acct_nsprefix_) else ''
            self.IntrmyAgt3Acct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntrmyAgt3Acct', pretty_print=pretty_print)
        if self.UltmtDbtr is not None:
            namespaceprefix_ = self.UltmtDbtr_nsprefix_ + ':' if (UseCapturedNS_ and self.UltmtDbtr_nsprefix_) else ''
            self.UltmtDbtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UltmtDbtr', pretty_print=pretty_print)
        if self.InitgPty is not None:
            namespaceprefix_ = self.InitgPty_nsprefix_ + ':' if (UseCapturedNS_ and self.InitgPty_nsprefix_) else ''
            self.InitgPty.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InitgPty', pretty_print=pretty_print)
        if self.Dbtr is not None:
            namespaceprefix_ = self.Dbtr_nsprefix_ + ':' if (UseCapturedNS_ and self.Dbtr_nsprefix_) else ''
            self.Dbtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dbtr', pretty_print=pretty_print)
        if self.DbtrAcct is not None:
            namespaceprefix_ = self.DbtrAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.DbtrAcct_nsprefix_) else ''
            self.DbtrAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DbtrAcct', pretty_print=pretty_print)
        if self.DbtrAgt is not None:
            namespaceprefix_ = self.DbtrAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.DbtrAgt_nsprefix_) else ''
            self.DbtrAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DbtrAgt', pretty_print=pretty_print)
        if self.DbtrAgtAcct is not None:
            namespaceprefix_ = self.DbtrAgtAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.DbtrAgtAcct_nsprefix_) else ''
            self.DbtrAgtAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DbtrAgtAcct', pretty_print=pretty_print)
        if self.CdtrAgt is not None:
            namespaceprefix_ = self.CdtrAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtrAgt_nsprefix_) else ''
            self.CdtrAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdtrAgt', pretty_print=pretty_print)
        if self.CdtrAgtAcct is not None:
            namespaceprefix_ = self.CdtrAgtAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtrAgtAcct_nsprefix_) else ''
            self.CdtrAgtAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdtrAgtAcct', pretty_print=pretty_print)
        if self.Cdtr is not None:
            namespaceprefix_ = self.Cdtr_nsprefix_ + ':' if (UseCapturedNS_ and self.Cdtr_nsprefix_) else ''
            self.Cdtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Cdtr', pretty_print=pretty_print)
        if self.CdtrAcct is not None:
            namespaceprefix_ = self.CdtrAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtrAcct_nsprefix_) else ''
            self.CdtrAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdtrAcct', pretty_print=pretty_print)
        if self.UltmtCdtr is not None:
            namespaceprefix_ = self.UltmtCdtr_nsprefix_ + ':' if (UseCapturedNS_ and self.UltmtCdtr_nsprefix_) else ''
            self.UltmtCdtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UltmtCdtr', pretty_print=pretty_print)
        for InstrForCdtrAgt_ in self.InstrForCdtrAgt:
            namespaceprefix_ = self.InstrForCdtrAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstrForCdtrAgt_nsprefix_) else ''
            InstrForCdtrAgt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstrForCdtrAgt', pretty_print=pretty_print)
        for InstrForNxtAgt_ in self.InstrForNxtAgt:
            namespaceprefix_ = self.InstrForNxtAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstrForNxtAgt_nsprefix_) else ''
            InstrForNxtAgt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstrForNxtAgt', pretty_print=pretty_print)
        if self.Purp is not None:
            namespaceprefix_ = self.Purp_nsprefix_ + ':' if (UseCapturedNS_ and self.Purp_nsprefix_) else ''
            self.Purp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Purp', pretty_print=pretty_print)
        for RgltryRptg_ in self.RgltryRptg:
            namespaceprefix_ = self.RgltryRptg_nsprefix_ + ':' if (UseCapturedNS_ and self.RgltryRptg_nsprefix_) else ''
            RgltryRptg_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RgltryRptg', pretty_print=pretty_print)
        if self.Tax is not None:
            namespaceprefix_ = self.Tax_nsprefix_ + ':' if (UseCapturedNS_ and self.Tax_nsprefix_) else ''
            self.Tax.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tax', pretty_print=pretty_print)
        for RltdRmtInf_ in self.RltdRmtInf:
            namespaceprefix_ = self.RltdRmtInf_nsprefix_ + ':' if (UseCapturedNS_ and self.RltdRmtInf_nsprefix_) else ''
            RltdRmtInf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RltdRmtInf', pretty_print=pretty_print)
        if self.RmtInf is not None:
            namespaceprefix_ = self.RmtInf_nsprefix_ + ':' if (UseCapturedNS_ and self.RmtInf_nsprefix_) else ''
            self.RmtInf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RmtInf', pretty_print=pretty_print)
        for SplmtryData_ in self.SplmtryData:
            namespaceprefix_ = self.SplmtryData_nsprefix_ + ':' if (UseCapturedNS_ and self.SplmtryData_nsprefix_) else ''
            SplmtryData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplmtryData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PmtId':
            obj_ = PaymentIdentification7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PmtId = obj_
            obj_.original_tagname_ = 'PmtId'
        elif nodeName_ == 'PmtTpInf':
            obj_ = PaymentTypeInformation28.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PmtTpInf = obj_
            obj_.original_tagname_ = 'PmtTpInf'
        elif nodeName_ == 'IntrBkSttlmAmt':
            obj_ = ActiveCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntrBkSttlmAmt = obj_
            obj_.original_tagname_ = 'IntrBkSttlmAmt'
        elif nodeName_ == 'IntrBkSttlmDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.IntrBkSttlmDt = dval_
            self.IntrBkSttlmDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.IntrBkSttlmDt)
        elif nodeName_ == 'SttlmPrty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SttlmPrty')
            value_ = self.gds_validate_string(value_, node, 'SttlmPrty')
            self.SttlmPrty = value_
            self.SttlmPrty_nsprefix_ = child_.prefix
            # validate type Priority3Code
            self.validate_Priority3Code(self.SttlmPrty)
        elif nodeName_ == 'SttlmTmIndctn':
            obj_ = SettlementDateTimeIndication1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SttlmTmIndctn = obj_
            obj_.original_tagname_ = 'SttlmTmIndctn'
        elif nodeName_ == 'SttlmTmReq':
            obj_ = SettlementTimeRequest2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SttlmTmReq = obj_
            obj_.original_tagname_ = 'SttlmTmReq'
        elif nodeName_ == 'AccptncDtTm':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.AccptncDtTm = dval_
            self.AccptncDtTm_nsprefix_ = child_.prefix
            # validate type ISODateTime
            self.validate_ISODateTime(self.AccptncDtTm)
        elif nodeName_ == 'PoolgAdjstmntDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PoolgAdjstmntDt = dval_
            self.PoolgAdjstmntDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.PoolgAdjstmntDt)
        elif nodeName_ == 'InstdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstdAmt = obj_
            obj_.original_tagname_ = 'InstdAmt'
        elif nodeName_ == 'XchgRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'XchgRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'XchgRate')
            self.XchgRate = fval_
            self.XchgRate_nsprefix_ = child_.prefix
            # validate type BaseOneRate
            self.validate_BaseOneRate(self.XchgRate)
        elif nodeName_ == 'ChrgBr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ChrgBr')
            value_ = self.gds_validate_string(value_, node, 'ChrgBr')
            self.ChrgBr = value_
            self.ChrgBr_nsprefix_ = child_.prefix
            # validate type ChargeBearerType1Code
            self.validate_ChargeBearerType1Code(self.ChrgBr)
        elif nodeName_ == 'ChrgsInf':
            obj_ = Charges7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ChrgsInf.append(obj_)
            obj_.original_tagname_ = 'ChrgsInf'
        elif nodeName_ == 'PrvsInstgAgt1':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrvsInstgAgt1 = obj_
            obj_.original_tagname_ = 'PrvsInstgAgt1'
        elif nodeName_ == 'PrvsInstgAgt1Acct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrvsInstgAgt1Acct = obj_
            obj_.original_tagname_ = 'PrvsInstgAgt1Acct'
        elif nodeName_ == 'PrvsInstgAgt2':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrvsInstgAgt2 = obj_
            obj_.original_tagname_ = 'PrvsInstgAgt2'
        elif nodeName_ == 'PrvsInstgAgt2Acct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrvsInstgAgt2Acct = obj_
            obj_.original_tagname_ = 'PrvsInstgAgt2Acct'
        elif nodeName_ == 'PrvsInstgAgt3':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrvsInstgAgt3 = obj_
            obj_.original_tagname_ = 'PrvsInstgAgt3'
        elif nodeName_ == 'PrvsInstgAgt3Acct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrvsInstgAgt3Acct = obj_
            obj_.original_tagname_ = 'PrvsInstgAgt3Acct'
        elif nodeName_ == 'InstgAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstgAgt = obj_
            obj_.original_tagname_ = 'InstgAgt'
        elif nodeName_ == 'InstdAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstdAgt = obj_
            obj_.original_tagname_ = 'InstdAgt'
        elif nodeName_ == 'IntrmyAgt1':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntrmyAgt1 = obj_
            obj_.original_tagname_ = 'IntrmyAgt1'
        elif nodeName_ == 'IntrmyAgt1Acct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntrmyAgt1Acct = obj_
            obj_.original_tagname_ = 'IntrmyAgt1Acct'
        elif nodeName_ == 'IntrmyAgt2':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntrmyAgt2 = obj_
            obj_.original_tagname_ = 'IntrmyAgt2'
        elif nodeName_ == 'IntrmyAgt2Acct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntrmyAgt2Acct = obj_
            obj_.original_tagname_ = 'IntrmyAgt2Acct'
        elif nodeName_ == 'IntrmyAgt3':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntrmyAgt3 = obj_
            obj_.original_tagname_ = 'IntrmyAgt3'
        elif nodeName_ == 'IntrmyAgt3Acct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntrmyAgt3Acct = obj_
            obj_.original_tagname_ = 'IntrmyAgt3Acct'
        elif nodeName_ == 'UltmtDbtr':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UltmtDbtr = obj_
            obj_.original_tagname_ = 'UltmtDbtr'
        elif nodeName_ == 'InitgPty':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InitgPty = obj_
            obj_.original_tagname_ = 'InitgPty'
        elif nodeName_ == 'Dbtr':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dbtr = obj_
            obj_.original_tagname_ = 'Dbtr'
        elif nodeName_ == 'DbtrAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DbtrAcct = obj_
            obj_.original_tagname_ = 'DbtrAcct'
        elif nodeName_ == 'DbtrAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DbtrAgt = obj_
            obj_.original_tagname_ = 'DbtrAgt'
        elif nodeName_ == 'DbtrAgtAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DbtrAgtAcct = obj_
            obj_.original_tagname_ = 'DbtrAgtAcct'
        elif nodeName_ == 'CdtrAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdtrAgt = obj_
            obj_.original_tagname_ = 'CdtrAgt'
        elif nodeName_ == 'CdtrAgtAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdtrAgtAcct = obj_
            obj_.original_tagname_ = 'CdtrAgtAcct'
        elif nodeName_ == 'Cdtr':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Cdtr = obj_
            obj_.original_tagname_ = 'Cdtr'
        elif nodeName_ == 'CdtrAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdtrAcct = obj_
            obj_.original_tagname_ = 'CdtrAcct'
        elif nodeName_ == 'UltmtCdtr':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UltmtCdtr = obj_
            obj_.original_tagname_ = 'UltmtCdtr'
        elif nodeName_ == 'InstrForCdtrAgt':
            obj_ = InstructionForCreditorAgent1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstrForCdtrAgt.append(obj_)
            obj_.original_tagname_ = 'InstrForCdtrAgt'
        elif nodeName_ == 'InstrForNxtAgt':
            obj_ = InstructionForNextAgent1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstrForNxtAgt.append(obj_)
            obj_.original_tagname_ = 'InstrForNxtAgt'
        elif nodeName_ == 'Purp':
            obj_ = Purpose2Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Purp = obj_
            obj_.original_tagname_ = 'Purp'
        elif nodeName_ == 'RgltryRptg':
            obj_ = RegulatoryReporting3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RgltryRptg.append(obj_)
            obj_.original_tagname_ = 'RgltryRptg'
        elif nodeName_ == 'Tax':
            obj_ = TaxInformation8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tax = obj_
            obj_.original_tagname_ = 'Tax'
        elif nodeName_ == 'RltdRmtInf':
            obj_ = RemittanceLocation7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RltdRmtInf.append(obj_)
            obj_.original_tagname_ = 'RltdRmtInf'
        elif nodeName_ == 'RmtInf':
            obj_ = RemittanceInformation16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RmtInf = obj_
            obj_.original_tagname_ = 'RmtInf'
        elif nodeName_ == 'SplmtryData':
            obj_ = SupplementaryData1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplmtryData.append(obj_)
            obj_.original_tagname_ = 'SplmtryData'
# end class CreditTransferTransaction39


class CreditorReferenceInformation2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', 'CreditorReferenceType2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'CreditorReferenceType2'}, None),
        'Ref': MemberSpec_('Ref', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Ref', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Ref = Ref
        self.validate_Max35Text(self.Ref)
        self.Ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceInformation2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceInformation2.subclass:
            return CreditorReferenceInformation2.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceInformation2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Ref(self):
        return self.Ref
    def set_Ref(self, Ref):
        self.Ref = Ref
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Tp is not None or
            self.Ref is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditorReferenceInformation2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditorReferenceInformation2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditorReferenceInformation2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditorReferenceInformation2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditorReferenceInformation2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditorReferenceInformation2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditorReferenceInformation2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Ref is not None:
            namespaceprefix_ = self.Ref_nsprefix_ + ':' if (UseCapturedNS_ and self.Ref_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRef>%s</%sRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Ref), input_name='Ref')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            obj_ = CreditorReferenceType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Ref':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ref')
            value_ = self.gds_validate_string(value_, node, 'Ref')
            self.Ref = value_
            self.Ref_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Ref)
# end class CreditorReferenceInformation2


class CreditorReferenceType1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['DocumentType3Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 8),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 8),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_DocumentType3Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceType1Choice.subclass:
            return CreditorReferenceType1Choice.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_DocumentType3Code(self, value):
        result = True
        # Validate type DocumentType3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RADM', 'RPIN', 'FXDR', 'DISP', 'PUOR', 'SCOR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DocumentType3Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditorReferenceType1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditorReferenceType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditorReferenceType1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditorReferenceType1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditorReferenceType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditorReferenceType1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditorReferenceType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type DocumentType3Code
            self.validate_DocumentType3Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CreditorReferenceType1Choice


class CreditorReferenceType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'CdOrPrtry': MemberSpec_('CdOrPrtry', 'CreditorReferenceType1Choice', 0, 0, {'name': 'CdOrPrtry', 'type': 'CreditorReferenceType1Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CdOrPrtry = CdOrPrtry
        self.CdOrPrtry_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceType2.subclass:
            return CreditorReferenceType2.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CdOrPrtry(self):
        return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry):
        self.CdOrPrtry = CdOrPrtry
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditorReferenceType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditorReferenceType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditorReferenceType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditorReferenceType2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditorReferenceType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditorReferenceType2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='CreditorReferenceType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            namespaceprefix_ = self.CdOrPrtry_nsprefix_ + ':' if (UseCapturedNS_ and self.CdOrPrtry_nsprefix_) else ''
            self.CdOrPrtry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CdOrPrtry':
            obj_ = CreditorReferenceType1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class CreditorReferenceType2


class DateAndPlaceOfBirth1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'BirthDt': MemberSpec_('BirthDt', ['ISODate', 'xs:date'], 0, 0, {'name': 'BirthDt', 'type': 'xs:date'}, None),
        'PrvcOfBirth': MemberSpec_('PrvcOfBirth', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PrvcOfBirth', 'type': 'xs:string'}, None),
        'CityOfBirth': MemberSpec_('CityOfBirth', ['Max35Text', 'xs:string'], 0, 0, {'name': 'CityOfBirth', 'type': 'xs:string'}, None),
        'CtryOfBirth': MemberSpec_('CtryOfBirth', ['CountryCode', 'xs:string'], 0, 0, {'name': 'CtryOfBirth', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, BirthDt=None, PrvcOfBirth=None, CityOfBirth=None, CtryOfBirth=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(BirthDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(BirthDt, '%Y-%m-%d').date()
        else:
            initvalue_ = BirthDt
        self.BirthDt = initvalue_
        self.BirthDt_nsprefix_ = None
        self.PrvcOfBirth = PrvcOfBirth
        self.validate_Max35Text(self.PrvcOfBirth)
        self.PrvcOfBirth_nsprefix_ = None
        self.CityOfBirth = CityOfBirth
        self.validate_Max35Text(self.CityOfBirth)
        self.CityOfBirth_nsprefix_ = None
        self.CtryOfBirth = CtryOfBirth
        self.validate_CountryCode(self.CtryOfBirth)
        self.CtryOfBirth_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateAndPlaceOfBirth1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateAndPlaceOfBirth1.subclass:
            return DateAndPlaceOfBirth1.subclass(*args_, **kwargs_)
        else:
            return DateAndPlaceOfBirth1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BirthDt(self):
        return self.BirthDt
    def set_BirthDt(self, BirthDt):
        self.BirthDt = BirthDt
    def get_PrvcOfBirth(self):
        return self.PrvcOfBirth
    def set_PrvcOfBirth(self, PrvcOfBirth):
        self.PrvcOfBirth = PrvcOfBirth
    def get_CityOfBirth(self):
        return self.CityOfBirth
    def set_CityOfBirth(self, CityOfBirth):
        self.CityOfBirth = CityOfBirth
    def get_CtryOfBirth(self):
        return self.CtryOfBirth
    def set_CtryOfBirth(self, CtryOfBirth):
        self.CtryOfBirth = CtryOfBirth
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CountryCode(self, value):
        result = True
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCode_patterns_, ))
                result = False
        return result
    validate_CountryCode_patterns_ = [['^([A-Z]{2,2})$']]
    def has__content(self):
        if (
            self.BirthDt is not None or
            self.PrvcOfBirth is not None or
            self.CityOfBirth is not None or
            self.CtryOfBirth is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DateAndPlaceOfBirth1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateAndPlaceOfBirth1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DateAndPlaceOfBirth1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateAndPlaceOfBirth1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DateAndPlaceOfBirth1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DateAndPlaceOfBirth1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DateAndPlaceOfBirth1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BirthDt is not None:
            namespaceprefix_ = self.BirthDt_nsprefix_ + ':' if (UseCapturedNS_ and self.BirthDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBirthDt>%s</%sBirthDt>%s' % (namespaceprefix_ , self.gds_format_date(self.BirthDt, input_name='BirthDt'), namespaceprefix_ , eol_))
        if self.PrvcOfBirth is not None:
            namespaceprefix_ = self.PrvcOfBirth_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvcOfBirth_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrvcOfBirth>%s</%sPrvcOfBirth>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PrvcOfBirth), input_name='PrvcOfBirth')), namespaceprefix_ , eol_))
        if self.CityOfBirth is not None:
            namespaceprefix_ = self.CityOfBirth_nsprefix_ + ':' if (UseCapturedNS_ and self.CityOfBirth_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCityOfBirth>%s</%sCityOfBirth>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CityOfBirth), input_name='CityOfBirth')), namespaceprefix_ , eol_))
        if self.CtryOfBirth is not None:
            namespaceprefix_ = self.CtryOfBirth_nsprefix_ + ':' if (UseCapturedNS_ and self.CtryOfBirth_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtryOfBirth>%s</%sCtryOfBirth>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CtryOfBirth), input_name='CtryOfBirth')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BirthDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.BirthDt = dval_
            self.BirthDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.BirthDt)
        elif nodeName_ == 'PrvcOfBirth':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PrvcOfBirth')
            value_ = self.gds_validate_string(value_, node, 'PrvcOfBirth')
            self.PrvcOfBirth = value_
            self.PrvcOfBirth_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.PrvcOfBirth)
        elif nodeName_ == 'CityOfBirth':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CityOfBirth')
            value_ = self.gds_validate_string(value_, node, 'CityOfBirth')
            self.CityOfBirth = value_
            self.CityOfBirth_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.CityOfBirth)
        elif nodeName_ == 'CtryOfBirth':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CtryOfBirth')
            value_ = self.gds_validate_string(value_, node, 'CtryOfBirth')
            self.CtryOfBirth = value_
            self.CtryOfBirth_nsprefix_ = child_.prefix
            # validate type CountryCode
            self.validate_CountryCode(self.CtryOfBirth)
# end class DateAndPlaceOfBirth1


class DatePeriod2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'FrDt': MemberSpec_('FrDt', ['ISODate', 'xs:date'], 0, 0, {'name': 'FrDt', 'type': 'xs:date'}, None),
        'ToDt': MemberSpec_('ToDt', ['ISODate', 'xs:date'], 0, 0, {'name': 'ToDt', 'type': 'xs:date'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, FrDt=None, ToDt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(FrDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FrDt, '%Y-%m-%d').date()
        else:
            initvalue_ = FrDt
        self.FrDt = initvalue_
        self.FrDt_nsprefix_ = None
        if isinstance(ToDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ToDt, '%Y-%m-%d').date()
        else:
            initvalue_ = ToDt
        self.ToDt = initvalue_
        self.ToDt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatePeriod2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatePeriod2.subclass:
            return DatePeriod2.subclass(*args_, **kwargs_)
        else:
            return DatePeriod2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FrDt(self):
        return self.FrDt
    def set_FrDt(self, FrDt):
        self.FrDt = FrDt
    def get_ToDt(self):
        return self.ToDt
    def set_ToDt(self, ToDt):
        self.ToDt = ToDt
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.FrDt is not None or
            self.ToDt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DatePeriod2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatePeriod2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DatePeriod2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DatePeriod2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DatePeriod2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DatePeriod2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DatePeriod2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FrDt is not None:
            namespaceprefix_ = self.FrDt_nsprefix_ + ':' if (UseCapturedNS_ and self.FrDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFrDt>%s</%sFrDt>%s' % (namespaceprefix_ , self.gds_format_date(self.FrDt, input_name='FrDt'), namespaceprefix_ , eol_))
        if self.ToDt is not None:
            namespaceprefix_ = self.ToDt_nsprefix_ + ':' if (UseCapturedNS_ and self.ToDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sToDt>%s</%sToDt>%s' % (namespaceprefix_ , self.gds_format_date(self.ToDt, input_name='ToDt'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FrDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FrDt = dval_
            self.FrDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.FrDt)
        elif nodeName_ == 'ToDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ToDt = dval_
            self.ToDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.ToDt)
# end class DatePeriod2


class DiscountAmountAndType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', 'DiscountAmountType1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'DiscountAmountType1Choice'}, None),
        'Amt': MemberSpec_('Amt', 'ActiveOrHistoricCurrencyAndAmount', 0, 0, {'name': 'Amt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Amt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Amt = Amt
        self.Amt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscountAmountAndType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscountAmountAndType1.subclass:
            return DiscountAmountAndType1.subclass(*args_, **kwargs_)
        else:
            return DiscountAmountAndType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Amt(self):
        return self.Amt
    def set_Amt(self, Amt):
        self.Amt = Amt
    def has__content(self):
        if (
            self.Tp is not None or
            self.Amt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DiscountAmountAndType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscountAmountAndType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiscountAmountAndType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiscountAmountAndType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiscountAmountAndType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiscountAmountAndType1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DiscountAmountAndType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Amt is not None:
            namespaceprefix_ = self.Amt_nsprefix_ + ':' if (UseCapturedNS_ and self.Amt_nsprefix_) else ''
            self.Amt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            obj_ = DiscountAmountType1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
# end class DiscountAmountAndType1


class DiscountAmountType1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalDiscountAmountType1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 9),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 9),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalDiscountAmountType1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscountAmountType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscountAmountType1Choice.subclass:
            return DiscountAmountType1Choice.subclass(*args_, **kwargs_)
        else:
            return DiscountAmountType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalDiscountAmountType1Code(self, value):
        result = True
        # Validate type ExternalDiscountAmountType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalDiscountAmountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalDiscountAmountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DiscountAmountType1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscountAmountType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiscountAmountType1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiscountAmountType1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiscountAmountType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiscountAmountType1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DiscountAmountType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalDiscountAmountType1Code
            self.validate_ExternalDiscountAmountType1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class DiscountAmountType1Choice


class Document(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'FIToFICstmrCdtTrf': MemberSpec_('FIToFICstmrCdtTrf', 'FIToFICustomerCreditTransferV08', 0, 0, {'name': 'FIToFICstmrCdtTrf', 'type': 'FIToFICustomerCreditTransferV08'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, FIToFICstmrCdtTrf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FIToFICstmrCdtTrf = FIToFICstmrCdtTrf
        self.FIToFICstmrCdtTrf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Document)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Document.subclass:
            return Document.subclass(*args_, **kwargs_)
        else:
            return Document(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FIToFICstmrCdtTrf(self):
        return self.FIToFICstmrCdtTrf
    def set_FIToFICstmrCdtTrf(self, FIToFICstmrCdtTrf):
        self.FIToFICstmrCdtTrf = FIToFICstmrCdtTrf
    def has__content(self):
        if (
            self.FIToFICstmrCdtTrf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Document', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Document')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Document':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Document')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Document', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Document'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Document', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FIToFICstmrCdtTrf is not None:
            namespaceprefix_ = self.FIToFICstmrCdtTrf_nsprefix_ + ':' if (UseCapturedNS_ and self.FIToFICstmrCdtTrf_nsprefix_) else ''
            self.FIToFICstmrCdtTrf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FIToFICstmrCdtTrf', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FIToFICstmrCdtTrf':
            obj_ = FIToFICustomerCreditTransferV08.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FIToFICstmrCdtTrf = obj_
            obj_.original_tagname_ = 'FIToFICstmrCdtTrf'
# end class Document


class DocumentAdjustment1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Amt': MemberSpec_('Amt', 'ActiveOrHistoricCurrencyAndAmount', 0, 0, {'name': 'Amt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'CdtDbtInd': MemberSpec_('CdtDbtInd', ['CreditDebitCode', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CdtDbtInd', 'type': 'xs:string'}, None),
        'Rsn': MemberSpec_('Rsn', ['Max4Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Rsn', 'type': 'xs:string'}, None),
        'AddtlInf': MemberSpec_('AddtlInf', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'AddtlInf', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Amt=None, CdtDbtInd=None, Rsn=None, AddtlInf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Amt = Amt
        self.Amt_nsprefix_ = None
        self.CdtDbtInd = CdtDbtInd
        self.validate_CreditDebitCode(self.CdtDbtInd)
        self.CdtDbtInd_nsprefix_ = None
        self.Rsn = Rsn
        self.validate_Max4Text(self.Rsn)
        self.Rsn_nsprefix_ = None
        self.AddtlInf = AddtlInf
        self.validate_Max140Text(self.AddtlInf)
        self.AddtlInf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentAdjustment1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentAdjustment1.subclass:
            return DocumentAdjustment1.subclass(*args_, **kwargs_)
        else:
            return DocumentAdjustment1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Amt(self):
        return self.Amt
    def set_Amt(self, Amt):
        self.Amt = Amt
    def get_CdtDbtInd(self):
        return self.CdtDbtInd
    def set_CdtDbtInd(self, CdtDbtInd):
        self.CdtDbtInd = CdtDbtInd
    def get_Rsn(self):
        return self.Rsn
    def set_Rsn(self, Rsn):
        self.Rsn = Rsn
    def get_AddtlInf(self):
        return self.AddtlInf
    def set_AddtlInf(self, AddtlInf):
        self.AddtlInf = AddtlInf
    def validate_CreditDebitCode(self, value):
        result = True
        # Validate type CreditDebitCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CRDT', 'DBIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CreditDebitCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max4Text(self, value):
        result = True
        # Validate type Max4Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max4Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max4Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Amt is not None or
            self.CdtDbtInd is not None or
            self.Rsn is not None or
            self.AddtlInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentAdjustment1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentAdjustment1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentAdjustment1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentAdjustment1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentAdjustment1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocumentAdjustment1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentAdjustment1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amt is not None:
            namespaceprefix_ = self.Amt_nsprefix_ + ':' if (UseCapturedNS_ and self.Amt_nsprefix_) else ''
            self.Amt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amt', pretty_print=pretty_print)
        if self.CdtDbtInd is not None:
            namespaceprefix_ = self.CdtDbtInd_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtDbtInd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCdtDbtInd>%s</%sCdtDbtInd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CdtDbtInd), input_name='CdtDbtInd')), namespaceprefix_ , eol_))
        if self.Rsn is not None:
            namespaceprefix_ = self.Rsn_nsprefix_ + ':' if (UseCapturedNS_ and self.Rsn_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRsn>%s</%sRsn>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Rsn), input_name='Rsn')), namespaceprefix_ , eol_))
        if self.AddtlInf is not None:
            namespaceprefix_ = self.AddtlInf_nsprefix_ + ':' if (UseCapturedNS_ and self.AddtlInf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddtlInf>%s</%sAddtlInf>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AddtlInf), input_name='AddtlInf')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'CdtDbtInd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CdtDbtInd')
            value_ = self.gds_validate_string(value_, node, 'CdtDbtInd')
            self.CdtDbtInd = value_
            self.CdtDbtInd_nsprefix_ = child_.prefix
            # validate type CreditDebitCode
            self.validate_CreditDebitCode(self.CdtDbtInd)
        elif nodeName_ == 'Rsn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Rsn')
            value_ = self.gds_validate_string(value_, node, 'Rsn')
            self.Rsn = value_
            self.Rsn_nsprefix_ = child_.prefix
            # validate type Max4Text
            self.validate_Max4Text(self.Rsn)
        elif nodeName_ == 'AddtlInf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AddtlInf')
            value_ = self.gds_validate_string(value_, node, 'AddtlInf')
            self.AddtlInf = value_
            self.AddtlInf_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlInf)
# end class DocumentAdjustment1


class DocumentLineIdentification1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', 'DocumentLineType1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'DocumentLineType1'}, None),
        'Nb': MemberSpec_('Nb', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nb', 'type': 'xs:string'}, None),
        'RltdDt': MemberSpec_('RltdDt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RltdDt', 'type': 'xs:date'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Nb=None, RltdDt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Nb = Nb
        self.validate_Max35Text(self.Nb)
        self.Nb_nsprefix_ = None
        if isinstance(RltdDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RltdDt, '%Y-%m-%d').date()
        else:
            initvalue_ = RltdDt
        self.RltdDt = initvalue_
        self.RltdDt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentLineIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentLineIdentification1.subclass:
            return DocumentLineIdentification1.subclass(*args_, **kwargs_)
        else:
            return DocumentLineIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Nb(self):
        return self.Nb
    def set_Nb(self, Nb):
        self.Nb = Nb
    def get_RltdDt(self):
        return self.RltdDt
    def set_RltdDt(self, RltdDt):
        self.RltdDt = RltdDt
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.Tp is not None or
            self.Nb is not None or
            self.RltdDt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineIdentification1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentLineIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentLineIdentification1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentLineIdentification1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentLineIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocumentLineIdentification1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Nb is not None:
            namespaceprefix_ = self.Nb_nsprefix_ + ':' if (UseCapturedNS_ and self.Nb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNb>%s</%sNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nb), input_name='Nb')), namespaceprefix_ , eol_))
        if self.RltdDt is not None:
            namespaceprefix_ = self.RltdDt_nsprefix_ + ':' if (UseCapturedNS_ and self.RltdDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRltdDt>%s</%sRltdDt>%s' % (namespaceprefix_ , self.gds_format_date(self.RltdDt, input_name='RltdDt'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            obj_ = DocumentLineType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Nb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nb')
            value_ = self.gds_validate_string(value_, node, 'Nb')
            self.Nb = value_
            self.Nb_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Nb)
        elif nodeName_ == 'RltdDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RltdDt = dval_
            self.RltdDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.RltdDt)
# end class DocumentLineIdentification1


class DocumentLineInformation1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'DocumentLineIdentification1', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'Id', 'type': 'DocumentLineIdentification1'}, None),
        'Desc': MemberSpec_('Desc', ['Max2048Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Desc', 'type': 'xs:string'}, None),
        'Amt': MemberSpec_('Amt', 'RemittanceAmount3', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Amt', 'type': 'RemittanceAmount3'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, Desc=None, Amt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Id is None:
            self.Id = []
        else:
            self.Id = Id
        self.Id_nsprefix_ = None
        self.Desc = Desc
        self.validate_Max2048Text(self.Desc)
        self.Desc_nsprefix_ = None
        self.Amt = Amt
        self.Amt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentLineInformation1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentLineInformation1.subclass:
            return DocumentLineInformation1.subclass(*args_, **kwargs_)
        else:
            return DocumentLineInformation1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def add_Id(self, value):
        self.Id.append(value)
    def insert_Id_at(self, index, value):
        self.Id.insert(index, value)
    def replace_Id_at(self, index, value):
        self.Id[index] = value
    def get_Desc(self):
        return self.Desc
    def set_Desc(self, Desc):
        self.Desc = Desc
    def get_Amt(self):
        return self.Amt
    def set_Amt(self, Amt):
        self.Amt = Amt
    def validate_Max2048Text(self, value):
        result = True
        # Validate type Max2048Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2048:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id or
            self.Desc is not None or
            self.Amt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineInformation1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentLineInformation1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentLineInformation1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentLineInformation1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentLineInformation1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocumentLineInformation1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineInformation1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Id_ in self.Id:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            Id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Desc is not None:
            namespaceprefix_ = self.Desc_nsprefix_ + ':' if (UseCapturedNS_ and self.Desc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDesc>%s</%sDesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Desc), input_name='Desc')), namespaceprefix_ , eol_))
        if self.Amt is not None:
            namespaceprefix_ = self.Amt_nsprefix_ + ':' if (UseCapturedNS_ and self.Amt_nsprefix_) else ''
            self.Amt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = DocumentLineIdentification1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id.append(obj_)
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Desc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Desc')
            value_ = self.gds_validate_string(value_, node, 'Desc')
            self.Desc = value_
            self.Desc_nsprefix_ = child_.prefix
            # validate type Max2048Text
            self.validate_Max2048Text(self.Desc)
        elif nodeName_ == 'Amt':
            obj_ = RemittanceAmount3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
# end class DocumentLineInformation1


class DocumentLineType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'CdOrPrtry': MemberSpec_('CdOrPrtry', 'DocumentLineType1Choice', 0, 0, {'name': 'CdOrPrtry', 'type': 'DocumentLineType1Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CdOrPrtry = CdOrPrtry
        self.CdOrPrtry_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentLineType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentLineType1.subclass:
            return DocumentLineType1.subclass(*args_, **kwargs_)
        else:
            return DocumentLineType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CdOrPrtry(self):
        return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry):
        self.CdOrPrtry = CdOrPrtry
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentLineType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentLineType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentLineType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentLineType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocumentLineType1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            namespaceprefix_ = self.CdOrPrtry_nsprefix_ + ':' if (UseCapturedNS_ and self.CdOrPrtry_nsprefix_) else ''
            self.CdOrPrtry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CdOrPrtry':
            obj_ = DocumentLineType1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class DocumentLineType1


class DocumentLineType1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalDocumentLineType1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 10),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 10),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalDocumentLineType1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentLineType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentLineType1Choice.subclass:
            return DocumentLineType1Choice.subclass(*args_, **kwargs_)
        else:
            return DocumentLineType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalDocumentLineType1Code(self, value):
        result = True
        # Validate type ExternalDocumentLineType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalDocumentLineType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalDocumentLineType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineType1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentLineType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentLineType1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentLineType1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentLineType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocumentLineType1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='DocumentLineType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalDocumentLineType1Code
            self.validate_ExternalDocumentLineType1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class DocumentLineType1Choice


class FIToFICustomerCreditTransferV08(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'GrpHdr': MemberSpec_('GrpHdr', 'GroupHeader93', 0, 0, {'name': 'GrpHdr', 'type': 'GroupHeader93'}, None),
        'CdtTrfTxInf': MemberSpec_('CdtTrfTxInf', 'CreditTransferTransaction39', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'CdtTrfTxInf', 'type': 'CreditTransferTransaction39'}, None),
        'SplmtryData': MemberSpec_('SplmtryData', 'SupplementaryData1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'SplmtryData', 'type': 'SupplementaryData1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, GrpHdr=None, CdtTrfTxInf=None, SplmtryData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GrpHdr = GrpHdr
        self.GrpHdr_nsprefix_ = None
        if CdtTrfTxInf is None:
            self.CdtTrfTxInf = []
        else:
            self.CdtTrfTxInf = CdtTrfTxInf
        self.CdtTrfTxInf_nsprefix_ = None
        if SplmtryData is None:
            self.SplmtryData = []
        else:
            self.SplmtryData = SplmtryData
        self.SplmtryData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FIToFICustomerCreditTransferV08)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FIToFICustomerCreditTransferV08.subclass:
            return FIToFICustomerCreditTransferV08.subclass(*args_, **kwargs_)
        else:
            return FIToFICustomerCreditTransferV08(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GrpHdr(self):
        return self.GrpHdr
    def set_GrpHdr(self, GrpHdr):
        self.GrpHdr = GrpHdr
    def get_CdtTrfTxInf(self):
        return self.CdtTrfTxInf
    def set_CdtTrfTxInf(self, CdtTrfTxInf):
        self.CdtTrfTxInf = CdtTrfTxInf
    def add_CdtTrfTxInf(self, value):
        self.CdtTrfTxInf.append(value)
    def insert_CdtTrfTxInf_at(self, index, value):
        self.CdtTrfTxInf.insert(index, value)
    def replace_CdtTrfTxInf_at(self, index, value):
        self.CdtTrfTxInf[index] = value
    def get_SplmtryData(self):
        return self.SplmtryData
    def set_SplmtryData(self, SplmtryData):
        self.SplmtryData = SplmtryData
    def add_SplmtryData(self, value):
        self.SplmtryData.append(value)
    def insert_SplmtryData_at(self, index, value):
        self.SplmtryData.insert(index, value)
    def replace_SplmtryData_at(self, index, value):
        self.SplmtryData[index] = value
    def has__content(self):
        if (
            self.GrpHdr is not None or
            self.CdtTrfTxInf or
            self.SplmtryData
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='FIToFICustomerCreditTransferV08', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FIToFICustomerCreditTransferV08')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FIToFICustomerCreditTransferV08':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FIToFICustomerCreditTransferV08')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FIToFICustomerCreditTransferV08', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FIToFICustomerCreditTransferV08'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='FIToFICustomerCreditTransferV08', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GrpHdr is not None:
            namespaceprefix_ = self.GrpHdr_nsprefix_ + ':' if (UseCapturedNS_ and self.GrpHdr_nsprefix_) else ''
            self.GrpHdr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrpHdr', pretty_print=pretty_print)
        for CdtTrfTxInf_ in self.CdtTrfTxInf:
            namespaceprefix_ = self.CdtTrfTxInf_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtTrfTxInf_nsprefix_) else ''
            CdtTrfTxInf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdtTrfTxInf', pretty_print=pretty_print)
        for SplmtryData_ in self.SplmtryData:
            namespaceprefix_ = self.SplmtryData_nsprefix_ + ':' if (UseCapturedNS_ and self.SplmtryData_nsprefix_) else ''
            SplmtryData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplmtryData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GrpHdr':
            obj_ = GroupHeader93.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrpHdr = obj_
            obj_.original_tagname_ = 'GrpHdr'
        elif nodeName_ == 'CdtTrfTxInf':
            obj_ = CreditTransferTransaction39.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdtTrfTxInf.append(obj_)
            obj_.original_tagname_ = 'CdtTrfTxInf'
        elif nodeName_ == 'SplmtryData':
            obj_ = SupplementaryData1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplmtryData.append(obj_)
            obj_.original_tagname_ = 'SplmtryData'
# end class FIToFICustomerCreditTransferV08


class FinancialIdentificationSchemeName1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalFinancialInstitutionIdentification1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 11),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 11),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalFinancialInstitutionIdentification1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialIdentificationSchemeName1Choice.subclass:
            return FinancialIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return FinancialIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalFinancialInstitutionIdentification1Code(self, value):
        result = True
        # Validate type ExternalFinancialInstitutionIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalFinancialInstitutionIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalFinancialInstitutionIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='FinancialIdentificationSchemeName1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinancialIdentificationSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FinancialIdentificationSchemeName1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FinancialIdentificationSchemeName1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FinancialIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FinancialIdentificationSchemeName1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='FinancialIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalFinancialInstitutionIdentification1Code
            self.validate_ExternalFinancialInstitutionIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class FinancialIdentificationSchemeName1Choice


class FinancialInstitutionIdentification18(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'BICFI': MemberSpec_('BICFI', ['BICFIDec2014Identifier', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'BICFI', 'type': 'xs:string'}, None),
        'ClrSysMmbId': MemberSpec_('ClrSysMmbId', 'ClearingSystemMemberIdentification2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ClrSysMmbId', 'type': 'ClearingSystemMemberIdentification2'}, None),
        'LEI': MemberSpec_('LEI', ['LEIIdentifier', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'LEI', 'type': 'xs:string'}, None),
        'Nm': MemberSpec_('Nm', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nm', 'type': 'xs:string'}, None),
        'PstlAdr': MemberSpec_('PstlAdr', 'PostalAddress24', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PstlAdr', 'type': 'PostalAddress24'}, None),
        'Othr': MemberSpec_('Othr', 'GenericFinancialIdentification1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Othr', 'type': 'GenericFinancialIdentification1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, BICFI=None, ClrSysMmbId=None, LEI=None, Nm=None, PstlAdr=None, Othr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BICFI = BICFI
        self.validate_BICFIDec2014Identifier(self.BICFI)
        self.BICFI_nsprefix_ = None
        self.ClrSysMmbId = ClrSysMmbId
        self.ClrSysMmbId_nsprefix_ = None
        self.LEI = LEI
        self.validate_LEIIdentifier(self.LEI)
        self.LEI_nsprefix_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Nm_nsprefix_ = None
        self.PstlAdr = PstlAdr
        self.PstlAdr_nsprefix_ = None
        self.Othr = Othr
        self.Othr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialInstitutionIdentification18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialInstitutionIdentification18.subclass:
            return FinancialInstitutionIdentification18.subclass(*args_, **kwargs_)
        else:
            return FinancialInstitutionIdentification18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BICFI(self):
        return self.BICFI
    def set_BICFI(self, BICFI):
        self.BICFI = BICFI
    def get_ClrSysMmbId(self):
        return self.ClrSysMmbId
    def set_ClrSysMmbId(self, ClrSysMmbId):
        self.ClrSysMmbId = ClrSysMmbId
    def get_LEI(self):
        return self.LEI
    def set_LEI(self, LEI):
        self.LEI = LEI
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def get_PstlAdr(self):
        return self.PstlAdr
    def set_PstlAdr(self, PstlAdr):
        self.PstlAdr = PstlAdr
    def get_Othr(self):
        return self.Othr
    def set_Othr(self, Othr):
        self.Othr = Othr
    def validate_BICFIDec2014Identifier(self, value):
        result = True
        # Validate type BICFIDec2014Identifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_BICFIDec2014Identifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BICFIDec2014Identifier_patterns_, ))
                result = False
        return result
    validate_BICFIDec2014Identifier_patterns_ = [['^([A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1})$']]
    def validate_LEIIdentifier(self, value):
        result = True
        # Validate type LEIIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_LEIIdentifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LEIIdentifier_patterns_, ))
                result = False
        return result
    validate_LEIIdentifier_patterns_ = [['^([A-Z0-9]{18,18}[0-9]{2,2})$']]
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.BICFI is not None or
            self.ClrSysMmbId is not None or
            self.LEI is not None or
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='FinancialInstitutionIdentification18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinancialInstitutionIdentification18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FinancialInstitutionIdentification18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FinancialInstitutionIdentification18')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FinancialInstitutionIdentification18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FinancialInstitutionIdentification18'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='FinancialInstitutionIdentification18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BICFI is not None:
            namespaceprefix_ = self.BICFI_nsprefix_ + ':' if (UseCapturedNS_ and self.BICFI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBICFI>%s</%sBICFI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BICFI), input_name='BICFI')), namespaceprefix_ , eol_))
        if self.ClrSysMmbId is not None:
            namespaceprefix_ = self.ClrSysMmbId_nsprefix_ + ':' if (UseCapturedNS_ and self.ClrSysMmbId_nsprefix_) else ''
            self.ClrSysMmbId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClrSysMmbId', pretty_print=pretty_print)
        if self.LEI is not None:
            namespaceprefix_ = self.LEI_nsprefix_ + ':' if (UseCapturedNS_ and self.LEI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLEI>%s</%sLEI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LEI), input_name='LEI')), namespaceprefix_ , eol_))
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
        if self.PstlAdr is not None:
            namespaceprefix_ = self.PstlAdr_nsprefix_ + ':' if (UseCapturedNS_ and self.PstlAdr_nsprefix_) else ''
            self.PstlAdr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PstlAdr', pretty_print=pretty_print)
        if self.Othr is not None:
            namespaceprefix_ = self.Othr_nsprefix_ + ':' if (UseCapturedNS_ and self.Othr_nsprefix_) else ''
            self.Othr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Othr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BICFI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BICFI')
            value_ = self.gds_validate_string(value_, node, 'BICFI')
            self.BICFI = value_
            self.BICFI_nsprefix_ = child_.prefix
            # validate type BICFIDec2014Identifier
            self.validate_BICFIDec2014Identifier(self.BICFI)
        elif nodeName_ == 'ClrSysMmbId':
            obj_ = ClearingSystemMemberIdentification2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClrSysMmbId = obj_
            obj_.original_tagname_ = 'ClrSysMmbId'
        elif nodeName_ == 'LEI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LEI')
            value_ = self.gds_validate_string(value_, node, 'LEI')
            self.LEI = value_
            self.LEI_nsprefix_ = child_.prefix
            # validate type LEIIdentifier
            self.validate_LEIIdentifier(self.LEI)
        elif nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Othr':
            obj_ = GenericFinancialIdentification1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class FinancialInstitutionIdentification18


class Garnishment3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', 'GarnishmentType1', 0, 0, {'name': 'Tp', 'type': 'GarnishmentType1'}, None),
        'Grnshee': MemberSpec_('Grnshee', 'PartyIdentification135', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Grnshee', 'type': 'PartyIdentification135'}, None),
        'GrnshmtAdmstr': MemberSpec_('GrnshmtAdmstr', 'PartyIdentification135', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'GrnshmtAdmstr', 'type': 'PartyIdentification135'}, None),
        'RefNb': MemberSpec_('RefNb', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RefNb', 'type': 'xs:string'}, None),
        'Dt': MemberSpec_('Dt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dt', 'type': 'xs:date'}, None),
        'RmtdAmt': MemberSpec_('RmtdAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RmtdAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'FmlyMdclInsrncInd': MemberSpec_('FmlyMdclInsrncInd', ['TrueFalseIndicator', 'xs:boolean'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'FmlyMdclInsrncInd', 'type': 'xs:boolean'}, None),
        'MplyeeTermntnInd': MemberSpec_('MplyeeTermntnInd', ['TrueFalseIndicator', 'xs:boolean'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'MplyeeTermntnInd', 'type': 'xs:boolean'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Grnshee=None, GrnshmtAdmstr=None, RefNb=None, Dt=None, RmtdAmt=None, FmlyMdclInsrncInd=None, MplyeeTermntnInd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Grnshee = Grnshee
        self.Grnshee_nsprefix_ = None
        self.GrnshmtAdmstr = GrnshmtAdmstr
        self.GrnshmtAdmstr_nsprefix_ = None
        self.RefNb = RefNb
        self.validate_Max140Text(self.RefNb)
        self.RefNb_nsprefix_ = None
        if isinstance(Dt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Dt, '%Y-%m-%d').date()
        else:
            initvalue_ = Dt
        self.Dt = initvalue_
        self.Dt_nsprefix_ = None
        self.RmtdAmt = RmtdAmt
        self.RmtdAmt_nsprefix_ = None
        self.FmlyMdclInsrncInd = FmlyMdclInsrncInd
        self.validate_TrueFalseIndicator(self.FmlyMdclInsrncInd)
        self.FmlyMdclInsrncInd_nsprefix_ = None
        self.MplyeeTermntnInd = MplyeeTermntnInd
        self.validate_TrueFalseIndicator(self.MplyeeTermntnInd)
        self.MplyeeTermntnInd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Garnishment3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Garnishment3.subclass:
            return Garnishment3.subclass(*args_, **kwargs_)
        else:
            return Garnishment3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Grnshee(self):
        return self.Grnshee
    def set_Grnshee(self, Grnshee):
        self.Grnshee = Grnshee
    def get_GrnshmtAdmstr(self):
        return self.GrnshmtAdmstr
    def set_GrnshmtAdmstr(self, GrnshmtAdmstr):
        self.GrnshmtAdmstr = GrnshmtAdmstr
    def get_RefNb(self):
        return self.RefNb
    def set_RefNb(self, RefNb):
        self.RefNb = RefNb
    def get_Dt(self):
        return self.Dt
    def set_Dt(self, Dt):
        self.Dt = Dt
    def get_RmtdAmt(self):
        return self.RmtdAmt
    def set_RmtdAmt(self, RmtdAmt):
        self.RmtdAmt = RmtdAmt
    def get_FmlyMdclInsrncInd(self):
        return self.FmlyMdclInsrncInd
    def set_FmlyMdclInsrncInd(self, FmlyMdclInsrncInd):
        self.FmlyMdclInsrncInd = FmlyMdclInsrncInd
    def get_MplyeeTermntnInd(self):
        return self.MplyeeTermntnInd
    def set_MplyeeTermntnInd(self, MplyeeTermntnInd):
        self.MplyeeTermntnInd = MplyeeTermntnInd
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_TrueFalseIndicator(self, value):
        result = True
        # Validate type TrueFalseIndicator, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            self.Tp is not None or
            self.Grnshee is not None or
            self.GrnshmtAdmstr is not None or
            self.RefNb is not None or
            self.Dt is not None or
            self.RmtdAmt is not None or
            self.FmlyMdclInsrncInd is not None or
            self.MplyeeTermntnInd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Garnishment3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Garnishment3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Garnishment3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Garnishment3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Garnishment3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Garnishment3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Garnishment3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Grnshee is not None:
            namespaceprefix_ = self.Grnshee_nsprefix_ + ':' if (UseCapturedNS_ and self.Grnshee_nsprefix_) else ''
            self.Grnshee.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Grnshee', pretty_print=pretty_print)
        if self.GrnshmtAdmstr is not None:
            namespaceprefix_ = self.GrnshmtAdmstr_nsprefix_ + ':' if (UseCapturedNS_ and self.GrnshmtAdmstr_nsprefix_) else ''
            self.GrnshmtAdmstr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrnshmtAdmstr', pretty_print=pretty_print)
        if self.RefNb is not None:
            namespaceprefix_ = self.RefNb_nsprefix_ + ':' if (UseCapturedNS_ and self.RefNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefNb>%s</%sRefNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RefNb), input_name='RefNb')), namespaceprefix_ , eol_))
        if self.Dt is not None:
            namespaceprefix_ = self.Dt_nsprefix_ + ':' if (UseCapturedNS_ and self.Dt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDt>%s</%sDt>%s' % (namespaceprefix_ , self.gds_format_date(self.Dt, input_name='Dt'), namespaceprefix_ , eol_))
        if self.RmtdAmt is not None:
            namespaceprefix_ = self.RmtdAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.RmtdAmt_nsprefix_) else ''
            self.RmtdAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RmtdAmt', pretty_print=pretty_print)
        if self.FmlyMdclInsrncInd is not None:
            namespaceprefix_ = self.FmlyMdclInsrncInd_nsprefix_ + ':' if (UseCapturedNS_ and self.FmlyMdclInsrncInd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFmlyMdclInsrncInd>%s</%sFmlyMdclInsrncInd>%s' % (namespaceprefix_ , self.gds_format_boolean(self.FmlyMdclInsrncInd, input_name='FmlyMdclInsrncInd'), namespaceprefix_ , eol_))
        if self.MplyeeTermntnInd is not None:
            namespaceprefix_ = self.MplyeeTermntnInd_nsprefix_ + ':' if (UseCapturedNS_ and self.MplyeeTermntnInd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMplyeeTermntnInd>%s</%sMplyeeTermntnInd>%s' % (namespaceprefix_ , self.gds_format_boolean(self.MplyeeTermntnInd, input_name='MplyeeTermntnInd'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            obj_ = GarnishmentType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Grnshee':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Grnshee = obj_
            obj_.original_tagname_ = 'Grnshee'
        elif nodeName_ == 'GrnshmtAdmstr':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrnshmtAdmstr = obj_
            obj_.original_tagname_ = 'GrnshmtAdmstr'
        elif nodeName_ == 'RefNb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RefNb')
            value_ = self.gds_validate_string(value_, node, 'RefNb')
            self.RefNb = value_
            self.RefNb_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.RefNb)
        elif nodeName_ == 'Dt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Dt = dval_
            self.Dt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.Dt)
        elif nodeName_ == 'RmtdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RmtdAmt = obj_
            obj_.original_tagname_ = 'RmtdAmt'
        elif nodeName_ == 'FmlyMdclInsrncInd':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'FmlyMdclInsrncInd')
            ival_ = self.gds_validate_boolean(ival_, node, 'FmlyMdclInsrncInd')
            self.FmlyMdclInsrncInd = ival_
            self.FmlyMdclInsrncInd_nsprefix_ = child_.prefix
            # validate type TrueFalseIndicator
            self.validate_TrueFalseIndicator(self.FmlyMdclInsrncInd)
        elif nodeName_ == 'MplyeeTermntnInd':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'MplyeeTermntnInd')
            ival_ = self.gds_validate_boolean(ival_, node, 'MplyeeTermntnInd')
            self.MplyeeTermntnInd = ival_
            self.MplyeeTermntnInd_nsprefix_ = child_.prefix
            # validate type TrueFalseIndicator
            self.validate_TrueFalseIndicator(self.MplyeeTermntnInd)
# end class Garnishment3


class GarnishmentType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'CdOrPrtry': MemberSpec_('CdOrPrtry', 'GarnishmentType1Choice', 0, 0, {'name': 'CdOrPrtry', 'type': 'GarnishmentType1Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CdOrPrtry = CdOrPrtry
        self.CdOrPrtry_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GarnishmentType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GarnishmentType1.subclass:
            return GarnishmentType1.subclass(*args_, **kwargs_)
        else:
            return GarnishmentType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CdOrPrtry(self):
        return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry):
        self.CdOrPrtry = CdOrPrtry
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GarnishmentType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GarnishmentType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GarnishmentType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GarnishmentType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GarnishmentType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GarnishmentType1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GarnishmentType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            namespaceprefix_ = self.CdOrPrtry_nsprefix_ + ':' if (UseCapturedNS_ and self.CdOrPrtry_nsprefix_) else ''
            self.CdOrPrtry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CdOrPrtry':
            obj_ = GarnishmentType1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GarnishmentType1


class GarnishmentType1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalGarnishmentType1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 12),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 12),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalGarnishmentType1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GarnishmentType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GarnishmentType1Choice.subclass:
            return GarnishmentType1Choice.subclass(*args_, **kwargs_)
        else:
            return GarnishmentType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalGarnishmentType1Code(self, value):
        result = True
        # Validate type ExternalGarnishmentType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalGarnishmentType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalGarnishmentType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GarnishmentType1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GarnishmentType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GarnishmentType1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GarnishmentType1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GarnishmentType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GarnishmentType1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GarnishmentType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalGarnishmentType1Code
            self.validate_ExternalGarnishmentType1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class GarnishmentType1Choice


class GenericAccountIdentification1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', ['Max34Text', 'xs:string'], 0, 0, {'name': 'Id', 'type': 'xs:string'}, None),
        'SchmeNm': MemberSpec_('SchmeNm', 'AccountSchemeName1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SchmeNm', 'type': 'AccountSchemeName1Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.validate_Max34Text(self.Id)
        self.Id_nsprefix_ = None
        self.SchmeNm = SchmeNm
        self.SchmeNm_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericAccountIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericAccountIdentification1.subclass:
            return GenericAccountIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericAccountIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_SchmeNm(self):
        return self.SchmeNm
    def set_SchmeNm(self, SchmeNm):
        self.SchmeNm = SchmeNm
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max34Text(self, value):
        result = True
        # Validate type Max34Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 34:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max34Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max34Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericAccountIdentification1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericAccountIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GenericAccountIdentification1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericAccountIdentification1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GenericAccountIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GenericAccountIdentification1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericAccountIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
        if self.SchmeNm is not None:
            namespaceprefix_ = self.SchmeNm_nsprefix_ + ':' if (UseCapturedNS_ and self.SchmeNm_nsprefix_) else ''
            self.SchmeNm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Max34Text
            self.validate_Max34Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = AccountSchemeName1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericAccountIdentification1


class GenericFinancialIdentification1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Id', 'type': 'xs:string'}, None),
        'SchmeNm': MemberSpec_('SchmeNm', 'FinancialIdentificationSchemeName1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SchmeNm', 'type': 'FinancialIdentificationSchemeName1Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.Id_nsprefix_ = None
        self.SchmeNm = SchmeNm
        self.SchmeNm_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericFinancialIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericFinancialIdentification1.subclass:
            return GenericFinancialIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericFinancialIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_SchmeNm(self):
        return self.SchmeNm
    def set_SchmeNm(self, SchmeNm):
        self.SchmeNm = SchmeNm
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericFinancialIdentification1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericFinancialIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GenericFinancialIdentification1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericFinancialIdentification1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GenericFinancialIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GenericFinancialIdentification1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericFinancialIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
        if self.SchmeNm is not None:
            namespaceprefix_ = self.SchmeNm_nsprefix_ + ':' if (UseCapturedNS_ and self.SchmeNm_nsprefix_) else ''
            self.SchmeNm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = FinancialIdentificationSchemeName1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericFinancialIdentification1


class GenericIdentification30(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', ['Exact4AlphaNumericText', 'xs:string'], 0, 0, {'name': 'Id', 'type': 'xs:string'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Issr', 'type': 'xs:string'}, None),
        'SchmeNm': MemberSpec_('SchmeNm', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SchmeNm', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, Issr=None, SchmeNm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.validate_Exact4AlphaNumericText(self.Id)
        self.Id_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
        self.SchmeNm = SchmeNm
        self.validate_Max35Text(self.SchmeNm)
        self.SchmeNm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericIdentification30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericIdentification30.subclass:
            return GenericIdentification30.subclass(*args_, **kwargs_)
        else:
            return GenericIdentification30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def get_SchmeNm(self):
        return self.SchmeNm
    def set_SchmeNm(self, SchmeNm):
        self.SchmeNm = SchmeNm
    def validate_Exact4AlphaNumericText(self, value):
        result = True
        # Validate type Exact4AlphaNumericText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Exact4AlphaNumericText_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Exact4AlphaNumericText_patterns_, ))
                result = False
        return result
    validate_Exact4AlphaNumericText_patterns_ = [['^([a-zA-Z0-9]{4})$']]
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id is not None or
            self.Issr is not None or
            self.SchmeNm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericIdentification30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericIdentification30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GenericIdentification30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericIdentification30')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GenericIdentification30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GenericIdentification30'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericIdentification30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
        if self.SchmeNm is not None:
            namespaceprefix_ = self.SchmeNm_nsprefix_ + ':' if (UseCapturedNS_ and self.SchmeNm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSchmeNm>%s</%sSchmeNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SchmeNm), input_name='SchmeNm')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Exact4AlphaNumericText
            self.validate_Exact4AlphaNumericText(self.Id)
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
        elif nodeName_ == 'SchmeNm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SchmeNm')
            value_ = self.gds_validate_string(value_, node, 'SchmeNm')
            self.SchmeNm = value_
            self.SchmeNm_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.SchmeNm)
# end class GenericIdentification30


class GenericOrganisationIdentification1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Id', 'type': 'xs:string'}, None),
        'SchmeNm': MemberSpec_('SchmeNm', 'OrganisationIdentificationSchemeName1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SchmeNm', 'type': 'OrganisationIdentificationSchemeName1Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.Id_nsprefix_ = None
        self.SchmeNm = SchmeNm
        self.SchmeNm_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericOrganisationIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericOrganisationIdentification1.subclass:
            return GenericOrganisationIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericOrganisationIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_SchmeNm(self):
        return self.SchmeNm
    def set_SchmeNm(self, SchmeNm):
        self.SchmeNm = SchmeNm
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericOrganisationIdentification1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericOrganisationIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GenericOrganisationIdentification1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericOrganisationIdentification1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GenericOrganisationIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GenericOrganisationIdentification1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericOrganisationIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
        if self.SchmeNm is not None:
            namespaceprefix_ = self.SchmeNm_nsprefix_ + ':' if (UseCapturedNS_ and self.SchmeNm_nsprefix_) else ''
            self.SchmeNm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = OrganisationIdentificationSchemeName1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericOrganisationIdentification1


class GenericPersonIdentification1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Id': MemberSpec_('Id', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Id', 'type': 'xs:string'}, None),
        'SchmeNm': MemberSpec_('SchmeNm', 'PersonIdentificationSchemeName1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SchmeNm', 'type': 'PersonIdentificationSchemeName1Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.Id_nsprefix_ = None
        self.SchmeNm = SchmeNm
        self.SchmeNm_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericPersonIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericPersonIdentification1.subclass:
            return GenericPersonIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericPersonIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_SchmeNm(self):
        return self.SchmeNm
    def set_SchmeNm(self, SchmeNm):
        self.SchmeNm = SchmeNm
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericPersonIdentification1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericPersonIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GenericPersonIdentification1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericPersonIdentification1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GenericPersonIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GenericPersonIdentification1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GenericPersonIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
        if self.SchmeNm is not None:
            namespaceprefix_ = self.SchmeNm_nsprefix_ + ':' if (UseCapturedNS_ and self.SchmeNm_nsprefix_) else ''
            self.SchmeNm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = PersonIdentificationSchemeName1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericPersonIdentification1


class GroupHeader93(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'MsgId': MemberSpec_('MsgId', ['Max35Text', 'xs:string'], 0, 0, {'name': 'MsgId', 'type': 'xs:string'}, None),
        'CreDtTm': MemberSpec_('CreDtTm', ['ISODateTime', 'xs:dateTime'], 0, 0, {'name': 'CreDtTm', 'type': 'xs:dateTime'}, None),
        'BtchBookg': MemberSpec_('BtchBookg', ['BatchBookingIndicator', 'xs:boolean'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'BtchBookg', 'type': 'xs:boolean'}, None),
        'NbOfTxs': MemberSpec_('NbOfTxs', ['Max15NumericText', 'xs:string'], 0, 0, {'name': 'NbOfTxs', 'type': 'xs:string'}, None),
        'CtrlSum': MemberSpec_('CtrlSum', ['DecimalNumber', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CtrlSum', 'type': 'xs:decimal'}, None),
        'TtlIntrBkSttlmAmt': MemberSpec_('TtlIntrBkSttlmAmt', 'ActiveCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TtlIntrBkSttlmAmt', 'type': 'ActiveCurrencyAndAmount'}, None),
        'IntrBkSttlmDt': MemberSpec_('IntrBkSttlmDt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'IntrBkSttlmDt', 'type': 'xs:date'}, None),
        'SttlmInf': MemberSpec_('SttlmInf', 'SettlementInstruction7', 0, 0, {'name': 'SttlmInf', 'type': 'SettlementInstruction7'}, None),
        'PmtTpInf': MemberSpec_('PmtTpInf', 'PaymentTypeInformation28', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PmtTpInf', 'type': 'PaymentTypeInformation28'}, None),
        'InstgAgt': MemberSpec_('InstgAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstgAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'InstdAgt': MemberSpec_('InstdAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstdAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, MsgId=None, CreDtTm=None, BtchBookg=None, NbOfTxs=None, CtrlSum=None, TtlIntrBkSttlmAmt=None, IntrBkSttlmDt=None, SttlmInf=None, PmtTpInf=None, InstgAgt=None, InstdAgt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MsgId = MsgId
        self.validate_Max35Text(self.MsgId)
        self.MsgId_nsprefix_ = None
        if isinstance(CreDtTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CreDtTm, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CreDtTm
        self.CreDtTm = initvalue_
        self.CreDtTm_nsprefix_ = None
        self.BtchBookg = BtchBookg
        self.validate_BatchBookingIndicator(self.BtchBookg)
        self.BtchBookg_nsprefix_ = None
        self.NbOfTxs = NbOfTxs
        self.validate_Max15NumericText(self.NbOfTxs)
        self.NbOfTxs_nsprefix_ = None
        self.CtrlSum = CtrlSum
        self.validate_DecimalNumber(self.CtrlSum)
        self.CtrlSum_nsprefix_ = None
        self.TtlIntrBkSttlmAmt = TtlIntrBkSttlmAmt
        self.TtlIntrBkSttlmAmt_nsprefix_ = None
        if isinstance(IntrBkSttlmDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(IntrBkSttlmDt, '%Y-%m-%d').date()
        else:
            initvalue_ = IntrBkSttlmDt
        self.IntrBkSttlmDt = initvalue_
        self.IntrBkSttlmDt_nsprefix_ = None
        self.SttlmInf = SttlmInf
        self.SttlmInf_nsprefix_ = None
        self.PmtTpInf = PmtTpInf
        self.PmtTpInf_nsprefix_ = None
        self.InstgAgt = InstgAgt
        self.InstgAgt_nsprefix_ = None
        self.InstdAgt = InstdAgt
        self.InstdAgt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroupHeader93)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroupHeader93.subclass:
            return GroupHeader93.subclass(*args_, **kwargs_)
        else:
            return GroupHeader93(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MsgId(self):
        return self.MsgId
    def set_MsgId(self, MsgId):
        self.MsgId = MsgId
    def get_CreDtTm(self):
        return self.CreDtTm
    def set_CreDtTm(self, CreDtTm):
        self.CreDtTm = CreDtTm
    def get_BtchBookg(self):
        return self.BtchBookg
    def set_BtchBookg(self, BtchBookg):
        self.BtchBookg = BtchBookg
    def get_NbOfTxs(self):
        return self.NbOfTxs
    def set_NbOfTxs(self, NbOfTxs):
        self.NbOfTxs = NbOfTxs
    def get_CtrlSum(self):
        return self.CtrlSum
    def set_CtrlSum(self, CtrlSum):
        self.CtrlSum = CtrlSum
    def get_TtlIntrBkSttlmAmt(self):
        return self.TtlIntrBkSttlmAmt
    def set_TtlIntrBkSttlmAmt(self, TtlIntrBkSttlmAmt):
        self.TtlIntrBkSttlmAmt = TtlIntrBkSttlmAmt
    def get_IntrBkSttlmDt(self):
        return self.IntrBkSttlmDt
    def set_IntrBkSttlmDt(self, IntrBkSttlmDt):
        self.IntrBkSttlmDt = IntrBkSttlmDt
    def get_SttlmInf(self):
        return self.SttlmInf
    def set_SttlmInf(self, SttlmInf):
        self.SttlmInf = SttlmInf
    def get_PmtTpInf(self):
        return self.PmtTpInf
    def set_PmtTpInf(self, PmtTpInf):
        self.PmtTpInf = PmtTpInf
    def get_InstgAgt(self):
        return self.InstgAgt
    def set_InstgAgt(self, InstgAgt):
        self.InstgAgt = InstgAgt
    def get_InstdAgt(self):
        return self.InstdAgt
    def set_InstdAgt(self, InstdAgt):
        self.InstdAgt = InstdAgt
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODateTime(self, value):
        result = True
        # Validate type ISODateTime, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_BatchBookingIndicator(self, value):
        result = True
        # Validate type BatchBookingIndicator, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_Max15NumericText(self, value):
        result = True
        # Validate type Max15NumericText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Max15NumericText_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Max15NumericText_patterns_, ))
                result = False
        return result
    validate_Max15NumericText_patterns_ = [['^([0-9]{1,15})$']]
    def validate_DecimalNumber(self, value):
        result = True
        # Validate type DecimalNumber, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on DecimalNumber' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.MsgId is not None or
            self.CreDtTm is not None or
            self.BtchBookg is not None or
            self.NbOfTxs is not None or
            self.CtrlSum is not None or
            self.TtlIntrBkSttlmAmt is not None or
            self.IntrBkSttlmDt is not None or
            self.SttlmInf is not None or
            self.PmtTpInf is not None or
            self.InstgAgt is not None or
            self.InstdAgt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GroupHeader93', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GroupHeader93')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GroupHeader93':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GroupHeader93')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GroupHeader93', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GroupHeader93'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='GroupHeader93', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MsgId is not None:
            namespaceprefix_ = self.MsgId_nsprefix_ + ':' if (UseCapturedNS_ and self.MsgId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMsgId>%s</%sMsgId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MsgId), input_name='MsgId')), namespaceprefix_ , eol_))
        if self.CreDtTm is not None:
            namespaceprefix_ = self.CreDtTm_nsprefix_ + ':' if (UseCapturedNS_ and self.CreDtTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreDtTm>%s</%sCreDtTm>%s' % (namespaceprefix_ , self.gds_format_datetime(self.CreDtTm, input_name='CreDtTm'), namespaceprefix_ , eol_))
        if self.BtchBookg is not None:
            namespaceprefix_ = self.BtchBookg_nsprefix_ + ':' if (UseCapturedNS_ and self.BtchBookg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBtchBookg>%s</%sBtchBookg>%s' % (namespaceprefix_ , self.gds_format_boolean(self.BtchBookg, input_name='BtchBookg'), namespaceprefix_ , eol_))
        if self.NbOfTxs is not None:
            namespaceprefix_ = self.NbOfTxs_nsprefix_ + ':' if (UseCapturedNS_ and self.NbOfTxs_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNbOfTxs>%s</%sNbOfTxs>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NbOfTxs), input_name='NbOfTxs')), namespaceprefix_ , eol_))
        if self.CtrlSum is not None:
            namespaceprefix_ = self.CtrlSum_nsprefix_ + ':' if (UseCapturedNS_ and self.CtrlSum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrlSum>%s</%sCtrlSum>%s' % (namespaceprefix_ , self.gds_format_decimal(self.CtrlSum, input_name='CtrlSum'), namespaceprefix_ , eol_))
        if self.TtlIntrBkSttlmAmt is not None:
            namespaceprefix_ = self.TtlIntrBkSttlmAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TtlIntrBkSttlmAmt_nsprefix_) else ''
            self.TtlIntrBkSttlmAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TtlIntrBkSttlmAmt', pretty_print=pretty_print)
        if self.IntrBkSttlmDt is not None:
            namespaceprefix_ = self.IntrBkSttlmDt_nsprefix_ + ':' if (UseCapturedNS_ and self.IntrBkSttlmDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIntrBkSttlmDt>%s</%sIntrBkSttlmDt>%s' % (namespaceprefix_ , self.gds_format_date(self.IntrBkSttlmDt, input_name='IntrBkSttlmDt'), namespaceprefix_ , eol_))
        if self.SttlmInf is not None:
            namespaceprefix_ = self.SttlmInf_nsprefix_ + ':' if (UseCapturedNS_ and self.SttlmInf_nsprefix_) else ''
            self.SttlmInf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SttlmInf', pretty_print=pretty_print)
        if self.PmtTpInf is not None:
            namespaceprefix_ = self.PmtTpInf_nsprefix_ + ':' if (UseCapturedNS_ and self.PmtTpInf_nsprefix_) else ''
            self.PmtTpInf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PmtTpInf', pretty_print=pretty_print)
        if self.InstgAgt is not None:
            namespaceprefix_ = self.InstgAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstgAgt_nsprefix_) else ''
            self.InstgAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstgAgt', pretty_print=pretty_print)
        if self.InstdAgt is not None:
            namespaceprefix_ = self.InstdAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstdAgt_nsprefix_) else ''
            self.InstdAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstdAgt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MsgId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MsgId')
            value_ = self.gds_validate_string(value_, node, 'MsgId')
            self.MsgId = value_
            self.MsgId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.MsgId)
        elif nodeName_ == 'CreDtTm':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.CreDtTm = dval_
            self.CreDtTm_nsprefix_ = child_.prefix
            # validate type ISODateTime
            self.validate_ISODateTime(self.CreDtTm)
        elif nodeName_ == 'BtchBookg':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'BtchBookg')
            ival_ = self.gds_validate_boolean(ival_, node, 'BtchBookg')
            self.BtchBookg = ival_
            self.BtchBookg_nsprefix_ = child_.prefix
            # validate type BatchBookingIndicator
            self.validate_BatchBookingIndicator(self.BtchBookg)
        elif nodeName_ == 'NbOfTxs':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NbOfTxs')
            value_ = self.gds_validate_string(value_, node, 'NbOfTxs')
            self.NbOfTxs = value_
            self.NbOfTxs_nsprefix_ = child_.prefix
            # validate type Max15NumericText
            self.validate_Max15NumericText(self.NbOfTxs)
        elif nodeName_ == 'CtrlSum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'CtrlSum')
            fval_ = self.gds_validate_decimal(fval_, node, 'CtrlSum')
            self.CtrlSum = fval_
            self.CtrlSum_nsprefix_ = child_.prefix
            # validate type DecimalNumber
            self.validate_DecimalNumber(self.CtrlSum)
        elif nodeName_ == 'TtlIntrBkSttlmAmt':
            obj_ = ActiveCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TtlIntrBkSttlmAmt = obj_
            obj_.original_tagname_ = 'TtlIntrBkSttlmAmt'
        elif nodeName_ == 'IntrBkSttlmDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.IntrBkSttlmDt = dval_
            self.IntrBkSttlmDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.IntrBkSttlmDt)
        elif nodeName_ == 'SttlmInf':
            obj_ = SettlementInstruction7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SttlmInf = obj_
            obj_.original_tagname_ = 'SttlmInf'
        elif nodeName_ == 'PmtTpInf':
            obj_ = PaymentTypeInformation28.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PmtTpInf = obj_
            obj_.original_tagname_ = 'PmtTpInf'
        elif nodeName_ == 'InstgAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstgAgt = obj_
            obj_.original_tagname_ = 'InstgAgt'
        elif nodeName_ == 'InstdAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstdAgt = obj_
            obj_.original_tagname_ = 'InstdAgt'
# end class GroupHeader93


class InstructionForCreditorAgent1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['Instruction3Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Cd', 'type': 'xs:string'}, None),
        'InstrInf': MemberSpec_('InstrInf', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstrInf', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, InstrInf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_Instruction3Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.InstrInf = InstrInf
        self.validate_Max140Text(self.InstrInf)
        self.InstrInf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstructionForCreditorAgent1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstructionForCreditorAgent1.subclass:
            return InstructionForCreditorAgent1.subclass(*args_, **kwargs_)
        else:
            return InstructionForCreditorAgent1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_InstrInf(self):
        return self.InstrInf
    def set_InstrInf(self, InstrInf):
        self.InstrInf = InstrInf
    def validate_Instruction3Code(self, value):
        result = True
        # Validate type Instruction3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CHQB', 'HOLD', 'PHOB', 'TELB']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Instruction3Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.InstrInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='InstructionForCreditorAgent1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstructionForCreditorAgent1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InstructionForCreditorAgent1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstructionForCreditorAgent1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InstructionForCreditorAgent1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InstructionForCreditorAgent1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='InstructionForCreditorAgent1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.InstrInf is not None:
            namespaceprefix_ = self.InstrInf_nsprefix_ + ':' if (UseCapturedNS_ and self.InstrInf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrInf>%s</%sInstrInf>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.InstrInf), input_name='InstrInf')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type Instruction3Code
            self.validate_Instruction3Code(self.Cd)
        elif nodeName_ == 'InstrInf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InstrInf')
            value_ = self.gds_validate_string(value_, node, 'InstrInf')
            self.InstrInf = value_
            self.InstrInf_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.InstrInf)
# end class InstructionForCreditorAgent1


class InstructionForNextAgent1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['Instruction4Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Cd', 'type': 'xs:string'}, None),
        'InstrInf': MemberSpec_('InstrInf', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstrInf', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, InstrInf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_Instruction4Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.InstrInf = InstrInf
        self.validate_Max140Text(self.InstrInf)
        self.InstrInf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstructionForNextAgent1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstructionForNextAgent1.subclass:
            return InstructionForNextAgent1.subclass(*args_, **kwargs_)
        else:
            return InstructionForNextAgent1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_InstrInf(self):
        return self.InstrInf
    def set_InstrInf(self, InstrInf):
        self.InstrInf = InstrInf
    def validate_Instruction4Code(self, value):
        result = True
        # Validate type Instruction4Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PHOA', 'TELA']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Instruction4Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.InstrInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='InstructionForNextAgent1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstructionForNextAgent1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InstructionForNextAgent1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstructionForNextAgent1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InstructionForNextAgent1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InstructionForNextAgent1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='InstructionForNextAgent1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.InstrInf is not None:
            namespaceprefix_ = self.InstrInf_nsprefix_ + ':' if (UseCapturedNS_ and self.InstrInf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrInf>%s</%sInstrInf>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.InstrInf), input_name='InstrInf')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type Instruction4Code
            self.validate_Instruction4Code(self.Cd)
        elif nodeName_ == 'InstrInf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InstrInf')
            value_ = self.gds_validate_string(value_, node, 'InstrInf')
            self.InstrInf = value_
            self.InstrInf_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.InstrInf)
# end class InstructionForNextAgent1


class LocalInstrument2Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalLocalInstrument1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 13),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 13),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalLocalInstrument1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalInstrument2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalInstrument2Choice.subclass:
            return LocalInstrument2Choice.subclass(*args_, **kwargs_)
        else:
            return LocalInstrument2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalLocalInstrument1Code(self, value):
        result = True
        # Validate type ExternalLocalInstrument1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalLocalInstrument1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalLocalInstrument1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='LocalInstrument2Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalInstrument2Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocalInstrument2Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalInstrument2Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocalInstrument2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocalInstrument2Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='LocalInstrument2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalLocalInstrument1Code
            self.validate_ExternalLocalInstrument1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class LocalInstrument2Choice


class NameAndAddress16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Nm': MemberSpec_('Nm', ['Max140Text', 'xs:string'], 0, 0, {'name': 'Nm', 'type': 'xs:string'}, None),
        'Adr': MemberSpec_('Adr', 'PostalAddress24', 0, 0, {'name': 'Adr', 'type': 'PostalAddress24'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Nm=None, Adr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Nm_nsprefix_ = None
        self.Adr = Adr
        self.Adr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameAndAddress16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameAndAddress16.subclass:
            return NameAndAddress16.subclass(*args_, **kwargs_)
        else:
            return NameAndAddress16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def get_Adr(self):
        return self.Adr
    def set_Adr(self, Adr):
        self.Adr = Adr
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Nm is not None or
            self.Adr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='NameAndAddress16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameAndAddress16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NameAndAddress16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameAndAddress16')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameAndAddress16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameAndAddress16'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='NameAndAddress16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
        if self.Adr is not None:
            namespaceprefix_ = self.Adr_nsprefix_ + ':' if (UseCapturedNS_ and self.Adr_nsprefix_) else ''
            self.Adr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Adr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'Adr':
            obj_ = PostalAddress24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Adr = obj_
            obj_.original_tagname_ = 'Adr'
# end class NameAndAddress16


class OrganisationIdentification29(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'AnyBIC': MemberSpec_('AnyBIC', ['AnyBICDec2014Identifier', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'AnyBIC', 'type': 'xs:string'}, None),
        'LEI': MemberSpec_('LEI', ['LEIIdentifier', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'LEI', 'type': 'xs:string'}, None),
        'Othr': MemberSpec_('Othr', 'GenericOrganisationIdentification1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Othr', 'type': 'GenericOrganisationIdentification1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, AnyBIC=None, LEI=None, Othr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AnyBIC = AnyBIC
        self.validate_AnyBICDec2014Identifier(self.AnyBIC)
        self.AnyBIC_nsprefix_ = None
        self.LEI = LEI
        self.validate_LEIIdentifier(self.LEI)
        self.LEI_nsprefix_ = None
        if Othr is None:
            self.Othr = []
        else:
            self.Othr = Othr
        self.Othr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationIdentification29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationIdentification29.subclass:
            return OrganisationIdentification29.subclass(*args_, **kwargs_)
        else:
            return OrganisationIdentification29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AnyBIC(self):
        return self.AnyBIC
    def set_AnyBIC(self, AnyBIC):
        self.AnyBIC = AnyBIC
    def get_LEI(self):
        return self.LEI
    def set_LEI(self, LEI):
        self.LEI = LEI
    def get_Othr(self):
        return self.Othr
    def set_Othr(self, Othr):
        self.Othr = Othr
    def add_Othr(self, value):
        self.Othr.append(value)
    def insert_Othr_at(self, index, value):
        self.Othr.insert(index, value)
    def replace_Othr_at(self, index, value):
        self.Othr[index] = value
    def validate_AnyBICDec2014Identifier(self, value):
        result = True
        # Validate type AnyBICDec2014Identifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AnyBICDec2014Identifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AnyBICDec2014Identifier_patterns_, ))
                result = False
        return result
    validate_AnyBICDec2014Identifier_patterns_ = [['^([A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1})$']]
    def validate_LEIIdentifier(self, value):
        result = True
        # Validate type LEIIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_LEIIdentifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LEIIdentifier_patterns_, ))
                result = False
        return result
    validate_LEIIdentifier_patterns_ = [['^([A-Z0-9]{18,18}[0-9]{2,2})$']]
    def has__content(self):
        if (
            self.AnyBIC is not None or
            self.LEI is not None or
            self.Othr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='OrganisationIdentification29', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationIdentification29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganisationIdentification29':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganisationIdentification29')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganisationIdentification29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrganisationIdentification29'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='OrganisationIdentification29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AnyBIC is not None:
            namespaceprefix_ = self.AnyBIC_nsprefix_ + ':' if (UseCapturedNS_ and self.AnyBIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnyBIC>%s</%sAnyBIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AnyBIC), input_name='AnyBIC')), namespaceprefix_ , eol_))
        if self.LEI is not None:
            namespaceprefix_ = self.LEI_nsprefix_ + ':' if (UseCapturedNS_ and self.LEI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLEI>%s</%sLEI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LEI), input_name='LEI')), namespaceprefix_ , eol_))
        for Othr_ in self.Othr:
            namespaceprefix_ = self.Othr_nsprefix_ + ':' if (UseCapturedNS_ and self.Othr_nsprefix_) else ''
            Othr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Othr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AnyBIC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AnyBIC')
            value_ = self.gds_validate_string(value_, node, 'AnyBIC')
            self.AnyBIC = value_
            self.AnyBIC_nsprefix_ = child_.prefix
            # validate type AnyBICDec2014Identifier
            self.validate_AnyBICDec2014Identifier(self.AnyBIC)
        elif nodeName_ == 'LEI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LEI')
            value_ = self.gds_validate_string(value_, node, 'LEI')
            self.LEI = value_
            self.LEI_nsprefix_ = child_.prefix
            # validate type LEIIdentifier
            self.validate_LEIIdentifier(self.LEI)
        elif nodeName_ == 'Othr':
            obj_ = GenericOrganisationIdentification1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Othr.append(obj_)
            obj_.original_tagname_ = 'Othr'
# end class OrganisationIdentification29


class OrganisationIdentificationSchemeName1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalOrganisationIdentification1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 14),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 14),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalOrganisationIdentification1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationIdentificationSchemeName1Choice.subclass:
            return OrganisationIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return OrganisationIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalOrganisationIdentification1Code(self, value):
        result = True
        # Validate type ExternalOrganisationIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalOrganisationIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalOrganisationIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='OrganisationIdentificationSchemeName1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationIdentificationSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganisationIdentificationSchemeName1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganisationIdentificationSchemeName1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganisationIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrganisationIdentificationSchemeName1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='OrganisationIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalOrganisationIdentification1Code
            self.validate_ExternalOrganisationIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class OrganisationIdentificationSchemeName1Choice


class OtherContact1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'ChanlTp': MemberSpec_('ChanlTp', ['Max4Text', 'xs:string'], 0, 0, {'name': 'ChanlTp', 'type': 'xs:string'}, None),
        'Id': MemberSpec_('Id', ['Max128Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Id', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ChanlTp=None, Id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ChanlTp = ChanlTp
        self.validate_Max4Text(self.ChanlTp)
        self.ChanlTp_nsprefix_ = None
        self.Id = Id
        self.validate_Max128Text(self.Id)
        self.Id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherContact1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherContact1.subclass:
            return OtherContact1.subclass(*args_, **kwargs_)
        else:
            return OtherContact1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ChanlTp(self):
        return self.ChanlTp
    def set_ChanlTp(self, ChanlTp):
        self.ChanlTp = ChanlTp
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_Max4Text(self, value):
        result = True
        # Validate type Max4Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max4Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max4Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max128Text(self, value):
        result = True
        # Validate type Max128Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 128:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max128Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max128Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ChanlTp is not None or
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='OtherContact1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtherContact1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OtherContact1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtherContact1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OtherContact1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OtherContact1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='OtherContact1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChanlTp is not None:
            namespaceprefix_ = self.ChanlTp_nsprefix_ + ':' if (UseCapturedNS_ and self.ChanlTp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChanlTp>%s</%sChanlTp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ChanlTp), input_name='ChanlTp')), namespaceprefix_ , eol_))
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ChanlTp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ChanlTp')
            value_ = self.gds_validate_string(value_, node, 'ChanlTp')
            self.ChanlTp = value_
            self.ChanlTp_nsprefix_ = child_.prefix
            # validate type Max4Text
            self.validate_Max4Text(self.ChanlTp)
        elif nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Max128Text
            self.validate_Max128Text(self.Id)
# end class OtherContact1


class Party38Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'OrgId': MemberSpec_('OrgId', 'OrganisationIdentification29', 0, 0, {'name': 'OrgId', 'type': 'OrganisationIdentification29'}, 15),
        'PrvtId': MemberSpec_('PrvtId', 'PersonIdentification13', 0, 0, {'name': 'PrvtId', 'type': 'PersonIdentification13'}, 15),
    }
    subclass = None
    superclass = None
    def __init__(self, OrgId=None, PrvtId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OrgId = OrgId
        self.OrgId_nsprefix_ = None
        self.PrvtId = PrvtId
        self.PrvtId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party38Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party38Choice.subclass:
            return Party38Choice.subclass(*args_, **kwargs_)
        else:
            return Party38Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OrgId(self):
        return self.OrgId
    def set_OrgId(self, OrgId):
        self.OrgId = OrgId
    def get_PrvtId(self):
        return self.PrvtId
    def set_PrvtId(self, PrvtId):
        self.PrvtId = PrvtId
    def has__content(self):
        if (
            self.OrgId is not None or
            self.PrvtId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Party38Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Party38Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Party38Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Party38Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Party38Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Party38Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Party38Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrgId is not None:
            namespaceprefix_ = self.OrgId_nsprefix_ + ':' if (UseCapturedNS_ and self.OrgId_nsprefix_) else ''
            self.OrgId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OrgId', pretty_print=pretty_print)
        if self.PrvtId is not None:
            namespaceprefix_ = self.PrvtId_nsprefix_ + ':' if (UseCapturedNS_ and self.PrvtId_nsprefix_) else ''
            self.PrvtId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrvtId', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OrgId':
            obj_ = OrganisationIdentification29.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OrgId = obj_
            obj_.original_tagname_ = 'OrgId'
        elif nodeName_ == 'PrvtId':
            obj_ = PersonIdentification13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrvtId = obj_
            obj_.original_tagname_ = 'PrvtId'
# end class Party38Choice


class PartyIdentification135(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Nm': MemberSpec_('Nm', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nm', 'type': 'xs:string'}, None),
        'PstlAdr': MemberSpec_('PstlAdr', 'PostalAddress24', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PstlAdr', 'type': 'PostalAddress24'}, None),
        'Id': MemberSpec_('Id', 'Party38Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Id', 'type': 'Party38Choice'}, None),
        'CtryOfRes': MemberSpec_('CtryOfRes', ['CountryCode', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CtryOfRes', 'type': 'xs:string'}, None),
        'CtctDtls': MemberSpec_('CtctDtls', 'Contact4', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CtctDtls', 'type': 'Contact4'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Nm=None, PstlAdr=None, Id=None, CtryOfRes=None, CtctDtls=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Nm_nsprefix_ = None
        self.PstlAdr = PstlAdr
        self.PstlAdr_nsprefix_ = None
        self.Id = Id
        self.Id_nsprefix_ = None
        self.CtryOfRes = CtryOfRes
        self.validate_CountryCode(self.CtryOfRes)
        self.CtryOfRes_nsprefix_ = None
        self.CtctDtls = CtctDtls
        self.CtctDtls_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyIdentification135)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyIdentification135.subclass:
            return PartyIdentification135.subclass(*args_, **kwargs_)
        else:
            return PartyIdentification135(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def get_PstlAdr(self):
        return self.PstlAdr
    def set_PstlAdr(self, PstlAdr):
        self.PstlAdr = PstlAdr
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_CtryOfRes(self):
        return self.CtryOfRes
    def set_CtryOfRes(self, CtryOfRes):
        self.CtryOfRes = CtryOfRes
    def get_CtctDtls(self):
        return self.CtctDtls
    def set_CtctDtls(self, CtctDtls):
        self.CtctDtls = CtctDtls
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CountryCode(self, value):
        result = True
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCode_patterns_, ))
                result = False
        return result
    validate_CountryCode_patterns_ = [['^([A-Z]{2,2})$']]
    def has__content(self):
        if (
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Id is not None or
            self.CtryOfRes is not None or
            self.CtctDtls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PartyIdentification135', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartyIdentification135')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PartyIdentification135':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PartyIdentification135')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PartyIdentification135', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PartyIdentification135'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PartyIdentification135', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
        if self.PstlAdr is not None:
            namespaceprefix_ = self.PstlAdr_nsprefix_ + ':' if (UseCapturedNS_ and self.PstlAdr_nsprefix_) else ''
            self.PstlAdr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PstlAdr', pretty_print=pretty_print)
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.CtryOfRes is not None:
            namespaceprefix_ = self.CtryOfRes_nsprefix_ + ':' if (UseCapturedNS_ and self.CtryOfRes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtryOfRes>%s</%sCtryOfRes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CtryOfRes), input_name='CtryOfRes')), namespaceprefix_ , eol_))
        if self.CtctDtls is not None:
            namespaceprefix_ = self.CtctDtls_nsprefix_ + ':' if (UseCapturedNS_ and self.CtctDtls_nsprefix_) else ''
            self.CtctDtls.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CtctDtls', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Id':
            obj_ = Party38Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'CtryOfRes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CtryOfRes')
            value_ = self.gds_validate_string(value_, node, 'CtryOfRes')
            self.CtryOfRes = value_
            self.CtryOfRes_nsprefix_ = child_.prefix
            # validate type CountryCode
            self.validate_CountryCode(self.CtryOfRes)
        elif nodeName_ == 'CtctDtls':
            obj_ = Contact4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CtctDtls = obj_
            obj_.original_tagname_ = 'CtctDtls'
# end class PartyIdentification135


class PaymentIdentification7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'InstrId': MemberSpec_('InstrId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstrId', 'type': 'xs:string'}, None),
        'EndToEndId': MemberSpec_('EndToEndId', ['Max35Text', 'xs:string'], 0, 0, {'name': 'EndToEndId', 'type': 'xs:string'}, None),
        'TxId': MemberSpec_('TxId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TxId', 'type': 'xs:string'}, None),
        'UETR': MemberSpec_('UETR', ['UUIDv4Identifier', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'UETR', 'type': 'xs:string'}, None),
        'ClrSysRef': MemberSpec_('ClrSysRef', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ClrSysRef', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, InstrId=None, EndToEndId=None, TxId=None, UETR=None, ClrSysRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.InstrId = InstrId
        self.validate_Max35Text(self.InstrId)
        self.InstrId_nsprefix_ = None
        self.EndToEndId = EndToEndId
        self.validate_Max35Text(self.EndToEndId)
        self.EndToEndId_nsprefix_ = None
        self.TxId = TxId
        self.validate_Max35Text(self.TxId)
        self.TxId_nsprefix_ = None
        self.UETR = UETR
        self.validate_UUIDv4Identifier(self.UETR)
        self.UETR_nsprefix_ = None
        self.ClrSysRef = ClrSysRef
        self.validate_Max35Text(self.ClrSysRef)
        self.ClrSysRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentIdentification7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentIdentification7.subclass:
            return PaymentIdentification7.subclass(*args_, **kwargs_)
        else:
            return PaymentIdentification7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_InstrId(self):
        return self.InstrId
    def set_InstrId(self, InstrId):
        self.InstrId = InstrId
    def get_EndToEndId(self):
        return self.EndToEndId
    def set_EndToEndId(self, EndToEndId):
        self.EndToEndId = EndToEndId
    def get_TxId(self):
        return self.TxId
    def set_TxId(self, TxId):
        self.TxId = TxId
    def get_UETR(self):
        return self.UETR
    def set_UETR(self, UETR):
        self.UETR = UETR
    def get_ClrSysRef(self):
        return self.ClrSysRef
    def set_ClrSysRef(self, ClrSysRef):
        self.ClrSysRef = ClrSysRef
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UUIDv4Identifier(self, value):
        result = True
        # Validate type UUIDv4Identifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_UUIDv4Identifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_UUIDv4Identifier_patterns_, ))
                result = False
        return result
    validate_UUIDv4Identifier_patterns_ = [['^([a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12})$']]
    def has__content(self):
        if (
            self.InstrId is not None or
            self.EndToEndId is not None or
            self.TxId is not None or
            self.UETR is not None or
            self.ClrSysRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PaymentIdentification7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentIdentification7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PaymentIdentification7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaymentIdentification7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PaymentIdentification7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PaymentIdentification7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PaymentIdentification7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstrId is not None:
            namespaceprefix_ = self.InstrId_nsprefix_ + ':' if (UseCapturedNS_ and self.InstrId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrId>%s</%sInstrId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.InstrId), input_name='InstrId')), namespaceprefix_ , eol_))
        if self.EndToEndId is not None:
            namespaceprefix_ = self.EndToEndId_nsprefix_ + ':' if (UseCapturedNS_ and self.EndToEndId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndToEndId>%s</%sEndToEndId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EndToEndId), input_name='EndToEndId')), namespaceprefix_ , eol_))
        if self.TxId is not None:
            namespaceprefix_ = self.TxId_nsprefix_ + ':' if (UseCapturedNS_ and self.TxId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTxId>%s</%sTxId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TxId), input_name='TxId')), namespaceprefix_ , eol_))
        if self.UETR is not None:
            namespaceprefix_ = self.UETR_nsprefix_ + ':' if (UseCapturedNS_ and self.UETR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUETR>%s</%sUETR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UETR), input_name='UETR')), namespaceprefix_ , eol_))
        if self.ClrSysRef is not None:
            namespaceprefix_ = self.ClrSysRef_nsprefix_ + ':' if (UseCapturedNS_ and self.ClrSysRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClrSysRef>%s</%sClrSysRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ClrSysRef), input_name='ClrSysRef')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InstrId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InstrId')
            value_ = self.gds_validate_string(value_, node, 'InstrId')
            self.InstrId = value_
            self.InstrId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.InstrId)
        elif nodeName_ == 'EndToEndId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EndToEndId')
            value_ = self.gds_validate_string(value_, node, 'EndToEndId')
            self.EndToEndId = value_
            self.EndToEndId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.EndToEndId)
        elif nodeName_ == 'TxId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TxId')
            value_ = self.gds_validate_string(value_, node, 'TxId')
            self.TxId = value_
            self.TxId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.TxId)
        elif nodeName_ == 'UETR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UETR')
            value_ = self.gds_validate_string(value_, node, 'UETR')
            self.UETR = value_
            self.UETR_nsprefix_ = child_.prefix
            # validate type UUIDv4Identifier
            self.validate_UUIDv4Identifier(self.UETR)
        elif nodeName_ == 'ClrSysRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ClrSysRef')
            value_ = self.gds_validate_string(value_, node, 'ClrSysRef')
            self.ClrSysRef = value_
            self.ClrSysRef_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.ClrSysRef)
# end class PaymentIdentification7


class PaymentTypeInformation28(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'InstrPrty': MemberSpec_('InstrPrty', ['Priority2Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstrPrty', 'type': 'xs:string'}, None),
        'ClrChanl': MemberSpec_('ClrChanl', ['ClearingChannel2Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ClrChanl', 'type': 'xs:string'}, None),
        'SvcLvl': MemberSpec_('SvcLvl', 'ServiceLevel8Choice', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'SvcLvl', 'type': 'ServiceLevel8Choice'}, None),
        'LclInstrm': MemberSpec_('LclInstrm', 'LocalInstrument2Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'LclInstrm', 'type': 'LocalInstrument2Choice'}, None),
        'CtgyPurp': MemberSpec_('CtgyPurp', 'CategoryPurpose1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CtgyPurp', 'type': 'CategoryPurpose1Choice'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, InstrPrty=None, ClrChanl=None, SvcLvl=None, LclInstrm=None, CtgyPurp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.InstrPrty = InstrPrty
        self.validate_Priority2Code(self.InstrPrty)
        self.InstrPrty_nsprefix_ = None
        self.ClrChanl = ClrChanl
        self.validate_ClearingChannel2Code(self.ClrChanl)
        self.ClrChanl_nsprefix_ = None
        if SvcLvl is None:
            self.SvcLvl = []
        else:
            self.SvcLvl = SvcLvl
        self.SvcLvl_nsprefix_ = None
        self.LclInstrm = LclInstrm
        self.LclInstrm_nsprefix_ = None
        self.CtgyPurp = CtgyPurp
        self.CtgyPurp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentTypeInformation28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentTypeInformation28.subclass:
            return PaymentTypeInformation28.subclass(*args_, **kwargs_)
        else:
            return PaymentTypeInformation28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_InstrPrty(self):
        return self.InstrPrty
    def set_InstrPrty(self, InstrPrty):
        self.InstrPrty = InstrPrty
    def get_ClrChanl(self):
        return self.ClrChanl
    def set_ClrChanl(self, ClrChanl):
        self.ClrChanl = ClrChanl
    def get_SvcLvl(self):
        return self.SvcLvl
    def set_SvcLvl(self, SvcLvl):
        self.SvcLvl = SvcLvl
    def add_SvcLvl(self, value):
        self.SvcLvl.append(value)
    def insert_SvcLvl_at(self, index, value):
        self.SvcLvl.insert(index, value)
    def replace_SvcLvl_at(self, index, value):
        self.SvcLvl[index] = value
    def get_LclInstrm(self):
        return self.LclInstrm
    def set_LclInstrm(self, LclInstrm):
        self.LclInstrm = LclInstrm
    def get_CtgyPurp(self):
        return self.CtgyPurp
    def set_CtgyPurp(self, CtgyPurp):
        self.CtgyPurp = CtgyPurp
    def validate_Priority2Code(self, value):
        result = True
        # Validate type Priority2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HIGH', 'NORM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Priority2Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ClearingChannel2Code(self, value):
        result = True
        # Validate type ClearingChannel2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RTGS', 'RTNS', 'MPNS', 'BOOK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ClearingChannel2Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.InstrPrty is not None or
            self.ClrChanl is not None or
            self.SvcLvl or
            self.LclInstrm is not None or
            self.CtgyPurp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PaymentTypeInformation28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentTypeInformation28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PaymentTypeInformation28':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaymentTypeInformation28')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PaymentTypeInformation28', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PaymentTypeInformation28'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PaymentTypeInformation28', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstrPrty is not None:
            namespaceprefix_ = self.InstrPrty_nsprefix_ + ':' if (UseCapturedNS_ and self.InstrPrty_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrPrty>%s</%sInstrPrty>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.InstrPrty), input_name='InstrPrty')), namespaceprefix_ , eol_))
        if self.ClrChanl is not None:
            namespaceprefix_ = self.ClrChanl_nsprefix_ + ':' if (UseCapturedNS_ and self.ClrChanl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClrChanl>%s</%sClrChanl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ClrChanl), input_name='ClrChanl')), namespaceprefix_ , eol_))
        for SvcLvl_ in self.SvcLvl:
            namespaceprefix_ = self.SvcLvl_nsprefix_ + ':' if (UseCapturedNS_ and self.SvcLvl_nsprefix_) else ''
            SvcLvl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SvcLvl', pretty_print=pretty_print)
        if self.LclInstrm is not None:
            namespaceprefix_ = self.LclInstrm_nsprefix_ + ':' if (UseCapturedNS_ and self.LclInstrm_nsprefix_) else ''
            self.LclInstrm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LclInstrm', pretty_print=pretty_print)
        if self.CtgyPurp is not None:
            namespaceprefix_ = self.CtgyPurp_nsprefix_ + ':' if (UseCapturedNS_ and self.CtgyPurp_nsprefix_) else ''
            self.CtgyPurp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CtgyPurp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InstrPrty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InstrPrty')
            value_ = self.gds_validate_string(value_, node, 'InstrPrty')
            self.InstrPrty = value_
            self.InstrPrty_nsprefix_ = child_.prefix
            # validate type Priority2Code
            self.validate_Priority2Code(self.InstrPrty)
        elif nodeName_ == 'ClrChanl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ClrChanl')
            value_ = self.gds_validate_string(value_, node, 'ClrChanl')
            self.ClrChanl = value_
            self.ClrChanl_nsprefix_ = child_.prefix
            # validate type ClearingChannel2Code
            self.validate_ClearingChannel2Code(self.ClrChanl)
        elif nodeName_ == 'SvcLvl':
            obj_ = ServiceLevel8Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SvcLvl.append(obj_)
            obj_.original_tagname_ = 'SvcLvl'
        elif nodeName_ == 'LclInstrm':
            obj_ = LocalInstrument2Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LclInstrm = obj_
            obj_.original_tagname_ = 'LclInstrm'
        elif nodeName_ == 'CtgyPurp':
            obj_ = CategoryPurpose1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CtgyPurp = obj_
            obj_.original_tagname_ = 'CtgyPurp'
# end class PaymentTypeInformation28


class PersonIdentification13(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'DtAndPlcOfBirth': MemberSpec_('DtAndPlcOfBirth', 'DateAndPlaceOfBirth1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DtAndPlcOfBirth', 'type': 'DateAndPlaceOfBirth1'}, None),
        'Othr': MemberSpec_('Othr', 'GenericPersonIdentification1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Othr', 'type': 'GenericPersonIdentification1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, DtAndPlcOfBirth=None, Othr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DtAndPlcOfBirth = DtAndPlcOfBirth
        self.DtAndPlcOfBirth_nsprefix_ = None
        if Othr is None:
            self.Othr = []
        else:
            self.Othr = Othr
        self.Othr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonIdentification13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonIdentification13.subclass:
            return PersonIdentification13.subclass(*args_, **kwargs_)
        else:
            return PersonIdentification13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DtAndPlcOfBirth(self):
        return self.DtAndPlcOfBirth
    def set_DtAndPlcOfBirth(self, DtAndPlcOfBirth):
        self.DtAndPlcOfBirth = DtAndPlcOfBirth
    def get_Othr(self):
        return self.Othr
    def set_Othr(self, Othr):
        self.Othr = Othr
    def add_Othr(self, value):
        self.Othr.append(value)
    def insert_Othr_at(self, index, value):
        self.Othr.insert(index, value)
    def replace_Othr_at(self, index, value):
        self.Othr[index] = value
    def has__content(self):
        if (
            self.DtAndPlcOfBirth is not None or
            self.Othr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PersonIdentification13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonIdentification13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonIdentification13':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonIdentification13')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonIdentification13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonIdentification13'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PersonIdentification13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DtAndPlcOfBirth is not None:
            namespaceprefix_ = self.DtAndPlcOfBirth_nsprefix_ + ':' if (UseCapturedNS_ and self.DtAndPlcOfBirth_nsprefix_) else ''
            self.DtAndPlcOfBirth.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DtAndPlcOfBirth', pretty_print=pretty_print)
        for Othr_ in self.Othr:
            namespaceprefix_ = self.Othr_nsprefix_ + ':' if (UseCapturedNS_ and self.Othr_nsprefix_) else ''
            Othr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Othr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DtAndPlcOfBirth':
            obj_ = DateAndPlaceOfBirth1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DtAndPlcOfBirth = obj_
            obj_.original_tagname_ = 'DtAndPlcOfBirth'
        elif nodeName_ == 'Othr':
            obj_ = GenericPersonIdentification1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Othr.append(obj_)
            obj_.original_tagname_ = 'Othr'
# end class PersonIdentification13


class PersonIdentificationSchemeName1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalPersonIdentification1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 16),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 16),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalPersonIdentification1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonIdentificationSchemeName1Choice.subclass:
            return PersonIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return PersonIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalPersonIdentification1Code(self, value):
        result = True
        # Validate type ExternalPersonIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalPersonIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalPersonIdentification1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PersonIdentificationSchemeName1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonIdentificationSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonIdentificationSchemeName1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonIdentificationSchemeName1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonIdentificationSchemeName1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PersonIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalPersonIdentification1Code
            self.validate_ExternalPersonIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class PersonIdentificationSchemeName1Choice


class PostalAddress24(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'AdrTp': MemberSpec_('AdrTp', 'AddressType3Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'AdrTp', 'type': 'AddressType3Choice'}, None),
        'Dept': MemberSpec_('Dept', ['Max70Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dept', 'type': 'xs:string'}, None),
        'SubDept': MemberSpec_('SubDept', ['Max70Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SubDept', 'type': 'xs:string'}, None),
        'StrtNm': MemberSpec_('StrtNm', ['Max70Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'StrtNm', 'type': 'xs:string'}, None),
        'BldgNb': MemberSpec_('BldgNb', ['Max16Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'BldgNb', 'type': 'xs:string'}, None),
        'BldgNm': MemberSpec_('BldgNm', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'BldgNm', 'type': 'xs:string'}, None),
        'Flr': MemberSpec_('Flr', ['Max70Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Flr', 'type': 'xs:string'}, None),
        'PstBx': MemberSpec_('PstBx', ['Max16Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PstBx', 'type': 'xs:string'}, None),
        'Room': MemberSpec_('Room', ['Max70Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Room', 'type': 'xs:string'}, None),
        'PstCd': MemberSpec_('PstCd', ['Max16Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PstCd', 'type': 'xs:string'}, None),
        'TwnNm': MemberSpec_('TwnNm', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TwnNm', 'type': 'xs:string'}, None),
        'TwnLctnNm': MemberSpec_('TwnLctnNm', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TwnLctnNm', 'type': 'xs:string'}, None),
        'DstrctNm': MemberSpec_('DstrctNm', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DstrctNm', 'type': 'xs:string'}, None),
        'CtrySubDvsn': MemberSpec_('CtrySubDvsn', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CtrySubDvsn', 'type': 'xs:string'}, None),
        'Ctry': MemberSpec_('Ctry', ['CountryCode', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Ctry', 'type': 'xs:string'}, None),
        'AdrLine': MemberSpec_('AdrLine', ['Max70Text', 'xs:string'], 1, 1, {'maxOccurs': '7', 'minOccurs': '0', 'name': 'AdrLine', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, AdrTp=None, Dept=None, SubDept=None, StrtNm=None, BldgNb=None, BldgNm=None, Flr=None, PstBx=None, Room=None, PstCd=None, TwnNm=None, TwnLctnNm=None, DstrctNm=None, CtrySubDvsn=None, Ctry=None, AdrLine=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AdrTp = AdrTp
        self.AdrTp_nsprefix_ = None
        self.Dept = Dept
        self.validate_Max70Text(self.Dept)
        self.Dept_nsprefix_ = None
        self.SubDept = SubDept
        self.validate_Max70Text(self.SubDept)
        self.SubDept_nsprefix_ = None
        self.StrtNm = StrtNm
        self.validate_Max70Text(self.StrtNm)
        self.StrtNm_nsprefix_ = None
        self.BldgNb = BldgNb
        self.validate_Max16Text(self.BldgNb)
        self.BldgNb_nsprefix_ = None
        self.BldgNm = BldgNm
        self.validate_Max35Text(self.BldgNm)
        self.BldgNm_nsprefix_ = None
        self.Flr = Flr
        self.validate_Max70Text(self.Flr)
        self.Flr_nsprefix_ = None
        self.PstBx = PstBx
        self.validate_Max16Text(self.PstBx)
        self.PstBx_nsprefix_ = None
        self.Room = Room
        self.validate_Max70Text(self.Room)
        self.Room_nsprefix_ = None
        self.PstCd = PstCd
        self.validate_Max16Text(self.PstCd)
        self.PstCd_nsprefix_ = None
        self.TwnNm = TwnNm
        self.validate_Max35Text(self.TwnNm)
        self.TwnNm_nsprefix_ = None
        self.TwnLctnNm = TwnLctnNm
        self.validate_Max35Text(self.TwnLctnNm)
        self.TwnLctnNm_nsprefix_ = None
        self.DstrctNm = DstrctNm
        self.validate_Max35Text(self.DstrctNm)
        self.DstrctNm_nsprefix_ = None
        self.CtrySubDvsn = CtrySubDvsn
        self.validate_Max35Text(self.CtrySubDvsn)
        self.CtrySubDvsn_nsprefix_ = None
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        self.Ctry_nsprefix_ = None
        if AdrLine is None:
            self.AdrLine = []
        else:
            self.AdrLine = AdrLine
        self.AdrLine_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PostalAddress24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PostalAddress24.subclass:
            return PostalAddress24.subclass(*args_, **kwargs_)
        else:
            return PostalAddress24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AdrTp(self):
        return self.AdrTp
    def set_AdrTp(self, AdrTp):
        self.AdrTp = AdrTp
    def get_Dept(self):
        return self.Dept
    def set_Dept(self, Dept):
        self.Dept = Dept
    def get_SubDept(self):
        return self.SubDept
    def set_SubDept(self, SubDept):
        self.SubDept = SubDept
    def get_StrtNm(self):
        return self.StrtNm
    def set_StrtNm(self, StrtNm):
        self.StrtNm = StrtNm
    def get_BldgNb(self):
        return self.BldgNb
    def set_BldgNb(self, BldgNb):
        self.BldgNb = BldgNb
    def get_BldgNm(self):
        return self.BldgNm
    def set_BldgNm(self, BldgNm):
        self.BldgNm = BldgNm
    def get_Flr(self):
        return self.Flr
    def set_Flr(self, Flr):
        self.Flr = Flr
    def get_PstBx(self):
        return self.PstBx
    def set_PstBx(self, PstBx):
        self.PstBx = PstBx
    def get_Room(self):
        return self.Room
    def set_Room(self, Room):
        self.Room = Room
    def get_PstCd(self):
        return self.PstCd
    def set_PstCd(self, PstCd):
        self.PstCd = PstCd
    def get_TwnNm(self):
        return self.TwnNm
    def set_TwnNm(self, TwnNm):
        self.TwnNm = TwnNm
    def get_TwnLctnNm(self):
        return self.TwnLctnNm
    def set_TwnLctnNm(self, TwnLctnNm):
        self.TwnLctnNm = TwnLctnNm
    def get_DstrctNm(self):
        return self.DstrctNm
    def set_DstrctNm(self, DstrctNm):
        self.DstrctNm = DstrctNm
    def get_CtrySubDvsn(self):
        return self.CtrySubDvsn
    def set_CtrySubDvsn(self, CtrySubDvsn):
        self.CtrySubDvsn = CtrySubDvsn
    def get_Ctry(self):
        return self.Ctry
    def set_Ctry(self, Ctry):
        self.Ctry = Ctry
    def get_AdrLine(self):
        return self.AdrLine
    def set_AdrLine(self, AdrLine):
        self.AdrLine = AdrLine
    def add_AdrLine(self, value):
        self.AdrLine.append(value)
    def insert_AdrLine_at(self, index, value):
        self.AdrLine.insert(index, value)
    def replace_AdrLine_at(self, index, value):
        self.AdrLine[index] = value
    def validate_Max70Text(self, value):
        result = True
        # Validate type Max70Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max70Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max70Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max16Text(self, value):
        result = True
        # Validate type Max16Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max16Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max16Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CountryCode(self, value):
        result = True
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCode_patterns_, ))
                result = False
        return result
    validate_CountryCode_patterns_ = [['^([A-Z]{2,2})$']]
    def has__content(self):
        if (
            self.AdrTp is not None or
            self.Dept is not None or
            self.SubDept is not None or
            self.StrtNm is not None or
            self.BldgNb is not None or
            self.BldgNm is not None or
            self.Flr is not None or
            self.PstBx is not None or
            self.Room is not None or
            self.PstCd is not None or
            self.TwnNm is not None or
            self.TwnLctnNm is not None or
            self.DstrctNm is not None or
            self.CtrySubDvsn is not None or
            self.Ctry is not None or
            self.AdrLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PostalAddress24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PostalAddress24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PostalAddress24':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PostalAddress24')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PostalAddress24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PostalAddress24'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='PostalAddress24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdrTp is not None:
            namespaceprefix_ = self.AdrTp_nsprefix_ + ':' if (UseCapturedNS_ and self.AdrTp_nsprefix_) else ''
            self.AdrTp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AdrTp', pretty_print=pretty_print)
        if self.Dept is not None:
            namespaceprefix_ = self.Dept_nsprefix_ + ':' if (UseCapturedNS_ and self.Dept_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDept>%s</%sDept>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Dept), input_name='Dept')), namespaceprefix_ , eol_))
        if self.SubDept is not None:
            namespaceprefix_ = self.SubDept_nsprefix_ + ':' if (UseCapturedNS_ and self.SubDept_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubDept>%s</%sSubDept>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubDept), input_name='SubDept')), namespaceprefix_ , eol_))
        if self.StrtNm is not None:
            namespaceprefix_ = self.StrtNm_nsprefix_ + ':' if (UseCapturedNS_ and self.StrtNm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStrtNm>%s</%sStrtNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.StrtNm), input_name='StrtNm')), namespaceprefix_ , eol_))
        if self.BldgNb is not None:
            namespaceprefix_ = self.BldgNb_nsprefix_ + ':' if (UseCapturedNS_ and self.BldgNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBldgNb>%s</%sBldgNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BldgNb), input_name='BldgNb')), namespaceprefix_ , eol_))
        if self.BldgNm is not None:
            namespaceprefix_ = self.BldgNm_nsprefix_ + ':' if (UseCapturedNS_ and self.BldgNm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBldgNm>%s</%sBldgNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BldgNm), input_name='BldgNm')), namespaceprefix_ , eol_))
        if self.Flr is not None:
            namespaceprefix_ = self.Flr_nsprefix_ + ':' if (UseCapturedNS_ and self.Flr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFlr>%s</%sFlr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Flr), input_name='Flr')), namespaceprefix_ , eol_))
        if self.PstBx is not None:
            namespaceprefix_ = self.PstBx_nsprefix_ + ':' if (UseCapturedNS_ and self.PstBx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPstBx>%s</%sPstBx>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PstBx), input_name='PstBx')), namespaceprefix_ , eol_))
        if self.Room is not None:
            namespaceprefix_ = self.Room_nsprefix_ + ':' if (UseCapturedNS_ and self.Room_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoom>%s</%sRoom>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Room), input_name='Room')), namespaceprefix_ , eol_))
        if self.PstCd is not None:
            namespaceprefix_ = self.PstCd_nsprefix_ + ':' if (UseCapturedNS_ and self.PstCd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPstCd>%s</%sPstCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PstCd), input_name='PstCd')), namespaceprefix_ , eol_))
        if self.TwnNm is not None:
            namespaceprefix_ = self.TwnNm_nsprefix_ + ':' if (UseCapturedNS_ and self.TwnNm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTwnNm>%s</%sTwnNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TwnNm), input_name='TwnNm')), namespaceprefix_ , eol_))
        if self.TwnLctnNm is not None:
            namespaceprefix_ = self.TwnLctnNm_nsprefix_ + ':' if (UseCapturedNS_ and self.TwnLctnNm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTwnLctnNm>%s</%sTwnLctnNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TwnLctnNm), input_name='TwnLctnNm')), namespaceprefix_ , eol_))
        if self.DstrctNm is not None:
            namespaceprefix_ = self.DstrctNm_nsprefix_ + ':' if (UseCapturedNS_ and self.DstrctNm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDstrctNm>%s</%sDstrctNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DstrctNm), input_name='DstrctNm')), namespaceprefix_ , eol_))
        if self.CtrySubDvsn is not None:
            namespaceprefix_ = self.CtrySubDvsn_nsprefix_ + ':' if (UseCapturedNS_ and self.CtrySubDvsn_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrySubDvsn>%s</%sCtrySubDvsn>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CtrySubDvsn), input_name='CtrySubDvsn')), namespaceprefix_ , eol_))
        if self.Ctry is not None:
            namespaceprefix_ = self.Ctry_nsprefix_ + ':' if (UseCapturedNS_ and self.Ctry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespaceprefix_ , eol_))
        for AdrLine_ in self.AdrLine:
            namespaceprefix_ = self.AdrLine_nsprefix_ + ':' if (UseCapturedNS_ and self.AdrLine_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdrLine>%s</%sAdrLine>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(AdrLine_), input_name='AdrLine')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AdrTp':
            obj_ = AddressType3Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdrTp = obj_
            obj_.original_tagname_ = 'AdrTp'
        elif nodeName_ == 'Dept':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Dept')
            value_ = self.gds_validate_string(value_, node, 'Dept')
            self.Dept = value_
            self.Dept_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.Dept)
        elif nodeName_ == 'SubDept':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubDept')
            value_ = self.gds_validate_string(value_, node, 'SubDept')
            self.SubDept = value_
            self.SubDept_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.SubDept)
        elif nodeName_ == 'StrtNm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'StrtNm')
            value_ = self.gds_validate_string(value_, node, 'StrtNm')
            self.StrtNm = value_
            self.StrtNm_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.StrtNm)
        elif nodeName_ == 'BldgNb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BldgNb')
            value_ = self.gds_validate_string(value_, node, 'BldgNb')
            self.BldgNb = value_
            self.BldgNb_nsprefix_ = child_.prefix
            # validate type Max16Text
            self.validate_Max16Text(self.BldgNb)
        elif nodeName_ == 'BldgNm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BldgNm')
            value_ = self.gds_validate_string(value_, node, 'BldgNm')
            self.BldgNm = value_
            self.BldgNm_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.BldgNm)
        elif nodeName_ == 'Flr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Flr')
            value_ = self.gds_validate_string(value_, node, 'Flr')
            self.Flr = value_
            self.Flr_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.Flr)
        elif nodeName_ == 'PstBx':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PstBx')
            value_ = self.gds_validate_string(value_, node, 'PstBx')
            self.PstBx = value_
            self.PstBx_nsprefix_ = child_.prefix
            # validate type Max16Text
            self.validate_Max16Text(self.PstBx)
        elif nodeName_ == 'Room':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Room')
            value_ = self.gds_validate_string(value_, node, 'Room')
            self.Room = value_
            self.Room_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.Room)
        elif nodeName_ == 'PstCd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PstCd')
            value_ = self.gds_validate_string(value_, node, 'PstCd')
            self.PstCd = value_
            self.PstCd_nsprefix_ = child_.prefix
            # validate type Max16Text
            self.validate_Max16Text(self.PstCd)
        elif nodeName_ == 'TwnNm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TwnNm')
            value_ = self.gds_validate_string(value_, node, 'TwnNm')
            self.TwnNm = value_
            self.TwnNm_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.TwnNm)
        elif nodeName_ == 'TwnLctnNm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TwnLctnNm')
            value_ = self.gds_validate_string(value_, node, 'TwnLctnNm')
            self.TwnLctnNm = value_
            self.TwnLctnNm_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.TwnLctnNm)
        elif nodeName_ == 'DstrctNm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DstrctNm')
            value_ = self.gds_validate_string(value_, node, 'DstrctNm')
            self.DstrctNm = value_
            self.DstrctNm_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.DstrctNm)
        elif nodeName_ == 'CtrySubDvsn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CtrySubDvsn')
            value_ = self.gds_validate_string(value_, node, 'CtrySubDvsn')
            self.CtrySubDvsn = value_
            self.CtrySubDvsn_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.CtrySubDvsn)
        elif nodeName_ == 'Ctry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ctry')
            value_ = self.gds_validate_string(value_, node, 'Ctry')
            self.Ctry = value_
            self.Ctry_nsprefix_ = child_.prefix
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
        elif nodeName_ == 'AdrLine':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AdrLine')
            value_ = self.gds_validate_string(value_, node, 'AdrLine')
            self.AdrLine.append(value_)
            self.AdrLine_nsprefix_ = child_.prefix
            # validate type Max70Text
            self.validate_Max70Text(self.AdrLine[-1])
# end class PostalAddress24


class ProxyAccountIdentification1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', 'ProxyAccountType1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'ProxyAccountType1Choice'}, None),
        'Id': MemberSpec_('Id', ['Max2048Text', 'xs:string'], 0, 0, {'name': 'Id', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Id = Id
        self.validate_Max2048Text(self.Id)
        self.Id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProxyAccountIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProxyAccountIdentification1.subclass:
            return ProxyAccountIdentification1.subclass(*args_, **kwargs_)
        else:
            return ProxyAccountIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_Max2048Text(self, value):
        result = True
        # Validate type Max2048Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2048:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Tp is not None or
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ProxyAccountIdentification1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProxyAccountIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProxyAccountIdentification1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProxyAccountIdentification1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProxyAccountIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProxyAccountIdentification1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ProxyAccountIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            obj_ = ProxyAccountType1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Id':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Id')
            value_ = self.gds_validate_string(value_, node, 'Id')
            self.Id = value_
            self.Id_nsprefix_ = child_.prefix
            # validate type Max2048Text
            self.validate_Max2048Text(self.Id)
# end class ProxyAccountIdentification1


class ProxyAccountType1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalProxyAccountType1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 17),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 17),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalProxyAccountType1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProxyAccountType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProxyAccountType1Choice.subclass:
            return ProxyAccountType1Choice.subclass(*args_, **kwargs_)
        else:
            return ProxyAccountType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalProxyAccountType1Code(self, value):
        result = True
        # Validate type ExternalProxyAccountType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalProxyAccountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalProxyAccountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ProxyAccountType1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProxyAccountType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProxyAccountType1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProxyAccountType1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProxyAccountType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProxyAccountType1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ProxyAccountType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalProxyAccountType1Code
            self.validate_ExternalProxyAccountType1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ProxyAccountType1Choice


class Purpose2Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalPurpose1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 18),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 18),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalPurpose1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Purpose2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Purpose2Choice.subclass:
            return Purpose2Choice.subclass(*args_, **kwargs_)
        else:
            return Purpose2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalPurpose1Code(self, value):
        result = True
        # Validate type ExternalPurpose1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalPurpose1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalPurpose1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Purpose2Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Purpose2Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Purpose2Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Purpose2Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Purpose2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Purpose2Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='Purpose2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalPurpose1Code
            self.validate_ExternalPurpose1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class Purpose2Choice


class ReferredDocumentInformation7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', 'ReferredDocumentType4', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'ReferredDocumentType4'}, None),
        'Nb': MemberSpec_('Nb', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nb', 'type': 'xs:string'}, None),
        'RltdDt': MemberSpec_('RltdDt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RltdDt', 'type': 'xs:date'}, None),
        'LineDtls': MemberSpec_('LineDtls', 'DocumentLineInformation1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'LineDtls', 'type': 'DocumentLineInformation1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Nb=None, RltdDt=None, LineDtls=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Nb = Nb
        self.validate_Max35Text(self.Nb)
        self.Nb_nsprefix_ = None
        if isinstance(RltdDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RltdDt, '%Y-%m-%d').date()
        else:
            initvalue_ = RltdDt
        self.RltdDt = initvalue_
        self.RltdDt_nsprefix_ = None
        if LineDtls is None:
            self.LineDtls = []
        else:
            self.LineDtls = LineDtls
        self.LineDtls_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentInformation7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentInformation7.subclass:
            return ReferredDocumentInformation7.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentInformation7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Nb(self):
        return self.Nb
    def set_Nb(self, Nb):
        self.Nb = Nb
    def get_RltdDt(self):
        return self.RltdDt
    def set_RltdDt(self, RltdDt):
        self.RltdDt = RltdDt
    def get_LineDtls(self):
        return self.LineDtls
    def set_LineDtls(self, LineDtls):
        self.LineDtls = LineDtls
    def add_LineDtls(self, value):
        self.LineDtls.append(value)
    def insert_LineDtls_at(self, index, value):
        self.LineDtls.insert(index, value)
    def replace_LineDtls_at(self, index, value):
        self.LineDtls[index] = value
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.Tp is not None or
            self.Nb is not None or
            self.RltdDt is not None or
            self.LineDtls
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ReferredDocumentInformation7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferredDocumentInformation7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferredDocumentInformation7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferredDocumentInformation7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferredDocumentInformation7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferredDocumentInformation7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ReferredDocumentInformation7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Nb is not None:
            namespaceprefix_ = self.Nb_nsprefix_ + ':' if (UseCapturedNS_ and self.Nb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNb>%s</%sNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nb), input_name='Nb')), namespaceprefix_ , eol_))
        if self.RltdDt is not None:
            namespaceprefix_ = self.RltdDt_nsprefix_ + ':' if (UseCapturedNS_ and self.RltdDt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRltdDt>%s</%sRltdDt>%s' % (namespaceprefix_ , self.gds_format_date(self.RltdDt, input_name='RltdDt'), namespaceprefix_ , eol_))
        for LineDtls_ in self.LineDtls:
            namespaceprefix_ = self.LineDtls_nsprefix_ + ':' if (UseCapturedNS_ and self.LineDtls_nsprefix_) else ''
            LineDtls_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineDtls', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            obj_ = ReferredDocumentType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Nb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nb')
            value_ = self.gds_validate_string(value_, node, 'Nb')
            self.Nb = value_
            self.Nb_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Nb)
        elif nodeName_ == 'RltdDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RltdDt = dval_
            self.RltdDt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.RltdDt)
        elif nodeName_ == 'LineDtls':
            obj_ = DocumentLineInformation1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineDtls.append(obj_)
            obj_.original_tagname_ = 'LineDtls'
# end class ReferredDocumentInformation7


class ReferredDocumentType3Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['DocumentType6Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 19),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 19),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_DocumentType6Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentType3Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentType3Choice.subclass:
            return ReferredDocumentType3Choice.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentType3Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_DocumentType6Code(self, value):
        result = True
        # Validate type DocumentType6Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MSIN', 'CNFA', 'DNFA', 'CINV', 'CREN', 'DEBN', 'HIRI', 'SBIN', 'CMCN', 'SOAC', 'DISP', 'BOLD', 'VCHR', 'AROI', 'TSUT', 'PUOR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DocumentType6Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ReferredDocumentType3Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferredDocumentType3Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferredDocumentType3Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferredDocumentType3Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferredDocumentType3Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferredDocumentType3Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ReferredDocumentType3Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type DocumentType6Code
            self.validate_DocumentType6Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ReferredDocumentType3Choice


class ReferredDocumentType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'CdOrPrtry': MemberSpec_('CdOrPrtry', 'ReferredDocumentType3Choice', 0, 0, {'name': 'CdOrPrtry', 'type': 'ReferredDocumentType3Choice'}, None),
        'Issr': MemberSpec_('Issr', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Issr', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CdOrPrtry = CdOrPrtry
        self.CdOrPrtry_nsprefix_ = None
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
        self.Issr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentType4.subclass:
            return ReferredDocumentType4.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CdOrPrtry(self):
        return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry):
        self.CdOrPrtry = CdOrPrtry
    def get_Issr(self):
        return self.Issr
    def set_Issr(self, Issr):
        self.Issr = Issr
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ReferredDocumentType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferredDocumentType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferredDocumentType4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferredDocumentType4')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferredDocumentType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferredDocumentType4'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ReferredDocumentType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            namespaceprefix_ = self.CdOrPrtry_nsprefix_ + ':' if (UseCapturedNS_ and self.CdOrPrtry_nsprefix_) else ''
            self.CdOrPrtry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            namespaceprefix_ = self.Issr_nsprefix_ + ':' if (UseCapturedNS_ and self.Issr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CdOrPrtry':
            obj_ = ReferredDocumentType3Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Issr')
            value_ = self.gds_validate_string(value_, node, 'Issr')
            self.Issr = value_
            self.Issr_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class ReferredDocumentType4


class RegulatoryAuthority2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Nm': MemberSpec_('Nm', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nm', 'type': 'xs:string'}, None),
        'Ctry': MemberSpec_('Ctry', ['CountryCode', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Ctry', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Nm=None, Ctry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Nm_nsprefix_ = None
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        self.Ctry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatoryAuthority2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatoryAuthority2.subclass:
            return RegulatoryAuthority2.subclass(*args_, **kwargs_)
        else:
            return RegulatoryAuthority2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def get_Ctry(self):
        return self.Ctry
    def set_Ctry(self, Ctry):
        self.Ctry = Ctry
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CountryCode(self, value):
        result = True
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCode_patterns_, ))
                result = False
        return result
    validate_CountryCode_patterns_ = [['^([A-Z]{2,2})$']]
    def has__content(self):
        if (
            self.Nm is not None or
            self.Ctry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RegulatoryAuthority2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegulatoryAuthority2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RegulatoryAuthority2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RegulatoryAuthority2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RegulatoryAuthority2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RegulatoryAuthority2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RegulatoryAuthority2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
        if self.Ctry is not None:
            namespaceprefix_ = self.Ctry_nsprefix_ + ':' if (UseCapturedNS_ and self.Ctry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'Ctry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ctry')
            value_ = self.gds_validate_string(value_, node, 'Ctry')
            self.Ctry = value_
            self.Ctry_nsprefix_ = child_.prefix
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
# end class RegulatoryAuthority2


class RegulatoryReporting3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'DbtCdtRptgInd': MemberSpec_('DbtCdtRptgInd', ['RegulatoryReportingType1Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DbtCdtRptgInd', 'type': 'xs:string'}, None),
        'Authrty': MemberSpec_('Authrty', 'RegulatoryAuthority2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Authrty', 'type': 'RegulatoryAuthority2'}, None),
        'Dtls': MemberSpec_('Dtls', 'StructuredRegulatoryReporting3', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Dtls', 'type': 'StructuredRegulatoryReporting3'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, DbtCdtRptgInd=None, Authrty=None, Dtls=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DbtCdtRptgInd = DbtCdtRptgInd
        self.validate_RegulatoryReportingType1Code(self.DbtCdtRptgInd)
        self.DbtCdtRptgInd_nsprefix_ = None
        self.Authrty = Authrty
        self.Authrty_nsprefix_ = None
        if Dtls is None:
            self.Dtls = []
        else:
            self.Dtls = Dtls
        self.Dtls_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatoryReporting3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatoryReporting3.subclass:
            return RegulatoryReporting3.subclass(*args_, **kwargs_)
        else:
            return RegulatoryReporting3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DbtCdtRptgInd(self):
        return self.DbtCdtRptgInd
    def set_DbtCdtRptgInd(self, DbtCdtRptgInd):
        self.DbtCdtRptgInd = DbtCdtRptgInd
    def get_Authrty(self):
        return self.Authrty
    def set_Authrty(self, Authrty):
        self.Authrty = Authrty
    def get_Dtls(self):
        return self.Dtls
    def set_Dtls(self, Dtls):
        self.Dtls = Dtls
    def add_Dtls(self, value):
        self.Dtls.append(value)
    def insert_Dtls_at(self, index, value):
        self.Dtls.insert(index, value)
    def replace_Dtls_at(self, index, value):
        self.Dtls[index] = value
    def validate_RegulatoryReportingType1Code(self, value):
        result = True
        # Validate type RegulatoryReportingType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CRED', 'DEBT', 'BOTH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RegulatoryReportingType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.DbtCdtRptgInd is not None or
            self.Authrty is not None or
            self.Dtls
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RegulatoryReporting3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegulatoryReporting3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RegulatoryReporting3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RegulatoryReporting3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RegulatoryReporting3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RegulatoryReporting3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RegulatoryReporting3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DbtCdtRptgInd is not None:
            namespaceprefix_ = self.DbtCdtRptgInd_nsprefix_ + ':' if (UseCapturedNS_ and self.DbtCdtRptgInd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDbtCdtRptgInd>%s</%sDbtCdtRptgInd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DbtCdtRptgInd), input_name='DbtCdtRptgInd')), namespaceprefix_ , eol_))
        if self.Authrty is not None:
            namespaceprefix_ = self.Authrty_nsprefix_ + ':' if (UseCapturedNS_ and self.Authrty_nsprefix_) else ''
            self.Authrty.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Authrty', pretty_print=pretty_print)
        for Dtls_ in self.Dtls:
            namespaceprefix_ = self.Dtls_nsprefix_ + ':' if (UseCapturedNS_ and self.Dtls_nsprefix_) else ''
            Dtls_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dtls', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DbtCdtRptgInd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DbtCdtRptgInd')
            value_ = self.gds_validate_string(value_, node, 'DbtCdtRptgInd')
            self.DbtCdtRptgInd = value_
            self.DbtCdtRptgInd_nsprefix_ = child_.prefix
            # validate type RegulatoryReportingType1Code
            self.validate_RegulatoryReportingType1Code(self.DbtCdtRptgInd)
        elif nodeName_ == 'Authrty':
            obj_ = RegulatoryAuthority2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Authrty = obj_
            obj_.original_tagname_ = 'Authrty'
        elif nodeName_ == 'Dtls':
            obj_ = StructuredRegulatoryReporting3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dtls.append(obj_)
            obj_.original_tagname_ = 'Dtls'
# end class RegulatoryReporting3


class RemittanceAmount2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'DuePyblAmt': MemberSpec_('DuePyblAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DuePyblAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'DscntApldAmt': MemberSpec_('DscntApldAmt', 'DiscountAmountAndType1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'DscntApldAmt', 'type': 'DiscountAmountAndType1'}, None),
        'CdtNoteAmt': MemberSpec_('CdtNoteAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CdtNoteAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'TaxAmt': MemberSpec_('TaxAmt', 'TaxAmountAndType1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'TaxAmt', 'type': 'TaxAmountAndType1'}, None),
        'AdjstmntAmtAndRsn': MemberSpec_('AdjstmntAmtAndRsn', 'DocumentAdjustment1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'AdjstmntAmtAndRsn', 'type': 'DocumentAdjustment1'}, None),
        'RmtdAmt': MemberSpec_('RmtdAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RmtdAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, DuePyblAmt=None, DscntApldAmt=None, CdtNoteAmt=None, TaxAmt=None, AdjstmntAmtAndRsn=None, RmtdAmt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DuePyblAmt = DuePyblAmt
        self.DuePyblAmt_nsprefix_ = None
        if DscntApldAmt is None:
            self.DscntApldAmt = []
        else:
            self.DscntApldAmt = DscntApldAmt
        self.DscntApldAmt_nsprefix_ = None
        self.CdtNoteAmt = CdtNoteAmt
        self.CdtNoteAmt_nsprefix_ = None
        if TaxAmt is None:
            self.TaxAmt = []
        else:
            self.TaxAmt = TaxAmt
        self.TaxAmt_nsprefix_ = None
        if AdjstmntAmtAndRsn is None:
            self.AdjstmntAmtAndRsn = []
        else:
            self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
        self.AdjstmntAmtAndRsn_nsprefix_ = None
        self.RmtdAmt = RmtdAmt
        self.RmtdAmt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceAmount2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceAmount2.subclass:
            return RemittanceAmount2.subclass(*args_, **kwargs_)
        else:
            return RemittanceAmount2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DuePyblAmt(self):
        return self.DuePyblAmt
    def set_DuePyblAmt(self, DuePyblAmt):
        self.DuePyblAmt = DuePyblAmt
    def get_DscntApldAmt(self):
        return self.DscntApldAmt
    def set_DscntApldAmt(self, DscntApldAmt):
        self.DscntApldAmt = DscntApldAmt
    def add_DscntApldAmt(self, value):
        self.DscntApldAmt.append(value)
    def insert_DscntApldAmt_at(self, index, value):
        self.DscntApldAmt.insert(index, value)
    def replace_DscntApldAmt_at(self, index, value):
        self.DscntApldAmt[index] = value
    def get_CdtNoteAmt(self):
        return self.CdtNoteAmt
    def set_CdtNoteAmt(self, CdtNoteAmt):
        self.CdtNoteAmt = CdtNoteAmt
    def get_TaxAmt(self):
        return self.TaxAmt
    def set_TaxAmt(self, TaxAmt):
        self.TaxAmt = TaxAmt
    def add_TaxAmt(self, value):
        self.TaxAmt.append(value)
    def insert_TaxAmt_at(self, index, value):
        self.TaxAmt.insert(index, value)
    def replace_TaxAmt_at(self, index, value):
        self.TaxAmt[index] = value
    def get_AdjstmntAmtAndRsn(self):
        return self.AdjstmntAmtAndRsn
    def set_AdjstmntAmtAndRsn(self, AdjstmntAmtAndRsn):
        self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
    def add_AdjstmntAmtAndRsn(self, value):
        self.AdjstmntAmtAndRsn.append(value)
    def insert_AdjstmntAmtAndRsn_at(self, index, value):
        self.AdjstmntAmtAndRsn.insert(index, value)
    def replace_AdjstmntAmtAndRsn_at(self, index, value):
        self.AdjstmntAmtAndRsn[index] = value
    def get_RmtdAmt(self):
        return self.RmtdAmt
    def set_RmtdAmt(self, RmtdAmt):
        self.RmtdAmt = RmtdAmt
    def has__content(self):
        if (
            self.DuePyblAmt is not None or
            self.DscntApldAmt or
            self.CdtNoteAmt is not None or
            self.TaxAmt or
            self.AdjstmntAmtAndRsn or
            self.RmtdAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceAmount2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceAmount2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RemittanceAmount2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RemittanceAmount2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RemittanceAmount2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RemittanceAmount2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceAmount2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DuePyblAmt is not None:
            namespaceprefix_ = self.DuePyblAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.DuePyblAmt_nsprefix_) else ''
            self.DuePyblAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DuePyblAmt', pretty_print=pretty_print)
        for DscntApldAmt_ in self.DscntApldAmt:
            namespaceprefix_ = self.DscntApldAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.DscntApldAmt_nsprefix_) else ''
            DscntApldAmt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DscntApldAmt', pretty_print=pretty_print)
        if self.CdtNoteAmt is not None:
            namespaceprefix_ = self.CdtNoteAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtNoteAmt_nsprefix_) else ''
            self.CdtNoteAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdtNoteAmt', pretty_print=pretty_print)
        for TaxAmt_ in self.TaxAmt:
            namespaceprefix_ = self.TaxAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxAmt_nsprefix_) else ''
            TaxAmt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxAmt', pretty_print=pretty_print)
        for AdjstmntAmtAndRsn_ in self.AdjstmntAmtAndRsn:
            namespaceprefix_ = self.AdjstmntAmtAndRsn_nsprefix_ + ':' if (UseCapturedNS_ and self.AdjstmntAmtAndRsn_nsprefix_) else ''
            AdjstmntAmtAndRsn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AdjstmntAmtAndRsn', pretty_print=pretty_print)
        if self.RmtdAmt is not None:
            namespaceprefix_ = self.RmtdAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.RmtdAmt_nsprefix_) else ''
            self.RmtdAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RmtdAmt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DuePyblAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DuePyblAmt = obj_
            obj_.original_tagname_ = 'DuePyblAmt'
        elif nodeName_ == 'DscntApldAmt':
            obj_ = DiscountAmountAndType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DscntApldAmt.append(obj_)
            obj_.original_tagname_ = 'DscntApldAmt'
        elif nodeName_ == 'CdtNoteAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdtNoteAmt = obj_
            obj_.original_tagname_ = 'CdtNoteAmt'
        elif nodeName_ == 'TaxAmt':
            obj_ = TaxAmountAndType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxAmt.append(obj_)
            obj_.original_tagname_ = 'TaxAmt'
        elif nodeName_ == 'AdjstmntAmtAndRsn':
            obj_ = DocumentAdjustment1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdjstmntAmtAndRsn.append(obj_)
            obj_.original_tagname_ = 'AdjstmntAmtAndRsn'
        elif nodeName_ == 'RmtdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RmtdAmt = obj_
            obj_.original_tagname_ = 'RmtdAmt'
# end class RemittanceAmount2


class RemittanceAmount3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'DuePyblAmt': MemberSpec_('DuePyblAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DuePyblAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'DscntApldAmt': MemberSpec_('DscntApldAmt', 'DiscountAmountAndType1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'DscntApldAmt', 'type': 'DiscountAmountAndType1'}, None),
        'CdtNoteAmt': MemberSpec_('CdtNoteAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CdtNoteAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'TaxAmt': MemberSpec_('TaxAmt', 'TaxAmountAndType1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'TaxAmt', 'type': 'TaxAmountAndType1'}, None),
        'AdjstmntAmtAndRsn': MemberSpec_('AdjstmntAmtAndRsn', 'DocumentAdjustment1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'AdjstmntAmtAndRsn', 'type': 'DocumentAdjustment1'}, None),
        'RmtdAmt': MemberSpec_('RmtdAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RmtdAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, DuePyblAmt=None, DscntApldAmt=None, CdtNoteAmt=None, TaxAmt=None, AdjstmntAmtAndRsn=None, RmtdAmt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DuePyblAmt = DuePyblAmt
        self.DuePyblAmt_nsprefix_ = None
        if DscntApldAmt is None:
            self.DscntApldAmt = []
        else:
            self.DscntApldAmt = DscntApldAmt
        self.DscntApldAmt_nsprefix_ = None
        self.CdtNoteAmt = CdtNoteAmt
        self.CdtNoteAmt_nsprefix_ = None
        if TaxAmt is None:
            self.TaxAmt = []
        else:
            self.TaxAmt = TaxAmt
        self.TaxAmt_nsprefix_ = None
        if AdjstmntAmtAndRsn is None:
            self.AdjstmntAmtAndRsn = []
        else:
            self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
        self.AdjstmntAmtAndRsn_nsprefix_ = None
        self.RmtdAmt = RmtdAmt
        self.RmtdAmt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceAmount3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceAmount3.subclass:
            return RemittanceAmount3.subclass(*args_, **kwargs_)
        else:
            return RemittanceAmount3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DuePyblAmt(self):
        return self.DuePyblAmt
    def set_DuePyblAmt(self, DuePyblAmt):
        self.DuePyblAmt = DuePyblAmt
    def get_DscntApldAmt(self):
        return self.DscntApldAmt
    def set_DscntApldAmt(self, DscntApldAmt):
        self.DscntApldAmt = DscntApldAmt
    def add_DscntApldAmt(self, value):
        self.DscntApldAmt.append(value)
    def insert_DscntApldAmt_at(self, index, value):
        self.DscntApldAmt.insert(index, value)
    def replace_DscntApldAmt_at(self, index, value):
        self.DscntApldAmt[index] = value
    def get_CdtNoteAmt(self):
        return self.CdtNoteAmt
    def set_CdtNoteAmt(self, CdtNoteAmt):
        self.CdtNoteAmt = CdtNoteAmt
    def get_TaxAmt(self):
        return self.TaxAmt
    def set_TaxAmt(self, TaxAmt):
        self.TaxAmt = TaxAmt
    def add_TaxAmt(self, value):
        self.TaxAmt.append(value)
    def insert_TaxAmt_at(self, index, value):
        self.TaxAmt.insert(index, value)
    def replace_TaxAmt_at(self, index, value):
        self.TaxAmt[index] = value
    def get_AdjstmntAmtAndRsn(self):
        return self.AdjstmntAmtAndRsn
    def set_AdjstmntAmtAndRsn(self, AdjstmntAmtAndRsn):
        self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
    def add_AdjstmntAmtAndRsn(self, value):
        self.AdjstmntAmtAndRsn.append(value)
    def insert_AdjstmntAmtAndRsn_at(self, index, value):
        self.AdjstmntAmtAndRsn.insert(index, value)
    def replace_AdjstmntAmtAndRsn_at(self, index, value):
        self.AdjstmntAmtAndRsn[index] = value
    def get_RmtdAmt(self):
        return self.RmtdAmt
    def set_RmtdAmt(self, RmtdAmt):
        self.RmtdAmt = RmtdAmt
    def has__content(self):
        if (
            self.DuePyblAmt is not None or
            self.DscntApldAmt or
            self.CdtNoteAmt is not None or
            self.TaxAmt or
            self.AdjstmntAmtAndRsn or
            self.RmtdAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceAmount3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceAmount3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RemittanceAmount3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RemittanceAmount3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RemittanceAmount3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RemittanceAmount3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceAmount3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DuePyblAmt is not None:
            namespaceprefix_ = self.DuePyblAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.DuePyblAmt_nsprefix_) else ''
            self.DuePyblAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DuePyblAmt', pretty_print=pretty_print)
        for DscntApldAmt_ in self.DscntApldAmt:
            namespaceprefix_ = self.DscntApldAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.DscntApldAmt_nsprefix_) else ''
            DscntApldAmt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DscntApldAmt', pretty_print=pretty_print)
        if self.CdtNoteAmt is not None:
            namespaceprefix_ = self.CdtNoteAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtNoteAmt_nsprefix_) else ''
            self.CdtNoteAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdtNoteAmt', pretty_print=pretty_print)
        for TaxAmt_ in self.TaxAmt:
            namespaceprefix_ = self.TaxAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxAmt_nsprefix_) else ''
            TaxAmt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxAmt', pretty_print=pretty_print)
        for AdjstmntAmtAndRsn_ in self.AdjstmntAmtAndRsn:
            namespaceprefix_ = self.AdjstmntAmtAndRsn_nsprefix_ + ':' if (UseCapturedNS_ and self.AdjstmntAmtAndRsn_nsprefix_) else ''
            AdjstmntAmtAndRsn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AdjstmntAmtAndRsn', pretty_print=pretty_print)
        if self.RmtdAmt is not None:
            namespaceprefix_ = self.RmtdAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.RmtdAmt_nsprefix_) else ''
            self.RmtdAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RmtdAmt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DuePyblAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DuePyblAmt = obj_
            obj_.original_tagname_ = 'DuePyblAmt'
        elif nodeName_ == 'DscntApldAmt':
            obj_ = DiscountAmountAndType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DscntApldAmt.append(obj_)
            obj_.original_tagname_ = 'DscntApldAmt'
        elif nodeName_ == 'CdtNoteAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdtNoteAmt = obj_
            obj_.original_tagname_ = 'CdtNoteAmt'
        elif nodeName_ == 'TaxAmt':
            obj_ = TaxAmountAndType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxAmt.append(obj_)
            obj_.original_tagname_ = 'TaxAmt'
        elif nodeName_ == 'AdjstmntAmtAndRsn':
            obj_ = DocumentAdjustment1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdjstmntAmtAndRsn.append(obj_)
            obj_.original_tagname_ = 'AdjstmntAmtAndRsn'
        elif nodeName_ == 'RmtdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RmtdAmt = obj_
            obj_.original_tagname_ = 'RmtdAmt'
# end class RemittanceAmount3


class RemittanceInformation16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Ustrd': MemberSpec_('Ustrd', ['Max140Text', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Ustrd', 'type': 'xs:string'}, None),
        'Strd': MemberSpec_('Strd', 'StructuredRemittanceInformation16', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Strd', 'type': 'StructuredRemittanceInformation16'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Ustrd=None, Strd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Ustrd is None:
            self.Ustrd = []
        else:
            self.Ustrd = Ustrd
        self.Ustrd_nsprefix_ = None
        if Strd is None:
            self.Strd = []
        else:
            self.Strd = Strd
        self.Strd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceInformation16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceInformation16.subclass:
            return RemittanceInformation16.subclass(*args_, **kwargs_)
        else:
            return RemittanceInformation16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Ustrd(self):
        return self.Ustrd
    def set_Ustrd(self, Ustrd):
        self.Ustrd = Ustrd
    def add_Ustrd(self, value):
        self.Ustrd.append(value)
    def insert_Ustrd_at(self, index, value):
        self.Ustrd.insert(index, value)
    def replace_Ustrd_at(self, index, value):
        self.Ustrd[index] = value
    def get_Strd(self):
        return self.Strd
    def set_Strd(self, Strd):
        self.Strd = Strd
    def add_Strd(self, value):
        self.Strd.append(value)
    def insert_Strd_at(self, index, value):
        self.Strd.insert(index, value)
    def replace_Strd_at(self, index, value):
        self.Strd[index] = value
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Ustrd or
            self.Strd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceInformation16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceInformation16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RemittanceInformation16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RemittanceInformation16')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RemittanceInformation16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RemittanceInformation16'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceInformation16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Ustrd_ in self.Ustrd:
            namespaceprefix_ = self.Ustrd_nsprefix_ + ':' if (UseCapturedNS_ and self.Ustrd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUstrd>%s</%sUstrd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Ustrd_), input_name='Ustrd')), namespaceprefix_ , eol_))
        for Strd_ in self.Strd:
            namespaceprefix_ = self.Strd_nsprefix_ + ':' if (UseCapturedNS_ and self.Strd_nsprefix_) else ''
            Strd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Strd', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Ustrd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ustrd')
            value_ = self.gds_validate_string(value_, node, 'Ustrd')
            self.Ustrd.append(value_)
            self.Ustrd_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Ustrd[-1])
        elif nodeName_ == 'Strd':
            obj_ = StructuredRemittanceInformation16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Strd.append(obj_)
            obj_.original_tagname_ = 'Strd'
# end class RemittanceInformation16


class RemittanceLocation7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'RmtId': MemberSpec_('RmtId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RmtId', 'type': 'xs:string'}, None),
        'RmtLctnDtls': MemberSpec_('RmtLctnDtls', 'RemittanceLocationData1', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'RmtLctnDtls', 'type': 'RemittanceLocationData1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, RmtId=None, RmtLctnDtls=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RmtId = RmtId
        self.validate_Max35Text(self.RmtId)
        self.RmtId_nsprefix_ = None
        if RmtLctnDtls is None:
            self.RmtLctnDtls = []
        else:
            self.RmtLctnDtls = RmtLctnDtls
        self.RmtLctnDtls_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceLocation7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceLocation7.subclass:
            return RemittanceLocation7.subclass(*args_, **kwargs_)
        else:
            return RemittanceLocation7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RmtId(self):
        return self.RmtId
    def set_RmtId(self, RmtId):
        self.RmtId = RmtId
    def get_RmtLctnDtls(self):
        return self.RmtLctnDtls
    def set_RmtLctnDtls(self, RmtLctnDtls):
        self.RmtLctnDtls = RmtLctnDtls
    def add_RmtLctnDtls(self, value):
        self.RmtLctnDtls.append(value)
    def insert_RmtLctnDtls_at(self, index, value):
        self.RmtLctnDtls.insert(index, value)
    def replace_RmtLctnDtls_at(self, index, value):
        self.RmtLctnDtls[index] = value
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.RmtId is not None or
            self.RmtLctnDtls
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceLocation7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceLocation7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RemittanceLocation7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RemittanceLocation7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RemittanceLocation7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RemittanceLocation7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceLocation7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RmtId is not None:
            namespaceprefix_ = self.RmtId_nsprefix_ + ':' if (UseCapturedNS_ and self.RmtId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRmtId>%s</%sRmtId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RmtId), input_name='RmtId')), namespaceprefix_ , eol_))
        for RmtLctnDtls_ in self.RmtLctnDtls:
            namespaceprefix_ = self.RmtLctnDtls_nsprefix_ + ':' if (UseCapturedNS_ and self.RmtLctnDtls_nsprefix_) else ''
            RmtLctnDtls_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RmtLctnDtls', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RmtId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RmtId')
            value_ = self.gds_validate_string(value_, node, 'RmtId')
            self.RmtId = value_
            self.RmtId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.RmtId)
        elif nodeName_ == 'RmtLctnDtls':
            obj_ = RemittanceLocationData1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RmtLctnDtls.append(obj_)
            obj_.original_tagname_ = 'RmtLctnDtls'
# end class RemittanceLocation7


class RemittanceLocationData1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Mtd': MemberSpec_('Mtd', ['RemittanceLocationMethod2Code', 'xs:string'], 0, 0, {'name': 'Mtd', 'type': 'xs:string'}, None),
        'ElctrncAdr': MemberSpec_('ElctrncAdr', ['Max2048Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ElctrncAdr', 'type': 'xs:string'}, None),
        'PstlAdr': MemberSpec_('PstlAdr', 'NameAndAddress16', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PstlAdr', 'type': 'NameAndAddress16'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Mtd=None, ElctrncAdr=None, PstlAdr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Mtd = Mtd
        self.validate_RemittanceLocationMethod2Code(self.Mtd)
        self.Mtd_nsprefix_ = None
        self.ElctrncAdr = ElctrncAdr
        self.validate_Max2048Text(self.ElctrncAdr)
        self.ElctrncAdr_nsprefix_ = None
        self.PstlAdr = PstlAdr
        self.PstlAdr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceLocationData1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceLocationData1.subclass:
            return RemittanceLocationData1.subclass(*args_, **kwargs_)
        else:
            return RemittanceLocationData1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Mtd(self):
        return self.Mtd
    def set_Mtd(self, Mtd):
        self.Mtd = Mtd
    def get_ElctrncAdr(self):
        return self.ElctrncAdr
    def set_ElctrncAdr(self, ElctrncAdr):
        self.ElctrncAdr = ElctrncAdr
    def get_PstlAdr(self):
        return self.PstlAdr
    def set_PstlAdr(self, PstlAdr):
        self.PstlAdr = PstlAdr
    def validate_RemittanceLocationMethod2Code(self, value):
        result = True
        # Validate type RemittanceLocationMethod2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FAXI', 'EDIC', 'URID', 'EMAL', 'POST', 'SMSM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RemittanceLocationMethod2Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max2048Text(self, value):
        result = True
        # Validate type Max2048Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2048:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max2048Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Mtd is not None or
            self.ElctrncAdr is not None or
            self.PstlAdr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceLocationData1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceLocationData1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RemittanceLocationData1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RemittanceLocationData1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RemittanceLocationData1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RemittanceLocationData1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='RemittanceLocationData1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Mtd is not None:
            namespaceprefix_ = self.Mtd_nsprefix_ + ':' if (UseCapturedNS_ and self.Mtd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtd>%s</%sMtd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Mtd), input_name='Mtd')), namespaceprefix_ , eol_))
        if self.ElctrncAdr is not None:
            namespaceprefix_ = self.ElctrncAdr_nsprefix_ + ':' if (UseCapturedNS_ and self.ElctrncAdr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sElctrncAdr>%s</%sElctrncAdr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ElctrncAdr), input_name='ElctrncAdr')), namespaceprefix_ , eol_))
        if self.PstlAdr is not None:
            namespaceprefix_ = self.PstlAdr_nsprefix_ + ':' if (UseCapturedNS_ and self.PstlAdr_nsprefix_) else ''
            self.PstlAdr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PstlAdr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Mtd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Mtd')
            value_ = self.gds_validate_string(value_, node, 'Mtd')
            self.Mtd = value_
            self.Mtd_nsprefix_ = child_.prefix
            # validate type RemittanceLocationMethod2Code
            self.validate_RemittanceLocationMethod2Code(self.Mtd)
        elif nodeName_ == 'ElctrncAdr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ElctrncAdr')
            value_ = self.gds_validate_string(value_, node, 'ElctrncAdr')
            self.ElctrncAdr = value_
            self.ElctrncAdr_nsprefix_ = child_.prefix
            # validate type Max2048Text
            self.validate_Max2048Text(self.ElctrncAdr)
        elif nodeName_ == 'PstlAdr':
            obj_ = NameAndAddress16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
# end class RemittanceLocationData1


class ServiceLevel8Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalServiceLevel1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 20),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 20),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalServiceLevel1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceLevel8Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceLevel8Choice.subclass:
            return ServiceLevel8Choice.subclass(*args_, **kwargs_)
        else:
            return ServiceLevel8Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalServiceLevel1Code(self, value):
        result = True
        # Validate type ExternalServiceLevel1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalServiceLevel1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalServiceLevel1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ServiceLevel8Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceLevel8Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceLevel8Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceLevel8Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceLevel8Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceLevel8Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='ServiceLevel8Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalServiceLevel1Code
            self.validate_ExternalServiceLevel1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ServiceLevel8Choice


class SettlementDateTimeIndication1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'DbtDtTm': MemberSpec_('DbtDtTm', ['ISODateTime', 'xs:dateTime'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DbtDtTm', 'type': 'xs:dateTime'}, None),
        'CdtDtTm': MemberSpec_('CdtDtTm', ['ISODateTime', 'xs:dateTime'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CdtDtTm', 'type': 'xs:dateTime'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, DbtDtTm=None, CdtDtTm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(DbtDtTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DbtDtTm, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DbtDtTm
        self.DbtDtTm = initvalue_
        self.DbtDtTm_nsprefix_ = None
        if isinstance(CdtDtTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CdtDtTm, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CdtDtTm
        self.CdtDtTm = initvalue_
        self.CdtDtTm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementDateTimeIndication1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementDateTimeIndication1.subclass:
            return SettlementDateTimeIndication1.subclass(*args_, **kwargs_)
        else:
            return SettlementDateTimeIndication1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DbtDtTm(self):
        return self.DbtDtTm
    def set_DbtDtTm(self, DbtDtTm):
        self.DbtDtTm = DbtDtTm
    def get_CdtDtTm(self):
        return self.CdtDtTm
    def set_CdtDtTm(self, CdtDtTm):
        self.CdtDtTm = CdtDtTm
    def validate_ISODateTime(self, value):
        result = True
        # Validate type ISODateTime, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.DbtDtTm is not None or
            self.CdtDtTm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SettlementDateTimeIndication1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SettlementDateTimeIndication1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SettlementDateTimeIndication1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SettlementDateTimeIndication1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SettlementDateTimeIndication1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SettlementDateTimeIndication1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SettlementDateTimeIndication1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DbtDtTm is not None:
            namespaceprefix_ = self.DbtDtTm_nsprefix_ + ':' if (UseCapturedNS_ and self.DbtDtTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDbtDtTm>%s</%sDbtDtTm>%s' % (namespaceprefix_ , self.gds_format_datetime(self.DbtDtTm, input_name='DbtDtTm'), namespaceprefix_ , eol_))
        if self.CdtDtTm is not None:
            namespaceprefix_ = self.CdtDtTm_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtDtTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCdtDtTm>%s</%sCdtDtTm>%s' % (namespaceprefix_ , self.gds_format_datetime(self.CdtDtTm, input_name='CdtDtTm'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DbtDtTm':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DbtDtTm = dval_
            self.DbtDtTm_nsprefix_ = child_.prefix
            # validate type ISODateTime
            self.validate_ISODateTime(self.DbtDtTm)
        elif nodeName_ == 'CdtDtTm':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.CdtDtTm = dval_
            self.CdtDtTm_nsprefix_ = child_.prefix
            # validate type ISODateTime
            self.validate_ISODateTime(self.CdtDtTm)
# end class SettlementDateTimeIndication1


class SettlementInstruction7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'SttlmMtd': MemberSpec_('SttlmMtd', ['SettlementMethod1Code', 'xs:string'], 0, 0, {'name': 'SttlmMtd', 'type': 'xs:string'}, None),
        'SttlmAcct': MemberSpec_('SttlmAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SttlmAcct', 'type': 'CashAccount38'}, None),
        'ClrSys': MemberSpec_('ClrSys', 'ClearingSystemIdentification3Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ClrSys', 'type': 'ClearingSystemIdentification3Choice'}, None),
        'InstgRmbrsmntAgt': MemberSpec_('InstgRmbrsmntAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstgRmbrsmntAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'InstgRmbrsmntAgtAcct': MemberSpec_('InstgRmbrsmntAgtAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstgRmbrsmntAgtAcct', 'type': 'CashAccount38'}, None),
        'InstdRmbrsmntAgt': MemberSpec_('InstdRmbrsmntAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstdRmbrsmntAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'InstdRmbrsmntAgtAcct': MemberSpec_('InstdRmbrsmntAgtAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'InstdRmbrsmntAgtAcct', 'type': 'CashAccount38'}, None),
        'ThrdRmbrsmntAgt': MemberSpec_('ThrdRmbrsmntAgt', 'BranchAndFinancialInstitutionIdentification6', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ThrdRmbrsmntAgt', 'type': 'BranchAndFinancialInstitutionIdentification6'}, None),
        'ThrdRmbrsmntAgtAcct': MemberSpec_('ThrdRmbrsmntAgtAcct', 'CashAccount38', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'ThrdRmbrsmntAgtAcct', 'type': 'CashAccount38'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, SttlmMtd=None, SttlmAcct=None, ClrSys=None, InstgRmbrsmntAgt=None, InstgRmbrsmntAgtAcct=None, InstdRmbrsmntAgt=None, InstdRmbrsmntAgtAcct=None, ThrdRmbrsmntAgt=None, ThrdRmbrsmntAgtAcct=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SttlmMtd = SttlmMtd
        self.validate_SettlementMethod1Code(self.SttlmMtd)
        self.SttlmMtd_nsprefix_ = None
        self.SttlmAcct = SttlmAcct
        self.SttlmAcct_nsprefix_ = None
        self.ClrSys = ClrSys
        self.ClrSys_nsprefix_ = None
        self.InstgRmbrsmntAgt = InstgRmbrsmntAgt
        self.InstgRmbrsmntAgt_nsprefix_ = None
        self.InstgRmbrsmntAgtAcct = InstgRmbrsmntAgtAcct
        self.InstgRmbrsmntAgtAcct_nsprefix_ = None
        self.InstdRmbrsmntAgt = InstdRmbrsmntAgt
        self.InstdRmbrsmntAgt_nsprefix_ = None
        self.InstdRmbrsmntAgtAcct = InstdRmbrsmntAgtAcct
        self.InstdRmbrsmntAgtAcct_nsprefix_ = None
        self.ThrdRmbrsmntAgt = ThrdRmbrsmntAgt
        self.ThrdRmbrsmntAgt_nsprefix_ = None
        self.ThrdRmbrsmntAgtAcct = ThrdRmbrsmntAgtAcct
        self.ThrdRmbrsmntAgtAcct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementInstruction7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementInstruction7.subclass:
            return SettlementInstruction7.subclass(*args_, **kwargs_)
        else:
            return SettlementInstruction7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SttlmMtd(self):
        return self.SttlmMtd
    def set_SttlmMtd(self, SttlmMtd):
        self.SttlmMtd = SttlmMtd
    def get_SttlmAcct(self):
        return self.SttlmAcct
    def set_SttlmAcct(self, SttlmAcct):
        self.SttlmAcct = SttlmAcct
    def get_ClrSys(self):
        return self.ClrSys
    def set_ClrSys(self, ClrSys):
        self.ClrSys = ClrSys
    def get_InstgRmbrsmntAgt(self):
        return self.InstgRmbrsmntAgt
    def set_InstgRmbrsmntAgt(self, InstgRmbrsmntAgt):
        self.InstgRmbrsmntAgt = InstgRmbrsmntAgt
    def get_InstgRmbrsmntAgtAcct(self):
        return self.InstgRmbrsmntAgtAcct
    def set_InstgRmbrsmntAgtAcct(self, InstgRmbrsmntAgtAcct):
        self.InstgRmbrsmntAgtAcct = InstgRmbrsmntAgtAcct
    def get_InstdRmbrsmntAgt(self):
        return self.InstdRmbrsmntAgt
    def set_InstdRmbrsmntAgt(self, InstdRmbrsmntAgt):
        self.InstdRmbrsmntAgt = InstdRmbrsmntAgt
    def get_InstdRmbrsmntAgtAcct(self):
        return self.InstdRmbrsmntAgtAcct
    def set_InstdRmbrsmntAgtAcct(self, InstdRmbrsmntAgtAcct):
        self.InstdRmbrsmntAgtAcct = InstdRmbrsmntAgtAcct
    def get_ThrdRmbrsmntAgt(self):
        return self.ThrdRmbrsmntAgt
    def set_ThrdRmbrsmntAgt(self, ThrdRmbrsmntAgt):
        self.ThrdRmbrsmntAgt = ThrdRmbrsmntAgt
    def get_ThrdRmbrsmntAgtAcct(self):
        return self.ThrdRmbrsmntAgtAcct
    def set_ThrdRmbrsmntAgtAcct(self, ThrdRmbrsmntAgtAcct):
        self.ThrdRmbrsmntAgtAcct = ThrdRmbrsmntAgtAcct
    def validate_SettlementMethod1Code(self, value):
        result = True
        # Validate type SettlementMethod1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INDA', 'INGA', 'COVE', 'CLRG']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SettlementMethod1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.SttlmMtd is not None or
            self.SttlmAcct is not None or
            self.ClrSys is not None or
            self.InstgRmbrsmntAgt is not None or
            self.InstgRmbrsmntAgtAcct is not None or
            self.InstdRmbrsmntAgt is not None or
            self.InstdRmbrsmntAgtAcct is not None or
            self.ThrdRmbrsmntAgt is not None or
            self.ThrdRmbrsmntAgtAcct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SettlementInstruction7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SettlementInstruction7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SettlementInstruction7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SettlementInstruction7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SettlementInstruction7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SettlementInstruction7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SettlementInstruction7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SttlmMtd is not None:
            namespaceprefix_ = self.SttlmMtd_nsprefix_ + ':' if (UseCapturedNS_ and self.SttlmMtd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSttlmMtd>%s</%sSttlmMtd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SttlmMtd), input_name='SttlmMtd')), namespaceprefix_ , eol_))
        if self.SttlmAcct is not None:
            namespaceprefix_ = self.SttlmAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.SttlmAcct_nsprefix_) else ''
            self.SttlmAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SttlmAcct', pretty_print=pretty_print)
        if self.ClrSys is not None:
            namespaceprefix_ = self.ClrSys_nsprefix_ + ':' if (UseCapturedNS_ and self.ClrSys_nsprefix_) else ''
            self.ClrSys.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClrSys', pretty_print=pretty_print)
        if self.InstgRmbrsmntAgt is not None:
            namespaceprefix_ = self.InstgRmbrsmntAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstgRmbrsmntAgt_nsprefix_) else ''
            self.InstgRmbrsmntAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstgRmbrsmntAgt', pretty_print=pretty_print)
        if self.InstgRmbrsmntAgtAcct is not None:
            namespaceprefix_ = self.InstgRmbrsmntAgtAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.InstgRmbrsmntAgtAcct_nsprefix_) else ''
            self.InstgRmbrsmntAgtAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstgRmbrsmntAgtAcct', pretty_print=pretty_print)
        if self.InstdRmbrsmntAgt is not None:
            namespaceprefix_ = self.InstdRmbrsmntAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.InstdRmbrsmntAgt_nsprefix_) else ''
            self.InstdRmbrsmntAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstdRmbrsmntAgt', pretty_print=pretty_print)
        if self.InstdRmbrsmntAgtAcct is not None:
            namespaceprefix_ = self.InstdRmbrsmntAgtAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.InstdRmbrsmntAgtAcct_nsprefix_) else ''
            self.InstdRmbrsmntAgtAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstdRmbrsmntAgtAcct', pretty_print=pretty_print)
        if self.ThrdRmbrsmntAgt is not None:
            namespaceprefix_ = self.ThrdRmbrsmntAgt_nsprefix_ + ':' if (UseCapturedNS_ and self.ThrdRmbrsmntAgt_nsprefix_) else ''
            self.ThrdRmbrsmntAgt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ThrdRmbrsmntAgt', pretty_print=pretty_print)
        if self.ThrdRmbrsmntAgtAcct is not None:
            namespaceprefix_ = self.ThrdRmbrsmntAgtAcct_nsprefix_ + ':' if (UseCapturedNS_ and self.ThrdRmbrsmntAgtAcct_nsprefix_) else ''
            self.ThrdRmbrsmntAgtAcct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ThrdRmbrsmntAgtAcct', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SttlmMtd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SttlmMtd')
            value_ = self.gds_validate_string(value_, node, 'SttlmMtd')
            self.SttlmMtd = value_
            self.SttlmMtd_nsprefix_ = child_.prefix
            # validate type SettlementMethod1Code
            self.validate_SettlementMethod1Code(self.SttlmMtd)
        elif nodeName_ == 'SttlmAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SttlmAcct = obj_
            obj_.original_tagname_ = 'SttlmAcct'
        elif nodeName_ == 'ClrSys':
            obj_ = ClearingSystemIdentification3Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClrSys = obj_
            obj_.original_tagname_ = 'ClrSys'
        elif nodeName_ == 'InstgRmbrsmntAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstgRmbrsmntAgt = obj_
            obj_.original_tagname_ = 'InstgRmbrsmntAgt'
        elif nodeName_ == 'InstgRmbrsmntAgtAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstgRmbrsmntAgtAcct = obj_
            obj_.original_tagname_ = 'InstgRmbrsmntAgtAcct'
        elif nodeName_ == 'InstdRmbrsmntAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstdRmbrsmntAgt = obj_
            obj_.original_tagname_ = 'InstdRmbrsmntAgt'
        elif nodeName_ == 'InstdRmbrsmntAgtAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstdRmbrsmntAgtAcct = obj_
            obj_.original_tagname_ = 'InstdRmbrsmntAgtAcct'
        elif nodeName_ == 'ThrdRmbrsmntAgt':
            obj_ = BranchAndFinancialInstitutionIdentification6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ThrdRmbrsmntAgt = obj_
            obj_.original_tagname_ = 'ThrdRmbrsmntAgt'
        elif nodeName_ == 'ThrdRmbrsmntAgtAcct':
            obj_ = CashAccount38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ThrdRmbrsmntAgtAcct = obj_
            obj_.original_tagname_ = 'ThrdRmbrsmntAgtAcct'
# end class SettlementInstruction7


class SettlementTimeRequest2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'CLSTm': MemberSpec_('CLSTm', ['ISOTime', 'xs:time'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CLSTm', 'type': 'xs:time'}, None),
        'TillTm': MemberSpec_('TillTm', ['ISOTime', 'xs:time'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TillTm', 'type': 'xs:time'}, None),
        'FrTm': MemberSpec_('FrTm', ['ISOTime', 'xs:time'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'FrTm', 'type': 'xs:time'}, None),
        'RjctTm': MemberSpec_('RjctTm', ['ISOTime', 'xs:time'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RjctTm', 'type': 'xs:time'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, CLSTm=None, TillTm=None, FrTm=None, RjctTm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(CLSTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CLSTm, '%H:%M:%S').time()
        else:
            initvalue_ = CLSTm
        self.CLSTm = initvalue_
        self.CLSTm_nsprefix_ = None
        if isinstance(TillTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TillTm, '%H:%M:%S').time()
        else:
            initvalue_ = TillTm
        self.TillTm = initvalue_
        self.TillTm_nsprefix_ = None
        if isinstance(FrTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FrTm, '%H:%M:%S').time()
        else:
            initvalue_ = FrTm
        self.FrTm = initvalue_
        self.FrTm_nsprefix_ = None
        if isinstance(RjctTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RjctTm, '%H:%M:%S').time()
        else:
            initvalue_ = RjctTm
        self.RjctTm = initvalue_
        self.RjctTm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementTimeRequest2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementTimeRequest2.subclass:
            return SettlementTimeRequest2.subclass(*args_, **kwargs_)
        else:
            return SettlementTimeRequest2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CLSTm(self):
        return self.CLSTm
    def set_CLSTm(self, CLSTm):
        self.CLSTm = CLSTm
    def get_TillTm(self):
        return self.TillTm
    def set_TillTm(self, TillTm):
        self.TillTm = TillTm
    def get_FrTm(self):
        return self.FrTm
    def set_FrTm(self, FrTm):
        self.FrTm = FrTm
    def get_RjctTm(self):
        return self.RjctTm
    def set_RjctTm(self, RjctTm):
        self.RjctTm = RjctTm
    def validate_ISOTime(self, value):
        result = True
        # Validate type ISOTime, a restriction on xs:time.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.time):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.time)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.CLSTm is not None or
            self.TillTm is not None or
            self.FrTm is not None or
            self.RjctTm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SettlementTimeRequest2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SettlementTimeRequest2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SettlementTimeRequest2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SettlementTimeRequest2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SettlementTimeRequest2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SettlementTimeRequest2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SettlementTimeRequest2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CLSTm is not None:
            namespaceprefix_ = self.CLSTm_nsprefix_ + ':' if (UseCapturedNS_ and self.CLSTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCLSTm>%s</%sCLSTm>%s' % (namespaceprefix_ , self.gds_format_time(self.CLSTm, input_name='CLSTm'), namespaceprefix_ , eol_))
        if self.TillTm is not None:
            namespaceprefix_ = self.TillTm_nsprefix_ + ':' if (UseCapturedNS_ and self.TillTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTillTm>%s</%sTillTm>%s' % (namespaceprefix_ , self.gds_format_time(self.TillTm, input_name='TillTm'), namespaceprefix_ , eol_))
        if self.FrTm is not None:
            namespaceprefix_ = self.FrTm_nsprefix_ + ':' if (UseCapturedNS_ and self.FrTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFrTm>%s</%sFrTm>%s' % (namespaceprefix_ , self.gds_format_time(self.FrTm, input_name='FrTm'), namespaceprefix_ , eol_))
        if self.RjctTm is not None:
            namespaceprefix_ = self.RjctTm_nsprefix_ + ':' if (UseCapturedNS_ and self.RjctTm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRjctTm>%s</%sRjctTm>%s' % (namespaceprefix_ , self.gds_format_time(self.RjctTm, input_name='RjctTm'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CLSTm':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.CLSTm = dval_
            self.CLSTm_nsprefix_ = child_.prefix
            # validate type ISOTime
            self.validate_ISOTime(self.CLSTm)
        elif nodeName_ == 'TillTm':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.TillTm = dval_
            self.TillTm_nsprefix_ = child_.prefix
            # validate type ISOTime
            self.validate_ISOTime(self.TillTm)
        elif nodeName_ == 'FrTm':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.FrTm = dval_
            self.FrTm_nsprefix_ = child_.prefix
            # validate type ISOTime
            self.validate_ISOTime(self.FrTm)
        elif nodeName_ == 'RjctTm':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.RjctTm = dval_
            self.RjctTm_nsprefix_ = child_.prefix
            # validate type ISOTime
            self.validate_ISOTime(self.RjctTm)
# end class SettlementTimeRequest2


class StructuredRegulatoryReporting3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'xs:string'}, None),
        'Dt': MemberSpec_('Dt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dt', 'type': 'xs:date'}, None),
        'Ctry': MemberSpec_('Ctry', ['CountryCode', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Ctry', 'type': 'xs:string'}, None),
        'Cd': MemberSpec_('Cd', ['Max10Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Cd', 'type': 'xs:string'}, None),
        'Amt': MemberSpec_('Amt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Amt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'Inf': MemberSpec_('Inf', ['Max35Text', 'xs:string'], 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Inf', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Dt=None, Ctry=None, Cd=None, Amt=None, Inf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.validate_Max35Text(self.Tp)
        self.Tp_nsprefix_ = None
        if isinstance(Dt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Dt, '%Y-%m-%d').date()
        else:
            initvalue_ = Dt
        self.Dt = initvalue_
        self.Dt_nsprefix_ = None
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        self.Ctry_nsprefix_ = None
        self.Cd = Cd
        self.validate_Max10Text(self.Cd)
        self.Cd_nsprefix_ = None
        self.Amt = Amt
        self.Amt_nsprefix_ = None
        if Inf is None:
            self.Inf = []
        else:
            self.Inf = Inf
        self.Inf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructuredRegulatoryReporting3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructuredRegulatoryReporting3.subclass:
            return StructuredRegulatoryReporting3.subclass(*args_, **kwargs_)
        else:
            return StructuredRegulatoryReporting3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Dt(self):
        return self.Dt
    def set_Dt(self, Dt):
        self.Dt = Dt
    def get_Ctry(self):
        return self.Ctry
    def set_Ctry(self, Ctry):
        self.Ctry = Ctry
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Amt(self):
        return self.Amt
    def set_Amt(self, Amt):
        self.Amt = Amt
    def get_Inf(self):
        return self.Inf
    def set_Inf(self, Inf):
        self.Inf = Inf
    def add_Inf(self, value):
        self.Inf.append(value)
    def insert_Inf_at(self, index, value):
        self.Inf.insert(index, value)
    def replace_Inf_at(self, index, value):
        self.Inf[index] = value
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_CountryCode(self, value):
        result = True
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCode_patterns_, ))
                result = False
        return result
    validate_CountryCode_patterns_ = [['^([A-Z]{2,2})$']]
    def validate_Max10Text(self, value):
        result = True
        # Validate type Max10Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max10Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max10Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Tp is not None or
            self.Dt is not None or
            self.Ctry is not None or
            self.Cd is not None or
            self.Amt is not None or
            self.Inf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='StructuredRegulatoryReporting3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StructuredRegulatoryReporting3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StructuredRegulatoryReporting3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StructuredRegulatoryReporting3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StructuredRegulatoryReporting3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StructuredRegulatoryReporting3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='StructuredRegulatoryReporting3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTp>%s</%sTp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Tp), input_name='Tp')), namespaceprefix_ , eol_))
        if self.Dt is not None:
            namespaceprefix_ = self.Dt_nsprefix_ + ':' if (UseCapturedNS_ and self.Dt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDt>%s</%sDt>%s' % (namespaceprefix_ , self.gds_format_date(self.Dt, input_name='Dt'), namespaceprefix_ , eol_))
        if self.Ctry is not None:
            namespaceprefix_ = self.Ctry_nsprefix_ + ':' if (UseCapturedNS_ and self.Ctry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespaceprefix_ , eol_))
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Amt is not None:
            namespaceprefix_ = self.Amt_nsprefix_ + ':' if (UseCapturedNS_ and self.Amt_nsprefix_) else ''
            self.Amt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amt', pretty_print=pretty_print)
        for Inf_ in self.Inf:
            namespaceprefix_ = self.Inf_nsprefix_ + ':' if (UseCapturedNS_ and self.Inf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInf>%s</%sInf>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Inf_), input_name='Inf')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Tp')
            value_ = self.gds_validate_string(value_, node, 'Tp')
            self.Tp = value_
            self.Tp_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Tp)
        elif nodeName_ == 'Dt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Dt = dval_
            self.Dt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.Dt)
        elif nodeName_ == 'Ctry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ctry')
            value_ = self.gds_validate_string(value_, node, 'Ctry')
            self.Ctry = value_
            self.Ctry_nsprefix_ = child_.prefix
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
        elif nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type Max10Text
            self.validate_Max10Text(self.Cd)
        elif nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'Inf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Inf')
            value_ = self.gds_validate_string(value_, node, 'Inf')
            self.Inf.append(value_)
            self.Inf_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Inf[-1])
# end class StructuredRegulatoryReporting3


class StructuredRemittanceInformation16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'RfrdDocInf': MemberSpec_('RfrdDocInf', 'ReferredDocumentInformation7', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'RfrdDocInf', 'type': 'ReferredDocumentInformation7'}, None),
        'RfrdDocAmt': MemberSpec_('RfrdDocAmt', 'RemittanceAmount2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RfrdDocAmt', 'type': 'RemittanceAmount2'}, None),
        'CdtrRefInf': MemberSpec_('CdtrRefInf', 'CreditorReferenceInformation2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CdtrRefInf', 'type': 'CreditorReferenceInformation2'}, None),
        'Invcr': MemberSpec_('Invcr', 'PartyIdentification135', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Invcr', 'type': 'PartyIdentification135'}, None),
        'Invcee': MemberSpec_('Invcee', 'PartyIdentification135', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Invcee', 'type': 'PartyIdentification135'}, None),
        'TaxRmt': MemberSpec_('TaxRmt', 'TaxInformation7', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TaxRmt', 'type': 'TaxInformation7'}, None),
        'GrnshmtRmt': MemberSpec_('GrnshmtRmt', 'Garnishment3', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'GrnshmtRmt', 'type': 'Garnishment3'}, None),
        'AddtlRmtInf': MemberSpec_('AddtlRmtInf', ['Max140Text', 'xs:string'], 1, 1, {'maxOccurs': '3', 'minOccurs': '0', 'name': 'AddtlRmtInf', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, RfrdDocInf=None, RfrdDocAmt=None, CdtrRefInf=None, Invcr=None, Invcee=None, TaxRmt=None, GrnshmtRmt=None, AddtlRmtInf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RfrdDocInf is None:
            self.RfrdDocInf = []
        else:
            self.RfrdDocInf = RfrdDocInf
        self.RfrdDocInf_nsprefix_ = None
        self.RfrdDocAmt = RfrdDocAmt
        self.RfrdDocAmt_nsprefix_ = None
        self.CdtrRefInf = CdtrRefInf
        self.CdtrRefInf_nsprefix_ = None
        self.Invcr = Invcr
        self.Invcr_nsprefix_ = None
        self.Invcee = Invcee
        self.Invcee_nsprefix_ = None
        self.TaxRmt = TaxRmt
        self.TaxRmt_nsprefix_ = None
        self.GrnshmtRmt = GrnshmtRmt
        self.GrnshmtRmt_nsprefix_ = None
        if AddtlRmtInf is None:
            self.AddtlRmtInf = []
        else:
            self.AddtlRmtInf = AddtlRmtInf
        self.AddtlRmtInf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructuredRemittanceInformation16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructuredRemittanceInformation16.subclass:
            return StructuredRemittanceInformation16.subclass(*args_, **kwargs_)
        else:
            return StructuredRemittanceInformation16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RfrdDocInf(self):
        return self.RfrdDocInf
    def set_RfrdDocInf(self, RfrdDocInf):
        self.RfrdDocInf = RfrdDocInf
    def add_RfrdDocInf(self, value):
        self.RfrdDocInf.append(value)
    def insert_RfrdDocInf_at(self, index, value):
        self.RfrdDocInf.insert(index, value)
    def replace_RfrdDocInf_at(self, index, value):
        self.RfrdDocInf[index] = value
    def get_RfrdDocAmt(self):
        return self.RfrdDocAmt
    def set_RfrdDocAmt(self, RfrdDocAmt):
        self.RfrdDocAmt = RfrdDocAmt
    def get_CdtrRefInf(self):
        return self.CdtrRefInf
    def set_CdtrRefInf(self, CdtrRefInf):
        self.CdtrRefInf = CdtrRefInf
    def get_Invcr(self):
        return self.Invcr
    def set_Invcr(self, Invcr):
        self.Invcr = Invcr
    def get_Invcee(self):
        return self.Invcee
    def set_Invcee(self, Invcee):
        self.Invcee = Invcee
    def get_TaxRmt(self):
        return self.TaxRmt
    def set_TaxRmt(self, TaxRmt):
        self.TaxRmt = TaxRmt
    def get_GrnshmtRmt(self):
        return self.GrnshmtRmt
    def set_GrnshmtRmt(self, GrnshmtRmt):
        self.GrnshmtRmt = GrnshmtRmt
    def get_AddtlRmtInf(self):
        return self.AddtlRmtInf
    def set_AddtlRmtInf(self, AddtlRmtInf):
        self.AddtlRmtInf = AddtlRmtInf
    def add_AddtlRmtInf(self, value):
        self.AddtlRmtInf.append(value)
    def insert_AddtlRmtInf_at(self, index, value):
        self.AddtlRmtInf.insert(index, value)
    def replace_AddtlRmtInf_at(self, index, value):
        self.AddtlRmtInf[index] = value
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.RfrdDocInf or
            self.RfrdDocAmt is not None or
            self.CdtrRefInf is not None or
            self.Invcr is not None or
            self.Invcee is not None or
            self.TaxRmt is not None or
            self.GrnshmtRmt is not None or
            self.AddtlRmtInf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='StructuredRemittanceInformation16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StructuredRemittanceInformation16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StructuredRemittanceInformation16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StructuredRemittanceInformation16')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StructuredRemittanceInformation16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StructuredRemittanceInformation16'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='StructuredRemittanceInformation16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RfrdDocInf_ in self.RfrdDocInf:
            namespaceprefix_ = self.RfrdDocInf_nsprefix_ + ':' if (UseCapturedNS_ and self.RfrdDocInf_nsprefix_) else ''
            RfrdDocInf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RfrdDocInf', pretty_print=pretty_print)
        if self.RfrdDocAmt is not None:
            namespaceprefix_ = self.RfrdDocAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.RfrdDocAmt_nsprefix_) else ''
            self.RfrdDocAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RfrdDocAmt', pretty_print=pretty_print)
        if self.CdtrRefInf is not None:
            namespaceprefix_ = self.CdtrRefInf_nsprefix_ + ':' if (UseCapturedNS_ and self.CdtrRefInf_nsprefix_) else ''
            self.CdtrRefInf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CdtrRefInf', pretty_print=pretty_print)
        if self.Invcr is not None:
            namespaceprefix_ = self.Invcr_nsprefix_ + ':' if (UseCapturedNS_ and self.Invcr_nsprefix_) else ''
            self.Invcr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Invcr', pretty_print=pretty_print)
        if self.Invcee is not None:
            namespaceprefix_ = self.Invcee_nsprefix_ + ':' if (UseCapturedNS_ and self.Invcee_nsprefix_) else ''
            self.Invcee.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Invcee', pretty_print=pretty_print)
        if self.TaxRmt is not None:
            namespaceprefix_ = self.TaxRmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxRmt_nsprefix_) else ''
            self.TaxRmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxRmt', pretty_print=pretty_print)
        if self.GrnshmtRmt is not None:
            namespaceprefix_ = self.GrnshmtRmt_nsprefix_ + ':' if (UseCapturedNS_ and self.GrnshmtRmt_nsprefix_) else ''
            self.GrnshmtRmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrnshmtRmt', pretty_print=pretty_print)
        for AddtlRmtInf_ in self.AddtlRmtInf:
            namespaceprefix_ = self.AddtlRmtInf_nsprefix_ + ':' if (UseCapturedNS_ and self.AddtlRmtInf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddtlRmtInf>%s</%sAddtlRmtInf>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(AddtlRmtInf_), input_name='AddtlRmtInf')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RfrdDocInf':
            obj_ = ReferredDocumentInformation7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RfrdDocInf.append(obj_)
            obj_.original_tagname_ = 'RfrdDocInf'
        elif nodeName_ == 'RfrdDocAmt':
            obj_ = RemittanceAmount2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RfrdDocAmt = obj_
            obj_.original_tagname_ = 'RfrdDocAmt'
        elif nodeName_ == 'CdtrRefInf':
            obj_ = CreditorReferenceInformation2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CdtrRefInf = obj_
            obj_.original_tagname_ = 'CdtrRefInf'
        elif nodeName_ == 'Invcr':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Invcr = obj_
            obj_.original_tagname_ = 'Invcr'
        elif nodeName_ == 'Invcee':
            obj_ = PartyIdentification135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Invcee = obj_
            obj_.original_tagname_ = 'Invcee'
        elif nodeName_ == 'TaxRmt':
            obj_ = TaxInformation7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxRmt = obj_
            obj_.original_tagname_ = 'TaxRmt'
        elif nodeName_ == 'GrnshmtRmt':
            obj_ = Garnishment3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrnshmtRmt = obj_
            obj_.original_tagname_ = 'GrnshmtRmt'
        elif nodeName_ == 'AddtlRmtInf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AddtlRmtInf')
            value_ = self.gds_validate_string(value_, node, 'AddtlRmtInf')
            self.AddtlRmtInf.append(value_)
            self.AddtlRmtInf_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlRmtInf[-1])
# end class StructuredRemittanceInformation16


class SupplementaryData1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'PlcAndNm': MemberSpec_('PlcAndNm', ['Max350Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'PlcAndNm', 'type': 'xs:string'}, None),
        'Envlp': MemberSpec_('Envlp', 'SupplementaryDataEnvelope1', 0, 0, {'name': 'Envlp', 'type': 'SupplementaryDataEnvelope1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, PlcAndNm=None, Envlp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PlcAndNm = PlcAndNm
        self.validate_Max350Text(self.PlcAndNm)
        self.PlcAndNm_nsprefix_ = None
        self.Envlp = Envlp
        self.Envlp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplementaryData1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplementaryData1.subclass:
            return SupplementaryData1.subclass(*args_, **kwargs_)
        else:
            return SupplementaryData1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PlcAndNm(self):
        return self.PlcAndNm
    def set_PlcAndNm(self, PlcAndNm):
        self.PlcAndNm = PlcAndNm
    def get_Envlp(self):
        return self.Envlp
    def set_Envlp(self, Envlp):
        self.Envlp = Envlp
    def validate_Max350Text(self, value):
        result = True
        # Validate type Max350Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 350:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max350Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max350Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.PlcAndNm is not None or
            self.Envlp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SupplementaryData1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplementaryData1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplementaryData1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplementaryData1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplementaryData1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupplementaryData1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SupplementaryData1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PlcAndNm is not None:
            namespaceprefix_ = self.PlcAndNm_nsprefix_ + ':' if (UseCapturedNS_ and self.PlcAndNm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlcAndNm>%s</%sPlcAndNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PlcAndNm), input_name='PlcAndNm')), namespaceprefix_ , eol_))
        if self.Envlp is not None:
            namespaceprefix_ = self.Envlp_nsprefix_ + ':' if (UseCapturedNS_ and self.Envlp_nsprefix_) else ''
            self.Envlp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Envlp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PlcAndNm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PlcAndNm')
            value_ = self.gds_validate_string(value_, node, 'PlcAndNm')
            self.PlcAndNm = value_
            self.PlcAndNm_nsprefix_ = child_.prefix
            # validate type Max350Text
            self.validate_Max350Text(self.PlcAndNm)
        elif nodeName_ == 'Envlp':
            obj_ = SupplementaryDataEnvelope1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Envlp = obj_
            obj_.original_tagname_ = 'Envlp'
# end class SupplementaryData1


class SupplementaryDataEnvelope1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        '__ANY__': MemberSpec_('__ANY__', '__ANY__', 0, 0, {'namespace': '##any', 'processContents': 'lax'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplementaryDataEnvelope1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplementaryDataEnvelope1.subclass:
            return SupplementaryDataEnvelope1.subclass(*args_, **kwargs_)
        else:
            return SupplementaryDataEnvelope1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SupplementaryDataEnvelope1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplementaryDataEnvelope1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplementaryDataEnvelope1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplementaryDataEnvelope1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplementaryDataEnvelope1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupplementaryDataEnvelope1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='SupplementaryDataEnvelope1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'SupplementaryDataEnvelope1')
        self.set_anytypeobjs_(content_)
# end class SupplementaryDataEnvelope1


class TaxAmount2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Rate': MemberSpec_('Rate', ['PercentageRate', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Rate', 'type': 'xs:decimal'}, None),
        'TaxblBaseAmt': MemberSpec_('TaxblBaseAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TaxblBaseAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'TtlAmt': MemberSpec_('TtlAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TtlAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'Dtls': MemberSpec_('Dtls', 'TaxRecordDetails2', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Dtls', 'type': 'TaxRecordDetails2'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Rate=None, TaxblBaseAmt=None, TtlAmt=None, Dtls=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Rate = Rate
        self.validate_PercentageRate(self.Rate)
        self.Rate_nsprefix_ = None
        self.TaxblBaseAmt = TaxblBaseAmt
        self.TaxblBaseAmt_nsprefix_ = None
        self.TtlAmt = TtlAmt
        self.TtlAmt_nsprefix_ = None
        if Dtls is None:
            self.Dtls = []
        else:
            self.Dtls = Dtls
        self.Dtls_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxAmount2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxAmount2.subclass:
            return TaxAmount2.subclass(*args_, **kwargs_)
        else:
            return TaxAmount2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Rate(self):
        return self.Rate
    def set_Rate(self, Rate):
        self.Rate = Rate
    def get_TaxblBaseAmt(self):
        return self.TaxblBaseAmt
    def set_TaxblBaseAmt(self, TaxblBaseAmt):
        self.TaxblBaseAmt = TaxblBaseAmt
    def get_TtlAmt(self):
        return self.TtlAmt
    def set_TtlAmt(self, TtlAmt):
        self.TtlAmt = TtlAmt
    def get_Dtls(self):
        return self.Dtls
    def set_Dtls(self, Dtls):
        self.Dtls = Dtls
    def add_Dtls(self, value):
        self.Dtls.append(value)
    def insert_Dtls_at(self, index, value):
        self.Dtls.insert(index, value)
    def replace_Dtls_at(self, index, value):
        self.Dtls[index] = value
    def validate_PercentageRate(self, value):
        result = True
        # Validate type PercentageRate, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on PercentageRate' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Rate is not None or
            self.TaxblBaseAmt is not None or
            self.TtlAmt is not None or
            self.Dtls
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAmount2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxAmount2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxAmount2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxAmount2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxAmount2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxAmount2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAmount2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Rate is not None:
            namespaceprefix_ = self.Rate_nsprefix_ + ':' if (UseCapturedNS_ and self.Rate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRate>%s</%sRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Rate, input_name='Rate'), namespaceprefix_ , eol_))
        if self.TaxblBaseAmt is not None:
            namespaceprefix_ = self.TaxblBaseAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxblBaseAmt_nsprefix_) else ''
            self.TaxblBaseAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxblBaseAmt', pretty_print=pretty_print)
        if self.TtlAmt is not None:
            namespaceprefix_ = self.TtlAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TtlAmt_nsprefix_) else ''
            self.TtlAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TtlAmt', pretty_print=pretty_print)
        for Dtls_ in self.Dtls:
            namespaceprefix_ = self.Dtls_nsprefix_ + ':' if (UseCapturedNS_ and self.Dtls_nsprefix_) else ''
            Dtls_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dtls', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Rate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Rate')
            fval_ = self.gds_validate_decimal(fval_, node, 'Rate')
            self.Rate = fval_
            self.Rate_nsprefix_ = child_.prefix
            # validate type PercentageRate
            self.validate_PercentageRate(self.Rate)
        elif nodeName_ == 'TaxblBaseAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxblBaseAmt = obj_
            obj_.original_tagname_ = 'TaxblBaseAmt'
        elif nodeName_ == 'TtlAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TtlAmt = obj_
            obj_.original_tagname_ = 'TtlAmt'
        elif nodeName_ == 'Dtls':
            obj_ = TaxRecordDetails2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dtls.append(obj_)
            obj_.original_tagname_ = 'Dtls'
# end class TaxAmount2


class TaxAmountAndType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', 'TaxAmountType1Choice', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'TaxAmountType1Choice'}, None),
        'Amt': MemberSpec_('Amt', 'ActiveOrHistoricCurrencyAndAmount', 0, 0, {'name': 'Amt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Amt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.Tp_nsprefix_ = None
        self.Amt = Amt
        self.Amt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxAmountAndType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxAmountAndType1.subclass:
            return TaxAmountAndType1.subclass(*args_, **kwargs_)
        else:
            return TaxAmountAndType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Amt(self):
        return self.Amt
    def set_Amt(self, Amt):
        self.Amt = Amt
    def has__content(self):
        if (
            self.Tp is not None or
            self.Amt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAmountAndType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxAmountAndType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxAmountAndType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxAmountAndType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxAmountAndType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxAmountAndType1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAmountAndType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            self.Tp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tp', pretty_print=pretty_print)
        if self.Amt is not None:
            namespaceprefix_ = self.Amt_nsprefix_ + ':' if (UseCapturedNS_ and self.Amt_nsprefix_) else ''
            self.Amt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            obj_ = TaxAmountType1Choice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
# end class TaxAmountAndType1


class TaxAmountType1Choice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cd': MemberSpec_('Cd', ['ExternalTaxAmountType1Code', 'xs:string'], 0, 0, {'name': 'Cd', 'type': 'xs:string'}, 21),
        'Prtry': MemberSpec_('Prtry', ['Max35Text', 'xs:string'], 0, 0, {'name': 'Prtry', 'type': 'xs:string'}, 21),
    }
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cd = Cd
        self.validate_ExternalTaxAmountType1Code(self.Cd)
        self.Cd_nsprefix_ = None
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
        self.Prtry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxAmountType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxAmountType1Choice.subclass:
            return TaxAmountType1Choice.subclass(*args_, **kwargs_)
        else:
            return TaxAmountType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cd(self):
        return self.Cd
    def set_Cd(self, Cd):
        self.Cd = Cd
    def get_Prtry(self):
        return self.Prtry
    def set_Prtry(self, Prtry):
        self.Prtry = Prtry
    def validate_ExternalTaxAmountType1Code(self, value):
        result = True
        # Validate type ExternalTaxAmountType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ExternalTaxAmountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ExternalTaxAmountType1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAmountType1Choice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxAmountType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxAmountType1Choice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxAmountType1Choice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxAmountType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxAmountType1Choice'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAmountType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            namespaceprefix_ = self.Cd_nsprefix_ + ':' if (UseCapturedNS_ and self.Cd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespaceprefix_ , eol_))
        if self.Prtry is not None:
            namespaceprefix_ = self.Prtry_nsprefix_ + ':' if (UseCapturedNS_ and self.Prtry_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cd')
            value_ = self.gds_validate_string(value_, node, 'Cd')
            self.Cd = value_
            self.Cd_nsprefix_ = child_.prefix
            # validate type ExternalTaxAmountType1Code
            self.validate_ExternalTaxAmountType1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prtry')
            value_ = self.gds_validate_string(value_, node, 'Prtry')
            self.Prtry = value_
            self.Prtry_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class TaxAmountType1Choice


class TaxAuthorisation1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Titl': MemberSpec_('Titl', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Titl', 'type': 'xs:string'}, None),
        'Nm': MemberSpec_('Nm', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Nm', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Titl=None, Nm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Titl = Titl
        self.validate_Max35Text(self.Titl)
        self.Titl_nsprefix_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Nm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxAuthorisation1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxAuthorisation1.subclass:
            return TaxAuthorisation1.subclass(*args_, **kwargs_)
        else:
            return TaxAuthorisation1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Titl(self):
        return self.Titl
    def set_Titl(self, Titl):
        self.Titl = Titl
    def get_Nm(self):
        return self.Nm
    def set_Nm(self, Nm):
        self.Nm = Nm
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Titl is not None or
            self.Nm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAuthorisation1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxAuthorisation1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxAuthorisation1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxAuthorisation1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxAuthorisation1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxAuthorisation1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxAuthorisation1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Titl is not None:
            namespaceprefix_ = self.Titl_nsprefix_ + ':' if (UseCapturedNS_ and self.Titl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitl>%s</%sTitl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Titl), input_name='Titl')), namespaceprefix_ , eol_))
        if self.Nm is not None:
            namespaceprefix_ = self.Nm_nsprefix_ + ':' if (UseCapturedNS_ and self.Nm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Titl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Titl')
            value_ = self.gds_validate_string(value_, node, 'Titl')
            self.Titl = value_
            self.Titl_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Titl)
        elif nodeName_ == 'Nm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Nm')
            value_ = self.gds_validate_string(value_, node, 'Nm')
            self.Nm = value_
            self.Nm_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
# end class TaxAuthorisation1


class TaxInformation7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cdtr': MemberSpec_('Cdtr', 'TaxParty1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Cdtr', 'type': 'TaxParty1'}, None),
        'Dbtr': MemberSpec_('Dbtr', 'TaxParty2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dbtr', 'type': 'TaxParty2'}, None),
        'UltmtDbtr': MemberSpec_('UltmtDbtr', 'TaxParty2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'UltmtDbtr', 'type': 'TaxParty2'}, None),
        'AdmstnZone': MemberSpec_('AdmstnZone', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'AdmstnZone', 'type': 'xs:string'}, None),
        'RefNb': MemberSpec_('RefNb', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RefNb', 'type': 'xs:string'}, None),
        'Mtd': MemberSpec_('Mtd', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Mtd', 'type': 'xs:string'}, None),
        'TtlTaxblBaseAmt': MemberSpec_('TtlTaxblBaseAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TtlTaxblBaseAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'TtlTaxAmt': MemberSpec_('TtlTaxAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TtlTaxAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'Dt': MemberSpec_('Dt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dt', 'type': 'xs:date'}, None),
        'SeqNb': MemberSpec_('SeqNb', ['Number', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SeqNb', 'type': 'xs:decimal'}, None),
        'Rcrd': MemberSpec_('Rcrd', 'TaxRecord2', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Rcrd', 'type': 'TaxRecord2'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Cdtr=None, Dbtr=None, UltmtDbtr=None, AdmstnZone=None, RefNb=None, Mtd=None, TtlTaxblBaseAmt=None, TtlTaxAmt=None, Dt=None, SeqNb=None, Rcrd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cdtr = Cdtr
        self.Cdtr_nsprefix_ = None
        self.Dbtr = Dbtr
        self.Dbtr_nsprefix_ = None
        self.UltmtDbtr = UltmtDbtr
        self.UltmtDbtr_nsprefix_ = None
        self.AdmstnZone = AdmstnZone
        self.validate_Max35Text(self.AdmstnZone)
        self.AdmstnZone_nsprefix_ = None
        self.RefNb = RefNb
        self.validate_Max140Text(self.RefNb)
        self.RefNb_nsprefix_ = None
        self.Mtd = Mtd
        self.validate_Max35Text(self.Mtd)
        self.Mtd_nsprefix_ = None
        self.TtlTaxblBaseAmt = TtlTaxblBaseAmt
        self.TtlTaxblBaseAmt_nsprefix_ = None
        self.TtlTaxAmt = TtlTaxAmt
        self.TtlTaxAmt_nsprefix_ = None
        if isinstance(Dt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Dt, '%Y-%m-%d').date()
        else:
            initvalue_ = Dt
        self.Dt = initvalue_
        self.Dt_nsprefix_ = None
        self.SeqNb = SeqNb
        self.validate_Number(self.SeqNb)
        self.SeqNb_nsprefix_ = None
        if Rcrd is None:
            self.Rcrd = []
        else:
            self.Rcrd = Rcrd
        self.Rcrd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxInformation7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxInformation7.subclass:
            return TaxInformation7.subclass(*args_, **kwargs_)
        else:
            return TaxInformation7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cdtr(self):
        return self.Cdtr
    def set_Cdtr(self, Cdtr):
        self.Cdtr = Cdtr
    def get_Dbtr(self):
        return self.Dbtr
    def set_Dbtr(self, Dbtr):
        self.Dbtr = Dbtr
    def get_UltmtDbtr(self):
        return self.UltmtDbtr
    def set_UltmtDbtr(self, UltmtDbtr):
        self.UltmtDbtr = UltmtDbtr
    def get_AdmstnZone(self):
        return self.AdmstnZone
    def set_AdmstnZone(self, AdmstnZone):
        self.AdmstnZone = AdmstnZone
    def get_RefNb(self):
        return self.RefNb
    def set_RefNb(self, RefNb):
        self.RefNb = RefNb
    def get_Mtd(self):
        return self.Mtd
    def set_Mtd(self, Mtd):
        self.Mtd = Mtd
    def get_TtlTaxblBaseAmt(self):
        return self.TtlTaxblBaseAmt
    def set_TtlTaxblBaseAmt(self, TtlTaxblBaseAmt):
        self.TtlTaxblBaseAmt = TtlTaxblBaseAmt
    def get_TtlTaxAmt(self):
        return self.TtlTaxAmt
    def set_TtlTaxAmt(self, TtlTaxAmt):
        self.TtlTaxAmt = TtlTaxAmt
    def get_Dt(self):
        return self.Dt
    def set_Dt(self, Dt):
        self.Dt = Dt
    def get_SeqNb(self):
        return self.SeqNb
    def set_SeqNb(self, SeqNb):
        self.SeqNb = SeqNb
    def get_Rcrd(self):
        return self.Rcrd
    def set_Rcrd(self, Rcrd):
        self.Rcrd = Rcrd
    def add_Rcrd(self, value):
        self.Rcrd.append(value)
    def insert_Rcrd_at(self, index, value):
        self.Rcrd.insert(index, value)
    def replace_Rcrd_at(self, index, value):
        self.Rcrd[index] = value
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Number(self, value):
        result = True
        # Validate type Number, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Number' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cdtr is not None or
            self.Dbtr is not None or
            self.UltmtDbtr is not None or
            self.AdmstnZone is not None or
            self.RefNb is not None or
            self.Mtd is not None or
            self.TtlTaxblBaseAmt is not None or
            self.TtlTaxAmt is not None or
            self.Dt is not None or
            self.SeqNb is not None or
            self.Rcrd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxInformation7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxInformation7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxInformation7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxInformation7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxInformation7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxInformation7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxInformation7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cdtr is not None:
            namespaceprefix_ = self.Cdtr_nsprefix_ + ':' if (UseCapturedNS_ and self.Cdtr_nsprefix_) else ''
            self.Cdtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Cdtr', pretty_print=pretty_print)
        if self.Dbtr is not None:
            namespaceprefix_ = self.Dbtr_nsprefix_ + ':' if (UseCapturedNS_ and self.Dbtr_nsprefix_) else ''
            self.Dbtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dbtr', pretty_print=pretty_print)
        if self.UltmtDbtr is not None:
            namespaceprefix_ = self.UltmtDbtr_nsprefix_ + ':' if (UseCapturedNS_ and self.UltmtDbtr_nsprefix_) else ''
            self.UltmtDbtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UltmtDbtr', pretty_print=pretty_print)
        if self.AdmstnZone is not None:
            namespaceprefix_ = self.AdmstnZone_nsprefix_ + ':' if (UseCapturedNS_ and self.AdmstnZone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdmstnZone>%s</%sAdmstnZone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AdmstnZone), input_name='AdmstnZone')), namespaceprefix_ , eol_))
        if self.RefNb is not None:
            namespaceprefix_ = self.RefNb_nsprefix_ + ':' if (UseCapturedNS_ and self.RefNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefNb>%s</%sRefNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RefNb), input_name='RefNb')), namespaceprefix_ , eol_))
        if self.Mtd is not None:
            namespaceprefix_ = self.Mtd_nsprefix_ + ':' if (UseCapturedNS_ and self.Mtd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtd>%s</%sMtd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Mtd), input_name='Mtd')), namespaceprefix_ , eol_))
        if self.TtlTaxblBaseAmt is not None:
            namespaceprefix_ = self.TtlTaxblBaseAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TtlTaxblBaseAmt_nsprefix_) else ''
            self.TtlTaxblBaseAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TtlTaxblBaseAmt', pretty_print=pretty_print)
        if self.TtlTaxAmt is not None:
            namespaceprefix_ = self.TtlTaxAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TtlTaxAmt_nsprefix_) else ''
            self.TtlTaxAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TtlTaxAmt', pretty_print=pretty_print)
        if self.Dt is not None:
            namespaceprefix_ = self.Dt_nsprefix_ + ':' if (UseCapturedNS_ and self.Dt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDt>%s</%sDt>%s' % (namespaceprefix_ , self.gds_format_date(self.Dt, input_name='Dt'), namespaceprefix_ , eol_))
        if self.SeqNb is not None:
            namespaceprefix_ = self.SeqNb_nsprefix_ + ':' if (UseCapturedNS_ and self.SeqNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeqNb>%s</%sSeqNb>%s' % (namespaceprefix_ , self.gds_format_decimal(self.SeqNb, input_name='SeqNb'), namespaceprefix_ , eol_))
        for Rcrd_ in self.Rcrd:
            namespaceprefix_ = self.Rcrd_nsprefix_ + ':' if (UseCapturedNS_ and self.Rcrd_nsprefix_) else ''
            Rcrd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Rcrd', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cdtr':
            obj_ = TaxParty1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Cdtr = obj_
            obj_.original_tagname_ = 'Cdtr'
        elif nodeName_ == 'Dbtr':
            obj_ = TaxParty2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dbtr = obj_
            obj_.original_tagname_ = 'Dbtr'
        elif nodeName_ == 'UltmtDbtr':
            obj_ = TaxParty2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UltmtDbtr = obj_
            obj_.original_tagname_ = 'UltmtDbtr'
        elif nodeName_ == 'AdmstnZone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AdmstnZone')
            value_ = self.gds_validate_string(value_, node, 'AdmstnZone')
            self.AdmstnZone = value_
            self.AdmstnZone_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.AdmstnZone)
        elif nodeName_ == 'RefNb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RefNb')
            value_ = self.gds_validate_string(value_, node, 'RefNb')
            self.RefNb = value_
            self.RefNb_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.RefNb)
        elif nodeName_ == 'Mtd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Mtd')
            value_ = self.gds_validate_string(value_, node, 'Mtd')
            self.Mtd = value_
            self.Mtd_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Mtd)
        elif nodeName_ == 'TtlTaxblBaseAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TtlTaxblBaseAmt = obj_
            obj_.original_tagname_ = 'TtlTaxblBaseAmt'
        elif nodeName_ == 'TtlTaxAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TtlTaxAmt = obj_
            obj_.original_tagname_ = 'TtlTaxAmt'
        elif nodeName_ == 'Dt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Dt = dval_
            self.Dt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.Dt)
        elif nodeName_ == 'SeqNb' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'SeqNb')
            fval_ = self.gds_validate_decimal(fval_, node, 'SeqNb')
            self.SeqNb = fval_
            self.SeqNb_nsprefix_ = child_.prefix
            # validate type Number
            self.validate_Number(self.SeqNb)
        elif nodeName_ == 'Rcrd':
            obj_ = TaxRecord2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rcrd.append(obj_)
            obj_.original_tagname_ = 'Rcrd'
# end class TaxInformation7


class TaxInformation8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Cdtr': MemberSpec_('Cdtr', 'TaxParty1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Cdtr', 'type': 'TaxParty1'}, None),
        'Dbtr': MemberSpec_('Dbtr', 'TaxParty2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dbtr', 'type': 'TaxParty2'}, None),
        'AdmstnZone': MemberSpec_('AdmstnZone', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'AdmstnZone', 'type': 'xs:string'}, None),
        'RefNb': MemberSpec_('RefNb', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RefNb', 'type': 'xs:string'}, None),
        'Mtd': MemberSpec_('Mtd', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Mtd', 'type': 'xs:string'}, None),
        'TtlTaxblBaseAmt': MemberSpec_('TtlTaxblBaseAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TtlTaxblBaseAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'TtlTaxAmt': MemberSpec_('TtlTaxAmt', 'ActiveOrHistoricCurrencyAndAmount', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TtlTaxAmt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
        'Dt': MemberSpec_('Dt', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Dt', 'type': 'xs:date'}, None),
        'SeqNb': MemberSpec_('SeqNb', ['Number', 'xs:decimal'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'SeqNb', 'type': 'xs:decimal'}, None),
        'Rcrd': MemberSpec_('Rcrd', 'TaxRecord2', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Rcrd', 'type': 'TaxRecord2'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Cdtr=None, Dbtr=None, AdmstnZone=None, RefNb=None, Mtd=None, TtlTaxblBaseAmt=None, TtlTaxAmt=None, Dt=None, SeqNb=None, Rcrd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Cdtr = Cdtr
        self.Cdtr_nsprefix_ = None
        self.Dbtr = Dbtr
        self.Dbtr_nsprefix_ = None
        self.AdmstnZone = AdmstnZone
        self.validate_Max35Text(self.AdmstnZone)
        self.AdmstnZone_nsprefix_ = None
        self.RefNb = RefNb
        self.validate_Max140Text(self.RefNb)
        self.RefNb_nsprefix_ = None
        self.Mtd = Mtd
        self.validate_Max35Text(self.Mtd)
        self.Mtd_nsprefix_ = None
        self.TtlTaxblBaseAmt = TtlTaxblBaseAmt
        self.TtlTaxblBaseAmt_nsprefix_ = None
        self.TtlTaxAmt = TtlTaxAmt
        self.TtlTaxAmt_nsprefix_ = None
        if isinstance(Dt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Dt, '%Y-%m-%d').date()
        else:
            initvalue_ = Dt
        self.Dt = initvalue_
        self.Dt_nsprefix_ = None
        self.SeqNb = SeqNb
        self.validate_Number(self.SeqNb)
        self.SeqNb_nsprefix_ = None
        if Rcrd is None:
            self.Rcrd = []
        else:
            self.Rcrd = Rcrd
        self.Rcrd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxInformation8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxInformation8.subclass:
            return TaxInformation8.subclass(*args_, **kwargs_)
        else:
            return TaxInformation8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Cdtr(self):
        return self.Cdtr
    def set_Cdtr(self, Cdtr):
        self.Cdtr = Cdtr
    def get_Dbtr(self):
        return self.Dbtr
    def set_Dbtr(self, Dbtr):
        self.Dbtr = Dbtr
    def get_AdmstnZone(self):
        return self.AdmstnZone
    def set_AdmstnZone(self, AdmstnZone):
        self.AdmstnZone = AdmstnZone
    def get_RefNb(self):
        return self.RefNb
    def set_RefNb(self, RefNb):
        self.RefNb = RefNb
    def get_Mtd(self):
        return self.Mtd
    def set_Mtd(self, Mtd):
        self.Mtd = Mtd
    def get_TtlTaxblBaseAmt(self):
        return self.TtlTaxblBaseAmt
    def set_TtlTaxblBaseAmt(self, TtlTaxblBaseAmt):
        self.TtlTaxblBaseAmt = TtlTaxblBaseAmt
    def get_TtlTaxAmt(self):
        return self.TtlTaxAmt
    def set_TtlTaxAmt(self, TtlTaxAmt):
        self.TtlTaxAmt = TtlTaxAmt
    def get_Dt(self):
        return self.Dt
    def set_Dt(self, Dt):
        self.Dt = Dt
    def get_SeqNb(self):
        return self.SeqNb
    def set_SeqNb(self, SeqNb):
        self.SeqNb = SeqNb
    def get_Rcrd(self):
        return self.Rcrd
    def set_Rcrd(self, Rcrd):
        self.Rcrd = Rcrd
    def add_Rcrd(self, value):
        self.Rcrd.append(value)
    def insert_Rcrd_at(self, index, value):
        self.Rcrd.insert(index, value)
    def replace_Rcrd_at(self, index, value):
        self.Rcrd[index] = value
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Number(self, value):
        result = True
        # Validate type Number, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Number' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Cdtr is not None or
            self.Dbtr is not None or
            self.AdmstnZone is not None or
            self.RefNb is not None or
            self.Mtd is not None or
            self.TtlTaxblBaseAmt is not None or
            self.TtlTaxAmt is not None or
            self.Dt is not None or
            self.SeqNb is not None or
            self.Rcrd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxInformation8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxInformation8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxInformation8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxInformation8')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxInformation8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxInformation8'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxInformation8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cdtr is not None:
            namespaceprefix_ = self.Cdtr_nsprefix_ + ':' if (UseCapturedNS_ and self.Cdtr_nsprefix_) else ''
            self.Cdtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Cdtr', pretty_print=pretty_print)
        if self.Dbtr is not None:
            namespaceprefix_ = self.Dbtr_nsprefix_ + ':' if (UseCapturedNS_ and self.Dbtr_nsprefix_) else ''
            self.Dbtr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dbtr', pretty_print=pretty_print)
        if self.AdmstnZone is not None:
            namespaceprefix_ = self.AdmstnZone_nsprefix_ + ':' if (UseCapturedNS_ and self.AdmstnZone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdmstnZone>%s</%sAdmstnZone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AdmstnZone), input_name='AdmstnZone')), namespaceprefix_ , eol_))
        if self.RefNb is not None:
            namespaceprefix_ = self.RefNb_nsprefix_ + ':' if (UseCapturedNS_ and self.RefNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefNb>%s</%sRefNb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RefNb), input_name='RefNb')), namespaceprefix_ , eol_))
        if self.Mtd is not None:
            namespaceprefix_ = self.Mtd_nsprefix_ + ':' if (UseCapturedNS_ and self.Mtd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtd>%s</%sMtd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Mtd), input_name='Mtd')), namespaceprefix_ , eol_))
        if self.TtlTaxblBaseAmt is not None:
            namespaceprefix_ = self.TtlTaxblBaseAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TtlTaxblBaseAmt_nsprefix_) else ''
            self.TtlTaxblBaseAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TtlTaxblBaseAmt', pretty_print=pretty_print)
        if self.TtlTaxAmt is not None:
            namespaceprefix_ = self.TtlTaxAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TtlTaxAmt_nsprefix_) else ''
            self.TtlTaxAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TtlTaxAmt', pretty_print=pretty_print)
        if self.Dt is not None:
            namespaceprefix_ = self.Dt_nsprefix_ + ':' if (UseCapturedNS_ and self.Dt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDt>%s</%sDt>%s' % (namespaceprefix_ , self.gds_format_date(self.Dt, input_name='Dt'), namespaceprefix_ , eol_))
        if self.SeqNb is not None:
            namespaceprefix_ = self.SeqNb_nsprefix_ + ':' if (UseCapturedNS_ and self.SeqNb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeqNb>%s</%sSeqNb>%s' % (namespaceprefix_ , self.gds_format_decimal(self.SeqNb, input_name='SeqNb'), namespaceprefix_ , eol_))
        for Rcrd_ in self.Rcrd:
            namespaceprefix_ = self.Rcrd_nsprefix_ + ':' if (UseCapturedNS_ and self.Rcrd_nsprefix_) else ''
            Rcrd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Rcrd', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Cdtr':
            obj_ = TaxParty1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Cdtr = obj_
            obj_.original_tagname_ = 'Cdtr'
        elif nodeName_ == 'Dbtr':
            obj_ = TaxParty2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dbtr = obj_
            obj_.original_tagname_ = 'Dbtr'
        elif nodeName_ == 'AdmstnZone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AdmstnZone')
            value_ = self.gds_validate_string(value_, node, 'AdmstnZone')
            self.AdmstnZone = value_
            self.AdmstnZone_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.AdmstnZone)
        elif nodeName_ == 'RefNb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RefNb')
            value_ = self.gds_validate_string(value_, node, 'RefNb')
            self.RefNb = value_
            self.RefNb_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.RefNb)
        elif nodeName_ == 'Mtd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Mtd')
            value_ = self.gds_validate_string(value_, node, 'Mtd')
            self.Mtd = value_
            self.Mtd_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Mtd)
        elif nodeName_ == 'TtlTaxblBaseAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TtlTaxblBaseAmt = obj_
            obj_.original_tagname_ = 'TtlTaxblBaseAmt'
        elif nodeName_ == 'TtlTaxAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TtlTaxAmt = obj_
            obj_.original_tagname_ = 'TtlTaxAmt'
        elif nodeName_ == 'Dt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Dt = dval_
            self.Dt_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.Dt)
        elif nodeName_ == 'SeqNb' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'SeqNb')
            fval_ = self.gds_validate_decimal(fval_, node, 'SeqNb')
            self.SeqNb = fval_
            self.SeqNb_nsprefix_ = child_.prefix
            # validate type Number
            self.validate_Number(self.SeqNb)
        elif nodeName_ == 'Rcrd':
            obj_ = TaxRecord2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rcrd.append(obj_)
            obj_.original_tagname_ = 'Rcrd'
# end class TaxInformation8


class TaxParty1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'TaxId': MemberSpec_('TaxId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TaxId', 'type': 'xs:string'}, None),
        'RegnId': MemberSpec_('RegnId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RegnId', 'type': 'xs:string'}, None),
        'TaxTp': MemberSpec_('TaxTp', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TaxTp', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, TaxId=None, RegnId=None, TaxTp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TaxId = TaxId
        self.validate_Max35Text(self.TaxId)
        self.TaxId_nsprefix_ = None
        self.RegnId = RegnId
        self.validate_Max35Text(self.RegnId)
        self.RegnId_nsprefix_ = None
        self.TaxTp = TaxTp
        self.validate_Max35Text(self.TaxTp)
        self.TaxTp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxParty1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxParty1.subclass:
            return TaxParty1.subclass(*args_, **kwargs_)
        else:
            return TaxParty1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TaxId(self):
        return self.TaxId
    def set_TaxId(self, TaxId):
        self.TaxId = TaxId
    def get_RegnId(self):
        return self.RegnId
    def set_RegnId(self, RegnId):
        self.RegnId = RegnId
    def get_TaxTp(self):
        return self.TaxTp
    def set_TaxTp(self, TaxTp):
        self.TaxTp = TaxTp
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.TaxId is not None or
            self.RegnId is not None or
            self.TaxTp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxParty1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxParty1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxParty1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxParty1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxParty1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxParty1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxParty1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxId is not None:
            namespaceprefix_ = self.TaxId_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxId>%s</%sTaxId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TaxId), input_name='TaxId')), namespaceprefix_ , eol_))
        if self.RegnId is not None:
            namespaceprefix_ = self.RegnId_nsprefix_ + ':' if (UseCapturedNS_ and self.RegnId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegnId>%s</%sRegnId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RegnId), input_name='RegnId')), namespaceprefix_ , eol_))
        if self.TaxTp is not None:
            namespaceprefix_ = self.TaxTp_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxTp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxTp>%s</%sTaxTp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TaxTp), input_name='TaxTp')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TaxId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TaxId')
            value_ = self.gds_validate_string(value_, node, 'TaxId')
            self.TaxId = value_
            self.TaxId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.TaxId)
        elif nodeName_ == 'RegnId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RegnId')
            value_ = self.gds_validate_string(value_, node, 'RegnId')
            self.RegnId = value_
            self.RegnId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.RegnId)
        elif nodeName_ == 'TaxTp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TaxTp')
            value_ = self.gds_validate_string(value_, node, 'TaxTp')
            self.TaxTp = value_
            self.TaxTp_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.TaxTp)
# end class TaxParty1


class TaxParty2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'TaxId': MemberSpec_('TaxId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TaxId', 'type': 'xs:string'}, None),
        'RegnId': MemberSpec_('RegnId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'RegnId', 'type': 'xs:string'}, None),
        'TaxTp': MemberSpec_('TaxTp', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TaxTp', 'type': 'xs:string'}, None),
        'Authstn': MemberSpec_('Authstn', 'TaxAuthorisation1', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Authstn', 'type': 'TaxAuthorisation1'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, TaxId=None, RegnId=None, TaxTp=None, Authstn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TaxId = TaxId
        self.validate_Max35Text(self.TaxId)
        self.TaxId_nsprefix_ = None
        self.RegnId = RegnId
        self.validate_Max35Text(self.RegnId)
        self.RegnId_nsprefix_ = None
        self.TaxTp = TaxTp
        self.validate_Max35Text(self.TaxTp)
        self.TaxTp_nsprefix_ = None
        self.Authstn = Authstn
        self.Authstn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxParty2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxParty2.subclass:
            return TaxParty2.subclass(*args_, **kwargs_)
        else:
            return TaxParty2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TaxId(self):
        return self.TaxId
    def set_TaxId(self, TaxId):
        self.TaxId = TaxId
    def get_RegnId(self):
        return self.RegnId
    def set_RegnId(self, RegnId):
        self.RegnId = RegnId
    def get_TaxTp(self):
        return self.TaxTp
    def set_TaxTp(self, TaxTp):
        self.TaxTp = TaxTp
    def get_Authstn(self):
        return self.Authstn
    def set_Authstn(self, Authstn):
        self.Authstn = Authstn
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.TaxId is not None or
            self.RegnId is not None or
            self.TaxTp is not None or
            self.Authstn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxParty2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxParty2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxParty2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxParty2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxParty2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxParty2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxParty2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxId is not None:
            namespaceprefix_ = self.TaxId_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxId>%s</%sTaxId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TaxId), input_name='TaxId')), namespaceprefix_ , eol_))
        if self.RegnId is not None:
            namespaceprefix_ = self.RegnId_nsprefix_ + ':' if (UseCapturedNS_ and self.RegnId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegnId>%s</%sRegnId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RegnId), input_name='RegnId')), namespaceprefix_ , eol_))
        if self.TaxTp is not None:
            namespaceprefix_ = self.TaxTp_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxTp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxTp>%s</%sTaxTp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TaxTp), input_name='TaxTp')), namespaceprefix_ , eol_))
        if self.Authstn is not None:
            namespaceprefix_ = self.Authstn_nsprefix_ + ':' if (UseCapturedNS_ and self.Authstn_nsprefix_) else ''
            self.Authstn.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Authstn', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TaxId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TaxId')
            value_ = self.gds_validate_string(value_, node, 'TaxId')
            self.TaxId = value_
            self.TaxId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.TaxId)
        elif nodeName_ == 'RegnId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RegnId')
            value_ = self.gds_validate_string(value_, node, 'RegnId')
            self.RegnId = value_
            self.RegnId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.RegnId)
        elif nodeName_ == 'TaxTp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TaxTp')
            value_ = self.gds_validate_string(value_, node, 'TaxTp')
            self.TaxTp = value_
            self.TaxTp_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.TaxTp)
        elif nodeName_ == 'Authstn':
            obj_ = TaxAuthorisation1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Authstn = obj_
            obj_.original_tagname_ = 'Authstn'
# end class TaxParty2


class TaxPeriod2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Yr': MemberSpec_('Yr', ['ISODate', 'xs:date'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Yr', 'type': 'xs:date'}, None),
        'Tp': MemberSpec_('Tp', ['TaxRecordPeriod1Code', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'xs:string'}, None),
        'FrToDt': MemberSpec_('FrToDt', 'DatePeriod2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'FrToDt', 'type': 'DatePeriod2'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Yr=None, Tp=None, FrToDt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(Yr, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Yr, '%Y-%m-%d').date()
        else:
            initvalue_ = Yr
        self.Yr = initvalue_
        self.Yr_nsprefix_ = None
        self.Tp = Tp
        self.validate_TaxRecordPeriod1Code(self.Tp)
        self.Tp_nsprefix_ = None
        self.FrToDt = FrToDt
        self.FrToDt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxPeriod2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxPeriod2.subclass:
            return TaxPeriod2.subclass(*args_, **kwargs_)
        else:
            return TaxPeriod2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Yr(self):
        return self.Yr
    def set_Yr(self, Yr):
        self.Yr = Yr
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_FrToDt(self):
        return self.FrToDt
    def set_FrToDt(self, FrToDt):
        self.FrToDt = FrToDt
    def validate_ISODate(self, value):
        result = True
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_TaxRecordPeriod1Code(self, value):
        result = True
        # Validate type TaxRecordPeriod1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MM01', 'MM02', 'MM03', 'MM04', 'MM05', 'MM06', 'MM07', 'MM08', 'MM09', 'MM10', 'MM11', 'MM12', 'QTR1', 'QTR2', 'QTR3', 'QTR4', 'HLF1', 'HLF2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TaxRecordPeriod1Code' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Yr is not None or
            self.Tp is not None or
            self.FrToDt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxPeriod2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxPeriod2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxPeriod2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxPeriod2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxPeriod2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxPeriod2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxPeriod2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Yr is not None:
            namespaceprefix_ = self.Yr_nsprefix_ + ':' if (UseCapturedNS_ and self.Yr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYr>%s</%sYr>%s' % (namespaceprefix_ , self.gds_format_date(self.Yr, input_name='Yr'), namespaceprefix_ , eol_))
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTp>%s</%sTp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Tp), input_name='Tp')), namespaceprefix_ , eol_))
        if self.FrToDt is not None:
            namespaceprefix_ = self.FrToDt_nsprefix_ + ':' if (UseCapturedNS_ and self.FrToDt_nsprefix_) else ''
            self.FrToDt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FrToDt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Yr':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Yr = dval_
            self.Yr_nsprefix_ = child_.prefix
            # validate type ISODate
            self.validate_ISODate(self.Yr)
        elif nodeName_ == 'Tp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Tp')
            value_ = self.gds_validate_string(value_, node, 'Tp')
            self.Tp = value_
            self.Tp_nsprefix_ = child_.prefix
            # validate type TaxRecordPeriod1Code
            self.validate_TaxRecordPeriod1Code(self.Tp)
        elif nodeName_ == 'FrToDt':
            obj_ = DatePeriod2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FrToDt = obj_
            obj_.original_tagname_ = 'FrToDt'
# end class TaxPeriod2


class TaxRecord2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Tp': MemberSpec_('Tp', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Tp', 'type': 'xs:string'}, None),
        'Ctgy': MemberSpec_('Ctgy', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Ctgy', 'type': 'xs:string'}, None),
        'CtgyDtls': MemberSpec_('CtgyDtls', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CtgyDtls', 'type': 'xs:string'}, None),
        'DbtrSts': MemberSpec_('DbtrSts', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'DbtrSts', 'type': 'xs:string'}, None),
        'CertId': MemberSpec_('CertId', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'CertId', 'type': 'xs:string'}, None),
        'FrmsCd': MemberSpec_('FrmsCd', ['Max35Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'FrmsCd', 'type': 'xs:string'}, None),
        'Prd': MemberSpec_('Prd', 'TaxPeriod2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Prd', 'type': 'TaxPeriod2'}, None),
        'TaxAmt': MemberSpec_('TaxAmt', 'TaxAmount2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'TaxAmt', 'type': 'TaxAmount2'}, None),
        'AddtlInf': MemberSpec_('AddtlInf', ['Max140Text', 'xs:string'], 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'AddtlInf', 'type': 'xs:string'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Ctgy=None, CtgyDtls=None, DbtrSts=None, CertId=None, FrmsCd=None, Prd=None, TaxAmt=None, AddtlInf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Tp = Tp
        self.validate_Max35Text(self.Tp)
        self.Tp_nsprefix_ = None
        self.Ctgy = Ctgy
        self.validate_Max35Text(self.Ctgy)
        self.Ctgy_nsprefix_ = None
        self.CtgyDtls = CtgyDtls
        self.validate_Max35Text(self.CtgyDtls)
        self.CtgyDtls_nsprefix_ = None
        self.DbtrSts = DbtrSts
        self.validate_Max35Text(self.DbtrSts)
        self.DbtrSts_nsprefix_ = None
        self.CertId = CertId
        self.validate_Max35Text(self.CertId)
        self.CertId_nsprefix_ = None
        self.FrmsCd = FrmsCd
        self.validate_Max35Text(self.FrmsCd)
        self.FrmsCd_nsprefix_ = None
        self.Prd = Prd
        self.Prd_nsprefix_ = None
        self.TaxAmt = TaxAmt
        self.TaxAmt_nsprefix_ = None
        self.AddtlInf = AddtlInf
        self.validate_Max140Text(self.AddtlInf)
        self.AddtlInf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxRecord2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxRecord2.subclass:
            return TaxRecord2.subclass(*args_, **kwargs_)
        else:
            return TaxRecord2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tp(self):
        return self.Tp
    def set_Tp(self, Tp):
        self.Tp = Tp
    def get_Ctgy(self):
        return self.Ctgy
    def set_Ctgy(self, Ctgy):
        self.Ctgy = Ctgy
    def get_CtgyDtls(self):
        return self.CtgyDtls
    def set_CtgyDtls(self, CtgyDtls):
        self.CtgyDtls = CtgyDtls
    def get_DbtrSts(self):
        return self.DbtrSts
    def set_DbtrSts(self, DbtrSts):
        self.DbtrSts = DbtrSts
    def get_CertId(self):
        return self.CertId
    def set_CertId(self, CertId):
        self.CertId = CertId
    def get_FrmsCd(self):
        return self.FrmsCd
    def set_FrmsCd(self, FrmsCd):
        self.FrmsCd = FrmsCd
    def get_Prd(self):
        return self.Prd
    def set_Prd(self, Prd):
        self.Prd = Prd
    def get_TaxAmt(self):
        return self.TaxAmt
    def set_TaxAmt(self, TaxAmt):
        self.TaxAmt = TaxAmt
    def get_AddtlInf(self):
        return self.AddtlInf
    def set_AddtlInf(self, AddtlInf):
        self.AddtlInf = AddtlInf
    def validate_Max35Text(self, value):
        result = True
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max35Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Max140Text(self, value):
        result = True
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 140:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Max140Text' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Tp is not None or
            self.Ctgy is not None or
            self.CtgyDtls is not None or
            self.DbtrSts is not None or
            self.CertId is not None or
            self.FrmsCd is not None or
            self.Prd is not None or
            self.TaxAmt is not None or
            self.AddtlInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxRecord2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxRecord2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxRecord2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxRecord2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxRecord2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxRecord2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxRecord2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            namespaceprefix_ = self.Tp_nsprefix_ + ':' if (UseCapturedNS_ and self.Tp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTp>%s</%sTp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Tp), input_name='Tp')), namespaceprefix_ , eol_))
        if self.Ctgy is not None:
            namespaceprefix_ = self.Ctgy_nsprefix_ + ':' if (UseCapturedNS_ and self.Ctgy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtgy>%s</%sCtgy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Ctgy), input_name='Ctgy')), namespaceprefix_ , eol_))
        if self.CtgyDtls is not None:
            namespaceprefix_ = self.CtgyDtls_nsprefix_ + ':' if (UseCapturedNS_ and self.CtgyDtls_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtgyDtls>%s</%sCtgyDtls>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CtgyDtls), input_name='CtgyDtls')), namespaceprefix_ , eol_))
        if self.DbtrSts is not None:
            namespaceprefix_ = self.DbtrSts_nsprefix_ + ':' if (UseCapturedNS_ and self.DbtrSts_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDbtrSts>%s</%sDbtrSts>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DbtrSts), input_name='DbtrSts')), namespaceprefix_ , eol_))
        if self.CertId is not None:
            namespaceprefix_ = self.CertId_nsprefix_ + ':' if (UseCapturedNS_ and self.CertId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCertId>%s</%sCertId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CertId), input_name='CertId')), namespaceprefix_ , eol_))
        if self.FrmsCd is not None:
            namespaceprefix_ = self.FrmsCd_nsprefix_ + ':' if (UseCapturedNS_ and self.FrmsCd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFrmsCd>%s</%sFrmsCd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FrmsCd), input_name='FrmsCd')), namespaceprefix_ , eol_))
        if self.Prd is not None:
            namespaceprefix_ = self.Prd_nsprefix_ + ':' if (UseCapturedNS_ and self.Prd_nsprefix_) else ''
            self.Prd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prd', pretty_print=pretty_print)
        if self.TaxAmt is not None:
            namespaceprefix_ = self.TaxAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxAmt_nsprefix_) else ''
            self.TaxAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxAmt', pretty_print=pretty_print)
        if self.AddtlInf is not None:
            namespaceprefix_ = self.AddtlInf_nsprefix_ + ':' if (UseCapturedNS_ and self.AddtlInf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddtlInf>%s</%sAddtlInf>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AddtlInf), input_name='AddtlInf')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Tp')
            value_ = self.gds_validate_string(value_, node, 'Tp')
            self.Tp = value_
            self.Tp_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Tp)
        elif nodeName_ == 'Ctgy':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ctgy')
            value_ = self.gds_validate_string(value_, node, 'Ctgy')
            self.Ctgy = value_
            self.Ctgy_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.Ctgy)
        elif nodeName_ == 'CtgyDtls':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CtgyDtls')
            value_ = self.gds_validate_string(value_, node, 'CtgyDtls')
            self.CtgyDtls = value_
            self.CtgyDtls_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.CtgyDtls)
        elif nodeName_ == 'DbtrSts':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DbtrSts')
            value_ = self.gds_validate_string(value_, node, 'DbtrSts')
            self.DbtrSts = value_
            self.DbtrSts_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.DbtrSts)
        elif nodeName_ == 'CertId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CertId')
            value_ = self.gds_validate_string(value_, node, 'CertId')
            self.CertId = value_
            self.CertId_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.CertId)
        elif nodeName_ == 'FrmsCd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FrmsCd')
            value_ = self.gds_validate_string(value_, node, 'FrmsCd')
            self.FrmsCd = value_
            self.FrmsCd_nsprefix_ = child_.prefix
            # validate type Max35Text
            self.validate_Max35Text(self.FrmsCd)
        elif nodeName_ == 'Prd':
            obj_ = TaxPeriod2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prd = obj_
            obj_.original_tagname_ = 'Prd'
        elif nodeName_ == 'TaxAmt':
            obj_ = TaxAmount2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxAmt = obj_
            obj_.original_tagname_ = 'TaxAmt'
        elif nodeName_ == 'AddtlInf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AddtlInf')
            value_ = self.gds_validate_string(value_, node, 'AddtlInf')
            self.AddtlInf = value_
            self.AddtlInf_nsprefix_ = child_.prefix
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlInf)
# end class TaxRecord2


class TaxRecordDetails2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        'Prd': MemberSpec_('Prd', 'TaxPeriod2', 0, 1, {'maxOccurs': '1', 'minOccurs': '0', 'name': 'Prd', 'type': 'TaxPeriod2'}, None),
        'Amt': MemberSpec_('Amt', 'ActiveOrHistoricCurrencyAndAmount', 0, 0, {'name': 'Amt', 'type': 'ActiveOrHistoricCurrencyAndAmount'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, Prd=None, Amt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Prd = Prd
        self.Prd_nsprefix_ = None
        self.Amt = Amt
        self.Amt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxRecordDetails2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxRecordDetails2.subclass:
            return TaxRecordDetails2.subclass(*args_, **kwargs_)
        else:
            return TaxRecordDetails2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Prd(self):
        return self.Prd
    def set_Prd(self, Prd):
        self.Prd = Prd
    def get_Amt(self):
        return self.Amt
    def set_Amt(self, Amt):
        self.Amt = Amt
    def has__content(self):
        if (
            self.Prd is not None or
            self.Amt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxRecordDetails2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxRecordDetails2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxRecordDetails2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxRecordDetails2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxRecordDetails2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxRecordDetails2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" ', name_='TaxRecordDetails2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prd is not None:
            namespaceprefix_ = self.Prd_nsprefix_ + ':' if (UseCapturedNS_ and self.Prd_nsprefix_) else ''
            self.Prd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prd', pretty_print=pretty_print)
        if self.Amt is not None:
            namespaceprefix_ = self.Amt_nsprefix_ + ':' if (UseCapturedNS_ and self.Amt_nsprefix_) else ''
            self.Amt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Prd':
            obj_ = TaxPeriod2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prd = obj_
            obj_.original_tagname_ = 'Prd'
        elif nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
# end class TaxRecordDetails2


#
# End data representation classes.
#


GDSClassesMapping = {
    'Document': Document,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from pacs_008_001_08 import *\n\n')
        sys.stdout.write('import pacs_008_001_08 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08': [('ActiveCurrencyAndAmount_SimpleType',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ActiveCurrencyCode',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ActiveOrHistoricCurrencyAndAmount_SimpleType',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ActiveOrHistoricCurrencyCode',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('AddressType2Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('AnyBICDec2014Identifier',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('BICFIDec2014Identifier',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('BaseOneRate',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('BatchBookingIndicator',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ChargeBearerType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ClearingChannel2Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('CountryCode',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('CreditDebitCode',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('DecimalNumber',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('DocumentType3Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('DocumentType6Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Exact4AlphaNumericText',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalAccountIdentification1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalCashAccountType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalCashClearingSystem1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalCategoryPurpose1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalClearingSystemIdentification1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalDiscountAmountType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalDocumentLineType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalFinancialInstitutionIdentification1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalGarnishmentType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalLocalInstrument1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalOrganisationIdentification1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalPersonIdentification1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalProxyAccountType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalPurpose1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalServiceLevel1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ExternalTaxAmountType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('IBAN2007Identifier',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ISODate',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ISODateTime',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('ISOTime',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Instruction3Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Instruction4Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('LEIIdentifier',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max10Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max128Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max140Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max15NumericText',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max16Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max2048Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max34Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max350Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max35Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max4Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Max70Text',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('NamePrefix2Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Number',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('PercentageRate',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('PhoneNumber',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('PreferredContactMethod1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Priority2Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('Priority3Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('RegulatoryReportingType1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('RemittanceLocationMethod2Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('SettlementMethod1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('TaxRecordPeriod1Code',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('TrueFalseIndicator',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('UUIDv4Identifier',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'ST'),
                                                    ('AccountIdentification4Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('AccountSchemeName1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ActiveCurrencyAndAmount',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ActiveOrHistoricCurrencyAndAmount',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('AddressType3Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('BranchAndFinancialInstitutionIdentification6',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('BranchData3',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('CashAccount38',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('CashAccountType2Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('CategoryPurpose1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('Charges7',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ClearingSystemIdentification2Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ClearingSystemIdentification3Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ClearingSystemMemberIdentification2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('Contact4',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('CreditTransferTransaction39',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('CreditorReferenceInformation2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('CreditorReferenceType1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('CreditorReferenceType2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DateAndPlaceOfBirth1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DatePeriod2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DiscountAmountAndType1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DiscountAmountType1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('Document',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DocumentAdjustment1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DocumentLineIdentification1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DocumentLineInformation1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DocumentLineType1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('DocumentLineType1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('FIToFICustomerCreditTransferV08',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('FinancialIdentificationSchemeName1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('FinancialInstitutionIdentification18',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('Garnishment3',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GarnishmentType1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GarnishmentType1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GenericAccountIdentification1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GenericFinancialIdentification1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GenericIdentification30',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GenericOrganisationIdentification1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GenericPersonIdentification1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('GroupHeader93',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('InstructionForCreditorAgent1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('InstructionForNextAgent1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('LocalInstrument2Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('NameAndAddress16',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('OrganisationIdentification29',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('OrganisationIdentificationSchemeName1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('OtherContact1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('Party38Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('PartyIdentification135',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('PaymentIdentification7',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('PaymentTypeInformation28',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('PersonIdentification13',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('PersonIdentificationSchemeName1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('PostalAddress24',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ProxyAccountIdentification1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ProxyAccountType1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('Purpose2Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ReferredDocumentInformation7',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ReferredDocumentType3Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ReferredDocumentType4',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('RegulatoryAuthority2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('RegulatoryReporting3',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('RemittanceAmount2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('RemittanceAmount3',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('RemittanceInformation16',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('RemittanceLocation7',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('RemittanceLocationData1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('ServiceLevel8Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('SettlementDateTimeIndication1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('SettlementInstruction7',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('SettlementTimeRequest2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('StructuredRegulatoryReporting3',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('StructuredRemittanceInformation16',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('SupplementaryData1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('SupplementaryDataEnvelope1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxAmount2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxAmountAndType1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxAmountType1Choice',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxAuthorisation1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxInformation7',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxInformation8',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxParty1',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxParty2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxPeriod2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxRecord2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT'),
                                                    ('TaxRecordDetails2',
                                                     'xsd/pacs.008/pacs.008.001.08.xsd',
                                                     'CT')]}

__all__ = [
    "AccountIdentification4Choice",
    "AccountSchemeName1Choice",
    "ActiveCurrencyAndAmount",
    "ActiveOrHistoricCurrencyAndAmount",
    "AddressType3Choice",
    "BranchAndFinancialInstitutionIdentification6",
    "BranchData3",
    "CashAccount38",
    "CashAccountType2Choice",
    "CategoryPurpose1Choice",
    "Charges7",
    "ClearingSystemIdentification2Choice",
    "ClearingSystemIdentification3Choice",
    "ClearingSystemMemberIdentification2",
    "Contact4",
    "CreditTransferTransaction39",
    "CreditorReferenceInformation2",
    "CreditorReferenceType1Choice",
    "CreditorReferenceType2",
    "DateAndPlaceOfBirth1",
    "DatePeriod2",
    "DiscountAmountAndType1",
    "DiscountAmountType1Choice",
    "Document",
    "DocumentAdjustment1",
    "DocumentLineIdentification1",
    "DocumentLineInformation1",
    "DocumentLineType1",
    "DocumentLineType1Choice",
    "FIToFICustomerCreditTransferV08",
    "FinancialIdentificationSchemeName1Choice",
    "FinancialInstitutionIdentification18",
    "Garnishment3",
    "GarnishmentType1",
    "GarnishmentType1Choice",
    "GenericAccountIdentification1",
    "GenericFinancialIdentification1",
    "GenericIdentification30",
    "GenericOrganisationIdentification1",
    "GenericPersonIdentification1",
    "GroupHeader93",
    "InstructionForCreditorAgent1",
    "InstructionForNextAgent1",
    "LocalInstrument2Choice",
    "NameAndAddress16",
    "OrganisationIdentification29",
    "OrganisationIdentificationSchemeName1Choice",
    "OtherContact1",
    "Party38Choice",
    "PartyIdentification135",
    "PaymentIdentification7",
    "PaymentTypeInformation28",
    "PersonIdentification13",
    "PersonIdentificationSchemeName1Choice",
    "PostalAddress24",
    "ProxyAccountIdentification1",
    "ProxyAccountType1Choice",
    "Purpose2Choice",
    "ReferredDocumentInformation7",
    "ReferredDocumentType3Choice",
    "ReferredDocumentType4",
    "RegulatoryAuthority2",
    "RegulatoryReporting3",
    "RemittanceAmount2",
    "RemittanceAmount3",
    "RemittanceInformation16",
    "RemittanceLocation7",
    "RemittanceLocationData1",
    "ServiceLevel8Choice",
    "SettlementDateTimeIndication1",
    "SettlementInstruction7",
    "SettlementTimeRequest2",
    "StructuredRegulatoryReporting3",
    "StructuredRemittanceInformation16",
    "SupplementaryData1",
    "SupplementaryDataEnvelope1",
    "TaxAmount2",
    "TaxAmountAndType1",
    "TaxAmountType1Choice",
    "TaxAuthorisation1",
    "TaxInformation7",
    "TaxInformation8",
    "TaxParty1",
    "TaxParty2",
    "TaxPeriod2",
    "TaxRecord2",
    "TaxRecordDetails2"
]
